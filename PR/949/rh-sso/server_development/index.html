<?xml version='1.0' encoding='UTF-8'?>
<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" class="chrometwo"><head><title>Server Developer Guide</title><link rel="stylesheet" type="text/css" href="Common_Content/css/default.css"/><meta name="generator" content="publican v4.3.4"/><meta name="description" content="This guides consist of information for developers to customize Red Hat Single Sign-On 7.4"/><link rel="next" href="#preface" title="Chapter 1. Preface"/><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/><script type="text/javascript" src="Common_Content/scripts/jquery-1.7.1.min.js"> </script><script type="text/javascript" src="Common_Content/scripts/utils.js"> </script><script type="text/javascript" src="Common_Content/scripts/highlight.js/highlight.pack.js"> </script></head><body><div id="chrometwo"><div id="main"><div xml:lang="en-US" class="book" id="idm140046323819968"><div class="titlepage"><div><div class="producttitle"><span class="productname">Red Hat Single Sign-On</span> <span class="productnumber">7.4</span></div><div><h1 class="title">Server Developer Guide</h1></div><div><h2 class="subtitle">For Use with Red Hat Single Sign-On 7.4</h2></div><div><div xml:lang="en-US" class="authorgroup"><span class="orgname">Red Hat Customer Content Services</span></div></div><div><a href="#idm140046320197568">Legal Notice</a></div><div><div class="abstract"><p class="title"><strong>Abstract</strong></p><div class="para">
				This guides consist of information for developers to customize Red Hat Single Sign-On 7.4
			</div></div></div></div><hr/></div><div class="toc"><ul class="toc"><li><span class="chapter"><a href="#preface">1. Preface</a></span></li><li><span class="chapter"><a href="#admin_rest_api">2. Admin REST API</a></span><ul><li><span class="section"><a href="#examples_using_curl">2.1. Examples using CURL</a></span><ul><li><span class="section"><a href="#authenticate_with_username_and_password">2.1.1. Authenticate with username and password</a></span></li><li><span class="section"><a href="#authenticate_with_a_service_account">2.1.2. Authenticate with a service account</a></span></li></ul></li></ul></li><li><span class="chapter"><a href="#themes">3. Themes</a></span><ul><li><span class="section"><a href="#theme_types">3.1. Theme Types</a></span></li><li><span class="section"><a href="#configure_theme">3.2. Configure Theme</a></span></li><li><span class="section"><a href="#default_themes">3.3. Default Themes</a></span></li><li><span class="section"><a href="#creating_a_theme">3.4. Creating a Theme</a></span><ul><li><span class="section"><a href="#theme_properties">3.4.1. Theme Properties</a></span></li><li><span class="section"><a href="#stylesheets">3.4.2. Stylesheets</a></span></li><li><span class="section"><a href="#scripts">3.4.3. Scripts</a></span></li><li><span class="section"><a href="#images">3.4.4. Images</a></span></li><li><span class="section"><a href="#messages">3.4.5. Messages</a></span></li><li><span class="section"><a href="#internationalization">3.4.6. Internationalization</a></span></li><li><span class="section"><a href="#html_templates">3.4.7. HTML Templates</a></span></li><li><span class="section"><a href="#emails">3.4.8. Emails</a></span></li></ul></li><li><span class="section"><a href="#deploying_themes">3.5. Deploying Themes</a></span></li><li><span class="section"><a href="#theme_selector">3.6. Theme Selector</a></span></li><li><span class="section"><a href="#theme_resource">3.7. Theme Resources</a></span></li><li><span class="section"><a href="#locale_selector">3.8. Locale Selector</a></span></li></ul></li><li><span class="chapter"><a href="#custom_user_attributes">4. Custom User Attributes</a></span><ul><li><span class="section"><a href="#registration_page">4.1. Registration Page</a></span></li><li><span class="section"><a href="#account_management_console">4.2. Account Management Console</a></span></li></ul></li><li><span class="chapter"><a href="#identity_brokering_apis">5. Identity Brokering APIs</a></span><ul><li><span class="section"><a href="#retrieving_external_idp_tokens">5.1. Retrieving External IDP Tokens</a></span></li><li><span class="section"><a href="#client_initiated_account_linking">5.2. Client Initiated Account Linking</a></span><ul><li><span class="section"><a href="#refreshing_external_tokens">5.2.1. Refreshing External Tokens</a></span></li></ul></li></ul></li><li><span class="chapter"><a href="#providers">6. Service Provider Interfaces (SPI)</a></span><ul><li><span class="section"><a href="#implementing_an_spi">6.1. Implementing an SPI</a></span><ul><li><span class="section"><a href="#providers_admin_console">6.1.1. Show info from your SPI implementation in admin console</a></span></li></ul></li><li><span class="section"><a href="#registering_provider_implementations">6.2. Registering provider implementations</a></span><ul><li><span class="section"><a href="#using_the_red_hat_single_sign_on_deployer">6.2.1. Using the Red Hat Single Sign-On Deployer</a></span></li><li><span class="section"><a href="#register_a_provider_using_modules">6.2.2. Register a provider using Modules</a></span></li><li><span class="section"><a href="#disabling_a_provider">6.2.3. Disabling a provider</a></span></li></ul></li><li><span class="section"><a href="#leveraging_java_ee">6.3. Leveraging Java EE</a></span></li><li><span class="section"><a href="#script_providers">6.4. JavaScript Providers</a></span><ul><li><span class="section"><a href="#authenticator">6.4.1. Authenticator</a></span></li><li><span class="section"><a href="#create_a_jar_with_the_scripts_to_deploy">6.4.2. Create a JAR with the scripts to deploy</a></span></li><li><span class="section"><a href="#deploy_the_script_jar">6.4.3. Deploy the Script JAR</a></span></li><li><span class="section"><a href="#using_red_hat_single_sign_on_administration_console_to_upload_scripts">6.4.4. Using Red Hat Single Sign-On Administration Console to upload scripts</a></span></li></ul></li><li><span class="section"><a href="#available_spis">6.5. Available SPIs</a></span></li></ul></li><li><span class="chapter"><a href="#user-storage-spi">7. User Storage SPI</a></span><ul><li><span class="section"><a href="#provider_interfaces">7.1. Provider Interfaces</a></span></li><li><span class="section"><a href="#provider_capability_interfaces">7.2. Provider Capability Interfaces</a></span></li><li><span class="section"><a href="#model_interfaces">7.3. Model Interfaces</a></span><ul><li><span class="section"><a href="#storage_ids">7.3.1. Storage Ids</a></span></li></ul></li><li><span class="section"><a href="#packaging_and_deployment">7.4. Packaging and Deployment</a></span></li><li><span class="section"><a href="#simple_read_only_lookup_example">7.5. Simple Read-Only, Lookup Example</a></span><ul><li><span class="section"><a href="#provider_class">7.5.1. Provider Class</a></span></li><li><span class="section"><a href="#provider_factory_implementation">7.5.2. Provider Factory Implementation</a></span></li><li><span class="section"><a href="#packaging_and_deployment_2">7.5.3. Packaging and Deployment</a></span></li><li><span class="section"><a href="#enabling_the_provider_in_the_administration_console">7.5.4. Enabling the Provider in the Administration Console</a></span></li></ul></li><li><span class="section"><a href="#configuration_techniques">7.6. Configuration Techniques</a></span><ul><li><span class="section"><a href="#configuration_example">7.6.1. Configuration Example</a></span></li><li><span class="section"><a href="#configuring_the_provider_in_the_administration_console">7.6.2. Configuring the Provider in the Administration Console</a></span></li></ul></li><li><span class="section"><a href="#add_remove_user_and_query_capability_interfaces">7.7. Add/Remove User and Query Capability interfaces</a></span><ul><li><span class="section"><a href="#implementing_userregistrationprovider">7.7.1. Implementing UserRegistrationProvider</a></span></li><li><span class="section"><a href="#implementing_userqueryprovider">7.7.2. Implementing UserQueryProvider</a></span></li></ul></li><li><span class="section"><a href="#augmenting_external_storage">7.8. Augmenting External Storage</a></span><ul><li><span class="section"><a href="#augmentation_example">7.8.1. Augmentation Example</a></span></li></ul></li><li><span class="section"><a href="#import_implementation_strategy">7.9. Import Implementation Strategy</a></span><ul><li><span class="section"><a href="#importeduservalidation_interface">7.9.1. ImportedUserValidation Interface</a></span></li><li><span class="section"><a href="#importsynchronization_interface">7.9.2. ImportSynchronization Interface</a></span></li></ul></li><li><span class="section"><a href="#user_caches">7.10. User Caches</a></span><ul><li><span class="section"><a href="#managing_the_user_cache">7.10.1. Managing the user cache</a></span></li><li><span class="section"><a href="#onusercache_callback_interface">7.10.2. OnUserCache Callback Interface</a></span></li><li><span class="section"><a href="#cache_policies">7.10.3. Cache Policies</a></span></li></ul></li><li><span class="section"><a href="#leveraging_java_ee_2">7.11. Leveraging Java EE</a></span></li><li><span class="section"><a href="#rest_management_api">7.12. REST Management API</a></span></li><li><span class="section"><a href="#migrating_from_an_earlier_user_federation_spi">7.13. Migrating from an Earlier User Federation SPI</a></span><ul><li><span class="section"><a href="#import_vs_non_import">7.13.1. Import vs. Non-Import</a></span></li><li><span class="section"><a href="#userfederationprovider_vs_userstorageprovider">7.13.2. UserFederationProvider vs. UserStorageProvider</a></span></li><li><span class="section"><a href="#userfederationproviderfactory_vs_userstorageproviderfactory">7.13.3. UserFederationProviderFactory vs. UserStorageProviderFactory</a></span></li><li><span class="section"><a href="#upgrading_to_a_new_model">7.13.4. Upgrading to a New Model</a></span></li></ul></li></ul></li><li><span class="chapter"><a href="#vault-spi">8. Vault SPI</a></span><ul><li><span class="section"><a href="#vault_provider">8.1. Vault provider</a></span></li><li><span class="section"><a href="#consuming_values_from_vault">8.2. Consuming values from vault</a></span></li></ul></li></ul></div><section class="chapter" id="preface"><div class="titlepage"><div><div><h1 class="title">Chapter 1. Preface</h1></div></div></div><p>
			In some of the example listings, what is meant to be displayed on one line does not fit inside the available page width. These lines have been broken up. A '\' at the end of a line means that a break has been introduced to fit in the page, with the following lines indented. So:
		</p><pre class="screen">Let's pretend to have an extremely \
long line that \
does not fit
This one is short</pre><p>
			Is really:
		</p><pre class="screen">Let's pretend to have an extremely long line that does not fit
This one is short</pre></section><section class="chapter" id="admin_rest_api"><div class="titlepage"><div><div><h1 class="title">Chapter 2. Admin REST API</h1></div></div></div><p>
			Red Hat Single Sign-On comes with a fully functional Admin REST API with all features provided by the Admin Console.
		</p><p>
			To invoke the API you need to obtain an access token with the appropriate permissions. The required permissions are described in <a class="link" href="https://access.redhat.com/documentation/en-us/red_hat_single_sign-on/7.4/html-single/server_administration_guide/">Server Administration Guide</a>.
		</p><p>
			A token can be obtained by enabling authenticating to your application with Red Hat Single Sign-On; see the <a class="link" href="https://access.redhat.com/documentation/en-us/red_hat_single_sign-on/7.4/html-single/securing_applications_and_services_guide/">Securing Applications and Services Guide</a>. You can also use direct access grant to obtain an access token.
		</p><p>
			For complete documentation see <a class="link" href="https://access.redhat.com/documentation/en-us/red_hat_single_sign-on/7.4/html-single/api_documentation/index">API Documentation</a>.
		</p><section class="section" id="examples_using_curl"><div class="titlepage"><div><div><h2 class="title">2.1. Examples using CURL</h2></div></div></div><section class="section" id="authenticate_with_username_and_password"><div class="titlepage"><div><div><h3 class="title">2.1.1. Authenticate with username and password</h3></div></div></div><p>
					Obtain access token for user in the realm <code class="literal">master</code> with username <code class="literal">admin</code> and password <code class="literal">password</code>:
				</p><pre class="programlisting language-bash">curl \
  -d "client_id=admin-cli" \
  -d "username=admin" \
  -d "password=password" \
  -d "grant_type=password" \
  "http://localhost:8080/auth/realms/master/protocol/openid-connect/token"</pre><div class="admonition note"><div class="admonition_header">Note</div><div><p>
						By default this token expires in 1 minute
					</p></div></div><p>
					The result will be a JSON document. To invoke the API you need to extract the value of the <code class="literal">access_token</code> property. You can then invoke the API by including the value in the <code class="literal">Authorization</code> header of requests to the API.
				</p><p>
					The following example shows how to get the details of the master realm:
				</p><pre class="programlisting language-bash">curl \
  -H "Authorization: bearer eyJhbGciOiJSUz..." \
  "http://localhost:8080/auth/admin/realms/master"</pre></section><section class="section" id="authenticate_with_a_service_account"><div class="titlepage"><div><div><h3 class="title">2.1.2. Authenticate with a service account</h3></div></div></div><p>
					Before being able to authenticate against the Admin REST API using a <code class="literal">client_id</code> and a <code class="literal">client_secret</code> you need to make sure the client is configured as it follows:
				</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">
							<code class="literal">client_id</code> is a <span class="strong strong"><strong>confidential</strong></span> client that belongs to the realm <span class="strong strong"><strong>master</strong></span>
						</li><li class="listitem">
							<code class="literal">client_id</code> has <code class="literal">Service Accounts Enabled</code> option enabled
						</li><li class="listitem"><p class="simpara">
							<code class="literal">client_id</code> has a custom "Audience" mapper
						</p><div class="itemizedlist"><ul class="itemizedlist" type="circle"><li class="listitem">
									Included Client Audience: <code class="literal">security-admin-console</code>
								</li></ul></div></li></ul></div><p>
					Finally, check that <code class="literal">client_id</code> has the role 'admin' assigned in the "Service Account Roles" tab.
				</p><p>
					After that, you will be able to obtain an access token for the Admin REST API using <code class="literal">client_id</code> and <code class="literal">client_secret</code>:
				</p><pre class="programlisting language-bash">curl \
  -d "client_id=&lt;YOUR_CLIENT_ID&gt;" \
  -d "client_secret=&lt;YOUR_CLIENT_SECRET&gt;" \
  -d "grant_type=client_credentials" \
  "http://localhost:8080/auth/realms/master/protocol/openid-connect/token"</pre></section></section></section><section class="chapter" id="themes"><div class="titlepage"><div><div><h1 class="title">Chapter 3. Themes</h1></div></div></div><p>
			Red Hat Single Sign-On provides theme support for web pages and emails. This allows customizing the look and feel of end-user facing pages so they can be integrated with your applications.
		</p><div class="figure" id="idm140046319667472"><p class="title"><strong>Figure 3.1. Login page with sunrise example theme</strong></p><div class="figure-contents"><div class="mediaobject"><img src="images/login-sunrise.png" alt="login sunrise"/></div></div></div><section class="section" id="theme_types"><div class="titlepage"><div><div><h2 class="title">3.1. Theme Types</h2></div></div></div><p>
				A theme can provide one or more types to customize different aspects of Red Hat Single Sign-On. The types available are:
			</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">
						Account - Account management
					</li><li class="listitem">
						Admin - Admin console
					</li><li class="listitem">
						Email - Emails
					</li><li class="listitem">
						Login - Login forms
					</li><li class="listitem">
						Welcome - Welcome page
					</li></ul></div></section><section class="section" id="configure_theme"><div class="titlepage"><div><div><h2 class="title">3.2. Configure Theme</h2></div></div></div><p>
				All theme types, except welcome, are configured through the <code class="literal">Admin Console</code>. To change the theme used for a realm open the <code class="literal">Admin Console</code>, select your realm from the drop-down box in the top left corner. Under <code class="literal">Realm Settings</code> click <code class="literal">Themes</code>.
			</p><div class="admonition note"><div class="admonition_header">Note</div><div><p>
					To set the theme for the <code class="literal">master</code> admin console you need to set the admin console theme for the <code class="literal">master</code> realm. To see the changes to the admin console refresh the page.
				</p></div></div><p>
				To change the welcome theme you need to edit <code class="literal">standalone.xml</code>, <code class="literal">standalone-ha.xml</code>, or <code class="literal">domain.xml</code>.
			</p><p>
				Add <code class="literal">welcomeTheme</code> to the theme element, for example:
			</p><pre class="programlisting language-xml">&lt;theme&gt;
    ...
    &lt;welcomeTheme&gt;custom-theme&lt;/welcomeTheme&gt;
    ...
&lt;/theme&gt;</pre><p>
				If the server is running you need to restart the server for the changes to the welcome theme to take effect.
			</p></section><section class="section" id="default_themes"><div class="titlepage"><div><div><h2 class="title">3.3. Default Themes</h2></div></div></div><p>
				Red Hat Single Sign-On comes bundled with default themes in the server’s root <code class="literal">themes</code> directory. To simplify upgrading you should not edit the bundled themes directly. Instead create your own theme that extends one of the bundled themes.
			</p></section><section class="section" id="creating_a_theme"><div class="titlepage"><div><div><h2 class="title">3.4. Creating a Theme</h2></div></div></div><p>
				A theme consists of:
			</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">
						HTML templates (<a class="link" href="https://freemarker.apache.org/">Freemarker Templates</a>)
					</li><li class="listitem">
						Images
					</li><li class="listitem">
						Message bundles
					</li><li class="listitem">
						Stylesheets
					</li><li class="listitem">
						Scripts
					</li><li class="listitem">
						Theme properties
					</li></ul></div><p>
				Unless you plan to replace every single page you should extend another theme. Most likely you will want to extend the Red Hat Single Sign-On theme, but you could also consider extending the base theme if you are significantly changing the look and feel of the pages. The base theme primarily consists of HTML templates and message bundles, while the Red Hat Single Sign-On theme primarily contains images and stylesheets.
			</p><p>
				When extending a theme you can override individual resources (templates, stylesheets, etc.). If you decide to override HTML templates bear in mind that you may need to update your custom template when upgrading to a new release.
			</p><p>
				While creating a theme it’s a good idea to disable caching as this makes it possible to edit theme resources directly from the <code class="literal">themes</code> directory without restarting Red Hat Single Sign-On. To do this edit <code class="literal">standalone.xml</code>. For <code class="literal">theme</code> set <code class="literal">staticMaxAge</code> to <code class="literal">-1</code> and both <code class="literal">cacheTemplates</code> and <code class="literal">cacheThemes</code> to <code class="literal">false</code>:
			</p><pre class="programlisting language-xml">&lt;theme&gt;
    &lt;staticMaxAge&gt;-1&lt;/staticMaxAge&gt;
    &lt;cacheThemes&gt;false&lt;/cacheThemes&gt;
    &lt;cacheTemplates&gt;false&lt;/cacheTemplates&gt;
    ...
&lt;/theme&gt;</pre><p>
				Remember to re-enable caching in production as it will significantly impact performance.
			</p><p>
				To create a new theme start by creating a new directory in the <code class="literal">themes</code> directory. The name of the directory becomes the name of the theme. For example to create a theme called <code class="literal">mytheme</code> create the directory <code class="literal">themes/mytheme</code>.
			</p><p>
				Inside the theme directory create a directory for each of the types your theme is going to provide. For example to add the login type to the <code class="literal">mytheme</code> theme create the directory <code class="literal">themes/mytheme/login</code>.
			</p><p>
				For each type create a file <code class="literal">theme.properties</code> which allows setting some configuration for the theme. For example to configure the theme <code class="literal">themes/mytheme/login</code> that we just created to extend the base theme and import some common resources create the file <code class="literal">themes/mytheme/login/theme.properties</code> with following contents:
			</p><pre class="screen">parent=base
import=common/keycloak</pre><p>
				You have now created a theme with support for the login type. To check that it works open the admin console. Select your realm and click on <code class="literal">Themes</code>. For <code class="literal">Login Theme</code> select <code class="literal">mytheme</code> and click <code class="literal">Save</code>. Then open the login page for the realm.
			</p><p>
				You can do this either by login through your application or by opening the Account Management console (<code class="literal">/realms/{realm name}/account</code>).
			</p><p>
				To see the effect of changing the parent theme, set <code class="literal">parent=keycloak</code> in <code class="literal">theme.properties</code> and refresh the login page.
			</p><section class="section" id="theme_properties"><div class="titlepage"><div><div><h3 class="title">3.4.1. Theme Properties</h3></div></div></div><p>
					Theme properties are set in the file <code class="literal">&lt;THEME TYPE&gt;/theme.properties</code> in the theme directory.
				</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">
							parent - Parent theme to extend
						</li><li class="listitem">
							import - Import resources from another theme
						</li><li class="listitem">
							styles - Space-separated list of styles to include
						</li><li class="listitem">
							locales - Comma-separated list of supported locales
						</li></ul></div><p>
					There are a list of properties that can be used to change the css class used for certain element types. For a list of these properties look at the theme.properties file in the corresponding type of the keycloak theme (<code class="literal">themes/keycloak/&lt;THEME TYPE&gt;/theme.properties</code>).
				</p><p>
					You can also add your own custom properties and use them from custom templates.
				</p><p>
					When doing so, you can substitute system properties or environment variables by using these formats:
				</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">
							<code class="literal">${some.system.property}</code> - for system properties
						</li><li class="listitem">
							<code class="literal">${env.ENV_VAR}</code> - for environment variables.
						</li></ul></div><p>
					A default value can also be provided in case the system property or the environment variable is not found with <code class="literal">${foo:defaultValue}</code>.
				</p><div class="admonition note"><div class="admonition_header">Note</div><div><p>
						If no default value is provided and there’s no corresponding system property or environment variable, then nothing is replaced and you end up with the format in your template.
					</p></div></div><p>
					Here’s an example of what is possible:
				</p><pre class="programlisting language-properties">javaVersion=${java.version}

unixHome=${env.HOME:Unix home not found}
windowsHome=${env.HOMEPATH:Windows home not found}</pre></section><section class="section" id="stylesheets"><div class="titlepage"><div><div><h3 class="title">3.4.2. Stylesheets</h3></div></div></div><p>
					A theme can have one or more stylesheets. To add a stylesheet create a file in the <code class="literal">&lt;THEME TYPE&gt;/resources/css</code> directory of your theme. Then add it to the <code class="literal">styles</code> property in <code class="literal">theme.properties</code>.
				</p><p>
					For example to add <code class="literal">styles.css</code> to the <code class="literal">mytheme</code> create <code class="literal">themes/mytheme/login/resources/css/styles.css</code> with the following content:
				</p><pre class="programlisting language-css">.login-pf body {
    background: DimGrey none;
}</pre><p>
					Then edit <code class="literal">themes/mytheme/login/theme.properties</code> and add:
				</p><pre class="screen">styles=css/styles.css</pre><p>
					To see the changes open the login page for your realm. You will notice that the only styles being applied are those from your custom stylesheet. To include the styles from the parent theme you need to load the styles from that theme as well. Do this by editing <code class="literal">themes/mytheme/login/theme.properties</code> and changing <code class="literal">styles</code> to:
				</p><pre class="screen">styles=node_modules/patternfly/dist/css/patternfly.css node_modules/patternfly/dist/css/patternfly-additions.css lib/zocial/zocial.css css/login.css css/styles.css</pre><div class="admonition note"><div class="admonition_header">Note</div><div><p>
						To override styles from the parent stylesheets it’s important that your stylesheet is listed last.
					</p></div></div></section><section class="section" id="scripts"><div class="titlepage"><div><div><h3 class="title">3.4.3. Scripts</h3></div></div></div><p>
					A theme can have one or more scripts, to add a script create a file in the <code class="literal">&lt;THEME TYPE&gt;/resources/js</code> directory of your theme. Then add it to the <code class="literal">scripts</code> property in <code class="literal">theme.properties</code>.
				</p><p>
					For example to add <code class="literal">script.js</code> to the <code class="literal">mytheme</code> create <code class="literal">themes/mytheme/login/resources/js/script.js</code> with the following content:
				</p><pre class="programlisting language-javascript">alert('Hello');</pre><p>
					Then edit <code class="literal">themes/mytheme/login/theme.properties</code> and add:
				</p><pre class="screen">scripts=js/script.js</pre></section><section class="section" id="images"><div class="titlepage"><div><div><h3 class="title">3.4.4. Images</h3></div></div></div><p>
					To make images available to the theme add them to the <code class="literal">&lt;THEME TYPE&gt;/resources/img</code> directory of your theme. These can be used from within stylesheets or directly in HTML templates.
				</p><p>
					For example to add an image to the <code class="literal">mytheme</code> copy an image to <code class="literal">themes/mytheme/login/resources/img/image.jpg</code>.
				</p><p>
					You can then use this image from within a custom stylesheet with:
				</p><pre class="programlisting language-css">body {
    background-image: url('../img/image.jpg');
    background-size: cover;
}</pre><p>
					Or to use directly in HTML templates add the following to a custom HTML template:
				</p><pre class="programlisting language-html">&lt;img src="${url.resourcesPath}/img/image.jpg"&gt;</pre></section><section class="section" id="messages"><div class="titlepage"><div><div><h3 class="title">3.4.5. Messages</h3></div></div></div><p>
					Text in the templates is loaded from message bundles. A theme that extends another theme will inherit all messages from the parent’s message bundle and you can override individual messages by adding <code class="literal">&lt;THEME TYPE&gt;/messages/messages_en.properties</code> to your theme.
				</p><p>
					For example to replace <code class="literal">Username</code> on the login form with <code class="literal">Your Username</code> for the <code class="literal">mytheme</code> create the file <code class="literal">themes/mytheme/login/messages/messages_en.properties</code> with the following content:
				</p><pre class="screen">usernameOrEmail=Your Username</pre><p>
					Within a message values like <code class="literal">{0}</code> and <code class="literal">{1}</code> are replaced with arguments when the message is used. For example {0} in <code class="literal">Log in to {0}</code> is replaced with the name of the realm.
				</p></section><section class="section" id="internationalization"><div class="titlepage"><div><div><h3 class="title">3.4.6. Internationalization</h3></div></div></div><p>
					Red Hat Single Sign-On supports internationalization. To enable internationalization for a realm see <a class="link" href="https://access.redhat.com/documentation/en-us/red_hat_single_sign-on/7.4/html-single/server_administration_guide/">Server Administration Guide</a>. This section describes how you can add your own language.
				</p><p>
					To add a new language create the file <code class="literal">&lt;THEME TYPE&gt;/messages/messages_&lt;LOCALE&gt;.properties</code> in the directory of your theme. Then add it to the <code class="literal">locales</code> property in <code class="literal">&lt;THEME TYPE&gt;/theme.properties</code>. For a language to be available to users the realms <code class="literal">login</code>, <code class="literal">account</code> and <code class="literal">email</code> theme has to support the language, so you need to add your language for those theme types.
				</p><p>
					For example, to add Norwegian translations to the <code class="literal">mytheme</code> theme create the file <code class="literal">themes/mytheme/login/messages/messages_no.properties</code> with the following content:
				</p><pre class="screen">usernameOrEmail=Brukernavn
password=Passord</pre><p>
					All messages you don’t provide a translation for will use the default English translation.
				</p><p>
					Then edit <code class="literal">themes/mytheme/login/theme.properties</code> and add:
				</p><pre class="screen">locales=en,no</pre><p>
					You also need to do the same for the <code class="literal">account</code> and <code class="literal">email</code> theme types. To do this create <code class="literal">themes/mytheme/account/messages/messages_no.properties</code> and <code class="literal">themes/mytheme/email/messages/messages_no.properties</code>. Leaving these files empty will result in the English messages being used. Then copy <code class="literal">themes/mytheme/login/theme.properties</code> to <code class="literal">themes/mytheme/account/theme.properties</code> and <code class="literal">themes/mytheme/email/theme.properties</code>.
				</p><p>
					Finally you need to add a translation for the language selector. This is done by adding a message to the English translation. To do this add the following to <code class="literal">themes/mytheme/account/messages/messages_en.properties</code> and <code class="literal">themes/mytheme/login/messages/messages_en.properties</code>:
				</p><pre class="screen">locale_no=Norsk</pre><p>
					By default message properties files should be encoded using ISO-8859-1. It’s also possible to specify the encoding using a special header. For example to use UTF-8 encoding:
				</p><pre class="screen"># encoding: UTF-8
usernameOrEmail=....</pre><p>
					See <a class="link" href="#locale_selector" title="3.8. Locale Selector">Locale Selector</a> on details on how the current locale is selected.
				</p></section><section class="section" id="html_templates"><div class="titlepage"><div><div><h3 class="title">3.4.7. HTML Templates</h3></div></div></div><p>
					Red Hat Single Sign-On uses <a class="link" href="https://freemarker.apache.org/">Freemarker Templates</a> in order to generate HTML. You can override individual templates in your own theme by creating <code class="literal">&lt;THEME TYPE&gt;/&lt;TEMPLATE&gt;.ftl</code>. For a list of templates used see <code class="literal">themes/base/&lt;THEME TYPE&gt;</code>.
				</p><p>
					When creating a custom template it is a good idea to copy the template from the base theme to your own theme, then applying the modifications you need. Bear in mind when upgrading to a new version of Red Hat Single Sign-On you may need to update your custom templates to apply changes to the original template if applicable.
				</p><p>
					For example to create a custom login form for the <code class="literal">mytheme</code> theme copy <code class="literal">themes/base/login/login.ftl</code> to <code class="literal">themes/mytheme/login</code> and open it in an editor. After the first line (&lt;#import …​&gt;) add <code class="literal">&lt;h1&gt;HELLO WORLD!&lt;/h1&gt;</code> like so:
				</p><pre class="programlisting language-html">&lt;#import "template.ftl" as layout&gt;
&lt;h1&gt;HELLO WORLD!&lt;/h1&gt;
...</pre><p>
					Check out the <a class="link" href="https://freemarker.apache.org/docs/index.html">FreeMarker Manual</a> for more details on how to edit templates.
				</p></section><section class="section" id="emails"><div class="titlepage"><div><div><h3 class="title">3.4.8. Emails</h3></div></div></div><p>
					To edit the subject and contents for emails, for example password recovery email, add a message bundle to the <code class="literal">email</code> type of your theme. There are three messages for each email. One for the subject, one for the plain text body and one for the html body.
				</p><p>
					To see all emails available take a look at <code class="literal">themes/base/email/messages/messages_en.properties</code>.
				</p><p>
					For example to change the password recovery email for the <code class="literal">mytheme</code> theme create <code class="literal">themes/mytheme/email/messages/messages_en.properties</code> with the following content:
				</p><pre class="screen">passwordResetSubject=My password recovery
passwordResetBody=Reset password link: {0}
passwordResetBodyHtml=&lt;a href="{0}"&gt;Reset password&lt;/a&gt;</pre></section></section><section class="section" id="deploying_themes"><div class="titlepage"><div><div><h2 class="title">3.5. Deploying Themes</h2></div></div></div><p>
				Themes can be deployed to Red Hat Single Sign-On by copying the theme directory to <code class="literal">themes</code> or it can be deployed as an archive. During development you can copy the theme to the <code class="literal">themes</code> directory, but in production you may want to consider using an <code class="literal">archive</code>. An <code class="literal">archive</code> makes it simpler to have a versioned copy of the theme, especially when you have multiple instances of Red Hat Single Sign-On for example with clustering.
			</p><p>
				To deploy a theme as an archive you need to create a JAR archive with the theme resources. You also need to add a file <code class="literal">META-INF/keycloak-themes.json</code> to the archive that lists the available themes in the archive as well as what types each theme provides.
			</p><p>
				For example for the <code class="literal">mytheme</code> theme create <code class="literal">mytheme.jar</code> with the contents:
			</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">
						META-INF/keycloak-themes.json
					</li><li class="listitem">
						theme/mytheme/login/theme.properties
					</li><li class="listitem">
						theme/mytheme/login/login.ftl
					</li><li class="listitem">
						theme/mytheme/login/resources/css/styles.css
					</li><li class="listitem">
						theme/mytheme/login/resources/img/image.png
					</li><li class="listitem">
						theme/mytheme/login/messages/messages_en.properties
					</li><li class="listitem">
						theme/mytheme/email/messages/messages_en.properties
					</li></ul></div><p>
				The contents of <code class="literal">META-INF/keycloak-themes.json</code> in this case would be:
			</p><pre class="programlisting language-json">{
    "themes": [{
        "name" : "mytheme",
        "types": [ "login", "email" ]
    }]
}</pre><p>
				A single archive can contain multiple themes and each theme can support one or more types.
			</p><p>
				To deploy the archive to Red Hat Single Sign-On simply drop it into the <code class="literal">standalone/deployments/</code> directory of Red Hat Single Sign-On and it will be automatically loaded.
			</p></section><section class="section" id="theme_selector"><div class="titlepage"><div><div><h2 class="title">3.6. Theme Selector</h2></div></div></div><p>
				By default the theme configured for the realm is used, with the exception of clients being able to override the login theme. This behavior can be changed through the Theme Selector SPI.
			</p><p>
				This could be used to select different themes for desktop and mobile devices by looking at the user agent header, for example.
			</p><p>
				To create a custom theme selector you need to implement <code class="literal">ThemeSelectorProviderFactory</code> and <code class="literal">ThemeSelectorProvider</code>.
			</p><p>
				Follow the steps in <a class="link" href="#providers" title="Chapter 6. Service Provider Interfaces (SPI)">Service Provider Interfaces</a> for more details on how to create and deploy a custom provider.
			</p></section><section class="section" id="theme_resource"><div class="titlepage"><div><div><h2 class="title">3.7. Theme Resources</h2></div></div></div><p>
				When implementing custom providers in Red Hat Single Sign-On there may often be a need to add additional templates, resources and messages bundles.
			</p><p>
				The easiest way to load additional theme resources is to create a JAR with templates in <code class="literal">theme-resources/templates</code> resources in <code class="literal">theme-resources/resources</code> and messages bundles in <code class="literal">theme-resources/messages</code> and drop it into the <code class="literal">standalone/deployments/</code> directory of Red Hat Single Sign-On.
			</p><p>
				If you want a more flexible way to load templates and resources that can be achieved through the ThemeResourceSPI. By implementing <code class="literal">ThemeResourceProviderFactory</code> and <code class="literal">ThemeResourceProvider</code> you can decide exactly how to load templates and resources.
			</p><p>
				Follow the steps in <a class="link" href="#providers" title="Chapter 6. Service Provider Interfaces (SPI)">Service Provider Interfaces</a> for more details on how to create and deploy a custom provider.
			</p></section><section class="section" id="locale_selector"><div class="titlepage"><div><div><h2 class="title">3.8. Locale Selector</h2></div></div></div><p>
				By default, the locale is selected using the <code class="literal">DefaultLocaleSelectorProvider</code> which implements the <code class="literal">LocaleSelectorProvider</code> interface. English is the default language when internationalization is disabled. With internationalization enabled, the locale is resolved in the following priority:
			</p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem">
						<code class="literal">kc_locale</code> query parameter
					</li><li class="listitem">
						<code class="literal">KEYCLOAK_LOCALE</code> cookie value
					</li><li class="listitem">
						User’s preferred locale if a user instance is available
					</li><li class="listitem">
						<code class="literal">ui_locales</code> query parameter
					</li><li class="listitem">
						<code class="literal">Accept-Language</code> request header
					</li><li class="listitem">
						Realm’s default language
					</li></ol></div><p>
				This behaviour can be changed through the <code class="literal">LocaleSelectorSPI</code> by implementing the <code class="literal">LocaleSelectorProvider</code> and <code class="literal">LocaleSelectorProviderFactory</code>.
			</p><p>
				The <code class="literal">LocaleSelectorProvider</code> interface has a single method, <code class="literal">resolveLocale</code>, which must return a locale given a <code class="literal">RealmModel</code> and a nullable <code class="literal">UserModel</code>. The actual request is available from the <code class="literal">KeycloakSession#getContext</code> method.
			</p><p>
				Custom implementations can extend the <code class="literal">DefaultLocaleSelectorProvider</code> in order to reuse parts of the default behaviour. For example to ignore the <code class="literal">Accept-Language</code> request header, a custom implementation could extend the default provider, override it’s <code class="literal">getAcceptLanguageHeaderLocale</code>, and return a null value. As a result the locale selection will fall back on the realms’s default language.
			</p><p>
				Follow the steps in <a class="link" href="#providers" title="Chapter 6. Service Provider Interfaces (SPI)">Service Provider Interfaces</a> for more details on how to create and deploy a custom provider.
			</p></section></section><section class="chapter" id="custom_user_attributes"><div class="titlepage"><div><div><h1 class="title">Chapter 4. Custom User Attributes</h1></div></div></div><p>
			You can add custom user attributes to the registration page and account management console with a custom theme. This chapter describes how to add attributes to a custom theme, but you should refer to the <a class="link" href="#themes" title="Chapter 3. Themes">Themes</a> chapter on how to create a custom theme.
		</p><section class="section" id="registration_page"><div class="titlepage"><div><div><h2 class="title">4.1. Registration Page</h2></div></div></div><p>
				To be able to enter custom attributes in the registration page copy the template <code class="literal">themes/base/login/register.ftl</code> to the login type of your custom theme. Then open the copy in an editor.
			</p><p>
				As an example to add a mobile number to the registration page add the following snippet to the form:
			</p><pre class="programlisting language-html">&lt;div class="form-group"&gt;
   &lt;div class="${properties.kcLabelWrapperClass!}"&gt;
       &lt;label for="user.attributes.mobile" class="${properties.kcLabelClass!}"&gt;Mobile number&lt;/label&gt;
   &lt;/div&gt;

   &lt;div class="${properties.kcInputWrapperClass!}"&gt;
       &lt;input type="text" class="${properties.kcInputClass!}" id="user.attributes.mobile" name="user.attributes.mobile" value="${(register.formData['user.attributes.mobile']!'')}"/&gt;
   &lt;/div&gt;
&lt;/div&gt;</pre><p>
				Ensure the name of the input html element starts with <code class="literal">user.attributes.</code>. In the example above, the attribute will be stored by Keycloak with the name <code class="literal">mobile</code>.
			</p><p>
				To see the changes make sure your realm is using your custom theme for the login theme and open the registration page.
			</p></section><section class="section" id="account_management_console"><div class="titlepage"><div><div><h2 class="title">4.2. Account Management Console</h2></div></div></div><p>
				To be able to manage custom attributes in the user profile page in the account management console copy the template <code class="literal">themes/base/account/account.ftl</code> to the account type of your custom theme. Then open the copy in an editor.
			</p><p>
				As an example to add a mobile number to the account page add the following snippet to the form:
			</p><pre class="programlisting language-html">&lt;div class="form-group"&gt;
   &lt;div class="col-sm-2 col-md-2"&gt;
       &lt;label for="user.attributes.mobile" class="control-label"&gt;Mobile number&lt;/label&gt;
   &lt;/div&gt;

   &lt;div class="col-sm-10 col-md-10"&gt;
       &lt;input type="text" class="form-control" id="user.attributes.mobile" name="user.attributes.mobile" value="${(account.attributes.mobile!'')}"/&gt;
   &lt;/div&gt;
&lt;/div&gt;</pre><p>
				Ensure the name of the input html element starts with <code class="literal">user.attributes.</code>.
			</p><p>
				To see the changes make sure your realm is using your custom theme for the account theme and open the user profile page in the account management console.
			</p></section></section><section class="chapter" id="identity_brokering_apis"><div class="titlepage"><div><div><h1 class="title">Chapter 5. Identity Brokering APIs</h1></div></div></div><p>
			Red Hat Single Sign-On can delegate authentication to a parent IDP for login. A typical example of this is the case where you want users to be able to login through a social provider like Facebook or Google. Red Hat Single Sign-On also allows you to link existing accounts to a brokered IDP. This section talks about some APIs that your applications can use as it pertains to identity brokering.
		</p><section class="section" id="retrieving_external_idp_tokens"><div class="titlepage"><div><div><h2 class="title">5.1. Retrieving External IDP Tokens</h2></div></div></div><p>
				Red Hat Single Sign-On allows you to store tokens and responses from the authentication process with the external IDP. For that, you can use the <code class="literal">Store Token</code> configuration option on the IDP’s settings page.
			</p><p>
				Application code can retrieve these tokens and responses to pull in extra user information, or to securely invoke requests on the external IDP. For example, an application might want to use the Google token to invoke on other Google services and REST APIs. To retrieve a token for a particular identity provider you need to send a request as follows:
			</p><pre class="screen">GET /auth/realms/{realm}/broker/{provider_alias}/token HTTP/1.1
Host: localhost:8080
Authorization: Bearer &lt;KEYCLOAK ACCESS TOKEN&gt;</pre><p>
				An application must have authenticated with Red Hat Single Sign-On and have received an access token. This access token will need to have the <code class="literal">broker</code> client-level role <code class="literal">read-token</code> set. This means that the user must have a role mapping for this role and the client application must have that role within its scope. In this case, given that you are accessing a protected service in Red Hat Single Sign-On, you need to send the access token issued by Red Hat Single Sign-On during the user authentication. In the broker configuration page you can automatically assign this role to newly imported users by turning on the <code class="literal">Stored Tokens Readable</code> switch.
			</p><p>
				These external tokens can be re-established by either logging in again through the provider, or using the client initiated account linking API.
			</p></section><section class="section" id="client_initiated_account_linking"><div class="titlepage"><div><div><h2 class="title">5.2. Client Initiated Account Linking</h2></div></div></div><p>
				Some applications want to integrate with social providers like Facebook, but do not want to provide an option to login via these social providers. Red Hat Single Sign-On offers a browser-based API that applications can use to link an existing user account to a specific external IDP. This is called client-initiated account linking. Account linking can only be initiated by OIDC applications.
			</p><p>
				The way it works is that the application forwards the user’s browser to a URL on the Red Hat Single Sign-On server requesting that it wants to link the user’s account to a specific external provider (i.e. Facebook). The server initiates a login with the external provider. The browser logs in at the external provider and is redirected back to the server. The server establishes the link and redirects back to the application with a confirmation.
			</p><p>
				There are some preconditions that must be met by the client application before it can initiate this protocol:
			</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">
						The desired identity provider must be configured and enabled for the user’s realm in the admin console.
					</li><li class="listitem">
						The user account must already be logged in as an existing user via the OIDC protocol
					</li><li class="listitem">
						The user must have an <code class="literal">account.manage-account</code> or <code class="literal">account.manage-account-links</code> role mapping.
					</li><li class="listitem">
						The application must be granted the scope for those roles within its access token
					</li><li class="listitem">
						The application must have access to its access token as it needs information within it to generate the redirect URL.
					</li></ul></div><p>
				To initiate the login, the application must fabricate a URL and redirect the user’s browser to this URL. The URL looks like this:
			</p><pre class="screen">/{auth-server-root}/auth/realms/{realm}/broker/{provider}/link?client_id={id}&amp;redirect_uri={uri}&amp;nonce={nonce}&amp;hash={hash}</pre><p>
				Here’s a description of each path and query param:
			</p><div class="variablelist"><dl class="variablelist"><dt><span class="term">provider</span></dt><dd>
							This is the provider alias of the external IDP that you defined in the <code class="literal">Identity Provider</code> section of the admin console.
						</dd><dt><span class="term">client_id</span></dt><dd>
							This is the OIDC client id of your application. When you registered the application as a client in the admin console, you had to specify this client id.
						</dd><dt><span class="term">redirect_uri</span></dt><dd>
							This is the application callback URL you want to redirect to after the account link is established. It must be a valid client redirect URI pattern. In other words, it must match one of the valid URL patterns you defined when you registered the client in the admin console.
						</dd><dt><span class="term">nonce</span></dt><dd>
							This is a random string that your application must generate
						</dd><dt><span class="term">hash</span></dt><dd>
							This is a Base64 URL encoded hash. This hash is generated by Base64 URL encoding a SHA_256 hash of <code class="literal">nonce</code> + <code class="literal">token.getSessionState()</code> + <code class="literal">token.getIssuedFor()</code> + <code class="literal">provider</code>. The token variable are obtained from the OIDC access token. Basically you are hashing the random nonce, the user session id, the client id, and the identity provider alias you want to access.
						</dd></dl></div><p>
				Here’s an example of Java Servlet code that generates the URL to establish the account link.
			</p><pre class="programlisting language-java">   KeycloakSecurityContext session = (KeycloakSecurityContext) httpServletRequest.getAttribute(KeycloakSecurityContext.class.getName());
   AccessToken token = session.getToken();
   String clientId = token.getIssuedFor();
   String nonce = UUID.randomUUID().toString();
   MessageDigest md = null;
   try {
      md = MessageDigest.getInstance("SHA-256");
   } catch (NoSuchAlgorithmException e) {
      throw new RuntimeException(e);
   }
   String input = nonce + token.getSessionState() + clientId + provider;
   byte[] check = md.digest(input.getBytes(StandardCharsets.UTF_8));
   String hash = Base64Url.encode(check);
   request.getSession().setAttribute("hash", hash);
   String redirectUri = ...;
   String accountLinkUrl = KeycloakUriBuilder.fromUri(authServerRootUrl)
                    .path("/auth/realms/{realm}/broker/{provider}/link")
                    .queryParam("nonce", nonce)
                    .queryParam("hash", hash)
                    .queryParam("client_id", clientId)
                    .queryParam("redirect_uri", redirectUri).build(realm, provider).toString();</pre><p>
				Why is this hash included? We do this so that the auth server is guaranteed to know that the client application initiated the request and no other rogue app just randomly asked for a user account to be linked to a specific provider. The auth server will first check to see if the user is logged in by checking the SSO cookie set at login. It will then try to regenerate the hash based on the current login and match it up to the hash sent by the application.
			</p><p>
				After the account has been linked, the auth server will redirect back to the <code class="literal">redirect_uri</code>. If there is a problem servicing the link request, the auth server may or may not redirect back to the <code class="literal">redirect_uri</code>. The browser may just end up at an error page instead of being redirected back to the application. If there is an error condition and the auth server deems it safe enough to redirect back to the client app, an additional <code class="literal">error</code> query parameter will be appended to the <code class="literal">redirect_uri</code>.
			</p><div class="admonition warning"><div class="admonition_header">Warning</div><div><p>
					While this API guarantees that the application initiated the request, it does not completely prevent CSRF attacks for this operation. The application is still responsible for guarding against CSRF attacks target at itself.
				</p></div></div><section class="section" id="refreshing_external_tokens"><div class="titlepage"><div><div><h3 class="title">5.2.1. Refreshing External Tokens</h3></div></div></div><p>
					If you are using the external token generated by logging into the provider (i.e. a Facebook or GitHub token), you can refresh this token by re-initiating the account linking API.
				</p></section></section></section><section class="chapter" id="providers"><div class="titlepage"><div><div><h1 class="title">Chapter 6. Service Provider Interfaces (SPI)</h1></div></div></div><p>
			Red Hat Single Sign-On is designed to cover most use-cases without requiring custom code, but we also want it to be customizable. To achieve this Red Hat Single Sign-On has a number of Service Provider Interfaces (SPI) for which you can implement your own providers.
		</p><section class="section" id="implementing_an_spi"><div class="titlepage"><div><div><h2 class="title">6.1. Implementing an SPI</h2></div></div></div><p>
				To implement an SPI you need to implement its ProviderFactory and Provider interfaces. You also need to create a service configuration file.
			</p><p>
				For example, to implement the Theme Selector SPI you need to implement ThemeSelectorProviderFactory and ThemeSelectorProvider and also provide the file <code class="literal">META-INF/services/org.keycloak.theme.ThemeSelectorProviderFactory</code>.
			</p><p>
				Example ThemeSelectorProviderFactory:
			</p><pre class="programlisting language-java">package org.acme.provider;

import ...

public class MyThemeSelectorProviderFactory implements ThemeSelectorProviderFactory {

    @Override
    public ThemeSelectorProvider create(KeycloakSession session) {
        return new MyThemeSelectorProvider(session);
    }

    @Override
    public void init(Config.Scope config) {
    }

    @Override
    public void postInit(KeycloakSessionFactory factory) {
    }

    @Override
    public void close() {
    }

    @Override
    public String getId() {
        return "myThemeSelector";
    }
}</pre><div class="admonition note"><div class="admonition_header">Note</div><div><p>
					Keycloak creates a single instance of provider factories which makes it possible to store state for multiple requests. Provider instances are created by calling create on the factory for each request so these should be light-weight object.
				</p></div></div><p>
				Example ThemeSelectorProvider:
			</p><pre class="programlisting language-java">package org.acme.provider;

import ...

public class MyThemeSelectorProvider implements ThemeSelectorProvider {

    public MyThemeSelectorProvider(KeycloakSession session) {
    }


    @Override
    public String getThemeName(Theme.Type type) {
        return "my-theme";
    }

    @Override
	public void close() {
    }
}</pre><p>
				Example service configuration file (<code class="literal">META-INF/services/org.keycloak.theme.ThemeSelectorProviderFactory</code>):
			</p><pre class="screen">org.acme.provider.MyThemeSelectorProviderFactory</pre><p>
				You can configure your provider through <code class="literal">standalone.xml</code>, <code class="literal">standalone-ha.xml</code>, or <code class="literal">domain.xml</code>.
			</p><p>
				For example by adding the following to <code class="literal">standalone.xml</code>:
			</p><pre class="programlisting language-xml">&lt;spi name="themeSelector"&gt;
    &lt;provider name="myThemeSelector" enabled="true"&gt;
        &lt;properties&gt;
            &lt;property name="theme" value="my-theme"/&gt;
        &lt;/properties&gt;
    &lt;/provider&gt;
&lt;/spi&gt;</pre><p>
				Then you can retrieve the config in the <code class="literal">ProviderFactory</code> init method:
			</p><pre class="programlisting language-java">public void init(Config.Scope config) {
    String themeName = config.get("theme");
}</pre><p>
				Your provider can also lookup other providers if needed. For example:
			</p><pre class="programlisting language-java">public class MyThemeSelectorProvider implements ThemeSelectorProvider {

    private KeycloakSession session;

    public MyThemeSelectorProvider(KeycloakSession session) {
        this.session = session;
    }

    @Override
    public String getThemeName(Theme.Type type) {
        return session.getContext().getRealm().getLoginTheme();
    }
}</pre><section class="section" id="providers_admin_console"><div class="titlepage"><div><div><h3 class="title">6.1.1. Show info from your SPI implementation in admin console</h3></div></div></div><p>
					Sometimes it is useful to show additional info about your Provider to a Red Hat Single Sign-On administrator. You can show provider build time information (eg. version of custom provider currently installed), current configuration of the provider (eg. url of remote system your provider talks to) or some operational info (average time of response from remote system your provider talks to). Red Hat Single Sign-On admin console provides Server Info page to show this kind of information.
				</p><p>
					To show info from your provider it is enough to implement <code class="literal">org.keycloak.provider.ServerInfoAwareProviderFactory</code> interface in your <code class="literal">ProviderFactory</code>.
				</p><p>
					Example implementation for <code class="literal">MyThemeSelectorProviderFactory</code> from previous example:
				</p><pre class="programlisting language-java">package org.acme.provider;

import ...

public class MyThemeSelectorProviderFactory implements ThemeSelectorProviderFactory, ServerInfoAwareProviderFactory {
    ...

    @Override
    public Map&lt;String, String&gt; getOperationalInfo() {
        Map&lt;String, String&gt; ret = new LinkedHashMap&lt;&gt;();
        ret.put("theme-name", "my-theme");
        return ret;
    }
}</pre></section></section><section class="section" id="registering_provider_implementations"><div class="titlepage"><div><div><h2 class="title">6.2. Registering provider implementations</h2></div></div></div><p>
				There are two ways to register provider implementations. In most cases the simplest way is to use the Red Hat Single Sign-On deployer approach as this handles a number of dependencies automatically for you. It also supports hot deployment as well as re-deployment.
			</p><p>
				The alternative approach is to deploy as a module.
			</p><p>
				If you are creating a custom SPI you will need to deploy it as a module, otherwise we recommend using the Red Hat Single Sign-On deployer approach.
			</p><section class="section" id="using_the_red_hat_single_sign_on_deployer"><div class="titlepage"><div><div><h3 class="title">6.2.1. Using the Red Hat Single Sign-On Deployer</h3></div></div></div><p>
					If you copy your provider jar to the Red Hat Single Sign-On <code class="literal">standalone/deployments/</code> directory, your provider will automatically be deployed. Hot deployment works too. Additionally, your provider jar works similarly to other components deployed in a JBoss EAP environment in that they can use facilities like the <code class="literal">jboss-deployment-structure.xml</code> file. This file allows you to set up dependencies on other components and load third-party jars and modules.
				</p><p>
					Provider jars can also be contained within other deployable units like EARs and WARs. Deploying with a EAR actually makes it really easy to use third party jars as you can just put these libraries in the EAR’s <code class="literal">lib/</code> directory.
				</p></section><section class="section" id="register_a_provider_using_modules"><div class="titlepage"><div><div><h3 class="title">6.2.2. Register a provider using Modules</h3></div></div></div><p>
					To register a provider using Modules first create a module. To do this you can either use the jboss-cli script or manually create a folder inside <code class="literal">KEYCLOAK_HOME/modules</code> and add your jar and a <code class="literal">module.xml</code>. For example to add the event listener sysout example provider using the <code class="literal">jboss-cli</code> script execute:
				</p><pre class="screen">KEYCLOAK_HOME/bin/jboss-cli.sh --command="module add --name=org.acme.provider --resources=target/provider.jar --dependencies=org.keycloak.keycloak-core,org.keycloak.keycloak-server-spi"</pre><p>
					Or to manually create it start by creating the folder <code class="literal">KEYCLOAK_HOME/modules/org/acme/provider/main</code>. Then copy <code class="literal">provider.jar</code> to this folder and create <code class="literal">module.xml</code> with the following content:
				</p><pre class="programlisting language-xml">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;module xmlns="urn:jboss:module:1.3" name="org.acme.provider"&gt;
    &lt;resources&gt;
        &lt;resource-root path="provider.jar"/&gt;
    &lt;/resources&gt;
    &lt;dependencies&gt;
        &lt;module name="org.keycloak.keycloak-core"/&gt;
        &lt;module name="org.keycloak.keycloak-server-spi"/&gt;
    &lt;/dependencies&gt;
&lt;/module&gt;</pre><p>
					Once you’ve created the module you need to register this module with Red Hat Single Sign-On. This is done by editing the keycloak-server subsystem section of <code class="literal">standalone.xml</code>, <code class="literal">standalone-ha.xml</code>, or <code class="literal">domain.xml</code>, and adding it to the providers:
				</p><pre class="programlisting language-xml">&lt;subsystem xmlns="urn:jboss:domain:keycloak-server:1.1"&gt;
    &lt;web-context&gt;auth&lt;/web-context&gt;
    &lt;providers&gt;
        &lt;provider&gt;module:org.keycloak.examples.event-sysout&lt;/provider&gt;
    &lt;/providers&gt;
    ...</pre></section><section class="section" id="disabling_a_provider"><div class="titlepage"><div><div><h3 class="title">6.2.3. Disabling a provider</h3></div></div></div><p>
					You can disable a provider by setting the enabled attribute for the provider to false in <code class="literal">standalone.xml</code>, <code class="literal">standalone-ha.xml</code>, or <code class="literal">domain.xml</code>. For example to disable the Infinispan user cache provider add:
				</p><pre class="programlisting language-xml">&lt;spi name="userCache"&gt;
    &lt;provider name="infinispan" enabled="false"/&gt;
&lt;/spi&gt;</pre></section></section><section class="section" id="leveraging_java_ee"><div class="titlepage"><div><div><h2 class="title">6.3. Leveraging Java EE</h2></div></div></div><p>
				The service providers can be packaged within any Java EE component so long as you set up the <code class="literal">META-INF/services</code> file correctly to point to your providers. For example, if your provider needs to use third party libraries, you can package up your provider within an ear and store these third party libraries in the ear’s <code class="literal">lib/</code> directory. Also note that provider jars can make use of the <code class="literal">jboss-deployment-structure.xml</code> file that EJBs, WARS, and EARs can use in a JBoss EAP environment. See the JBoss EAP documentation for more details on this file. It allows you to pull in external dependencies among other fine grain actions.
			</p><p>
				<code class="literal">ProviderFactory</code> implementations are required to be plain java objects. But, we also currently support implementing provider classes as Stateful EJBs. This is how you would do it:
			</p><pre class="programlisting language-java">@Stateful
@Local(EjbExampleUserStorageProvider.class)
public class EjbExampleUserStorageProvider implements UserStorageProvider,
        UserLookupProvider,
        UserRegistrationProvider,
        UserQueryProvider,
        CredentialInputUpdater,
        CredentialInputValidator,
        OnUserCache
{
    @PersistenceContext
    protected EntityManager em;

    protected ComponentModel model;
    protected KeycloakSession session;

    public void setModel(ComponentModel model) {
        this.model = model;
    }

    public void setSession(KeycloakSession session) {
        this.session = session;
    }


    @Remove
    @Override
    public void close() {
    }
...
}</pre><p>
				You have to define the <code class="literal">@Local</code> annotation and specify your provider class there. If you don’t do this, EJB will not proxy the provider instance correctly and your provider won’t work.
			</p><p>
				You must put the <code class="literal">@Remove</code> annotation on the <code class="literal">close()</code> method of your provider. If you don’t, the stateful bean will never be cleaned up and you may eventually see error messages.
			</p><p>
				Implementations of <code class="literal">ProviderFactory</code> are required to be plain java objects. Your factory class would perform a JNDI lookup of the Stateful EJB in its <code class="literal">create()</code> method.
			</p><pre class="programlisting language-java">public class EjbExampleUserStorageProviderFactory
        implements UserStorageProviderFactory&lt;EjbExampleUserStorageProvider&gt; {

    @Override
    public EjbExampleUserStorageProvider create(KeycloakSession session, ComponentModel model) {
        try {
            InitialContext ctx = new InitialContext();
            EjbExampleUserStorageProvider provider = (EjbExampleUserStorageProvider)ctx.lookup(
                     "java:global/user-storage-jpa-example/" + EjbExampleUserStorageProvider.class.getSimpleName());
            provider.setModel(model);
            provider.setSession(session);
            return provider;
        } catch (Exception e) {
            throw new RuntimeException(e);
        }
    }</pre></section><section class="section" id="script_providers"><div class="titlepage"><div><div><h2 class="title">6.4. JavaScript Providers</h2></div></div></div><p>
				Red Hat Single Sign-On has the ability to execute scripts during runtime in order to allow administrators to customize specific functionalities:
			</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">
						Authenticator
					</li><li class="listitem">
						JavaScript Policy
					</li><li class="listitem">
						OpenID Connect Protocol Mapper
					</li></ul></div><section class="section" id="authenticator"><div class="titlepage"><div><div><h3 class="title">6.4.1. Authenticator</h3></div></div></div><p>
					Authentication scripts must provide at least one of the following functions: <code class="literal">authenticate(..)</code>, which is called from <code class="literal">Authenticator#authenticate(AuthenticationFlowContext)</code><code class="literal">action(..)</code>, which is called from <code class="literal">Authenticator#action(AuthenticationFlowContext)</code>
				</p><p>
					Custom <code class="literal">Authenticator</code> should at least provide the <code class="literal">authenticate(..)</code> function. You can use the <code class="literal">javax.script.Bindings</code> script within the code.
				</p><div class="variablelist"><dl class="variablelist"><dt><span class="term"><code class="literal">script</code></span></dt><dd>
								the <code class="literal">ScriptModel</code> to access script metadata
							</dd><dt><span class="term"><code class="literal">realm</code></span></dt><dd>
								the <code class="literal">RealmModel</code>
							</dd><dt><span class="term"><code class="literal">user</code></span></dt><dd>
								the current <code class="literal">UserModel</code>
							</dd><dt><span class="term"><code class="literal">session</code></span></dt><dd>
								the active <code class="literal">KeycloakSession</code>
							</dd><dt><span class="term"><code class="literal">authenticationSession</code></span></dt><dd>
								the current <code class="literal">AuthenticationSessionModel</code>
							</dd><dt><span class="term"><code class="literal">httpRequest</code></span></dt><dd>
								the current <code class="literal">org.jboss.resteasy.spi.HttpRequest</code>
							</dd><dt><span class="term"><code class="literal">LOG</code></span></dt><dd>
								a <code class="literal">org.jboss.logging.Logger</code> scoped to <code class="literal">ScriptBasedAuthenticator</code>
							</dd></dl></div><div class="admonition note"><div class="admonition_header">Note</div><div><p>
						You can extract additional context information from the <code class="literal">context</code> argument passed to the <code class="literal">authenticate(context)</code> <code class="literal">action(context)</code> function.
					</p></div></div><pre class="programlisting language-javascript">AuthenticationFlowError = Java.type("org.keycloak.authentication.AuthenticationFlowError");

function authenticate(context) {

  LOG.info(script.name + " --&gt; trace auth for: " + user.username);

  if (   user.username === "tester"
      &amp;&amp; user.getAttribute("someAttribute")
      &amp;&amp; user.getAttribute("someAttribute").contains("someValue")) {

      context.failure(AuthenticationFlowError.INVALID_USER);
      return;
  }

  context.success();
}</pre></section><section class="section" id="create_a_jar_with_the_scripts_to_deploy"><div class="titlepage"><div><div><h3 class="title">6.4.2. Create a JAR with the scripts to deploy</h3></div></div></div><div class="admonition note"><div class="admonition_header">Note</div><div><p>
						JAR files are regular ZIP files with a <code class="literal">.jar</code> extension.
					</p></div></div><p>
					In order to make your scripts available to Red Hat Single Sign-On you need to deploy them to the server. For that, you should create a <code class="literal">JAR</code> file with the following structure:
				</p><pre class="screen">META-INF/keycloak-scripts.json

my-script-authenticator.js
my-script-policy.js
my-script-mapper.js</pre><p>
					The <code class="literal">META-INF/keycloak-scripts.json</code> is a file descriptor that provides metadata information about the scripts you want to deploy. It is a JSON file with the following structure:
				</p><pre class="programlisting language-json">{
    "authenticators": [
        {
            "name": "My Authenticator",
            "fileName": "my-script-authenticator.js",
            "description": "My Authenticator from a JS file"
        }
    ],
    "policies": [
        {
            "name": "My Policy",
            "fileName": "my-script-policy.js",
            "description": "My Policy from a JS file"
        }
    ],
    "mappers": [
        {
            "name": "My Mapper",
            "fileName": "my-script-mapper.js",
            "description": "My Mapper from a JS file"
        }
    ]
}</pre><p>
					This file should reference the different types of script providers that you want to deploy:
				</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p class="simpara">
							<code class="literal">authenticators</code>
						</p><p class="simpara">
							For OpenID Connect Script Authenticators. You can have one or multiple authenticators in the same JAR file
						</p></li><li class="listitem"><p class="simpara">
							<code class="literal">policies</code>
						</p><p class="simpara">
							For JavaScript Policies when using Red Hat Single Sign-On Authorization Services. You can have one or multiple policies in the same JAR file
						</p></li><li class="listitem"><p class="simpara">
							<code class="literal">mappers</code>
						</p><p class="simpara">
							For OpenID Connect Script Protocol Mappers. You can have one or multiple mappers in the same JAR file
						</p></li></ul></div><p>
					For each script file in your <code class="literal">JAR</code> file you must have a corresponding entry in <code class="literal">META-INF/keycloak-scripts.json</code> that maps your scripts files to a specific provider type. For that you should provide the following properties for each entry:
				</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p class="simpara">
							<code class="literal">name</code>
						</p><p class="simpara">
							A friendly name that will be used to show the scripts through the Red Hat Single Sign-On Administration Console. If not provided, the name of the script file will be used instead
						</p></li><li class="listitem"><p class="simpara">
							<code class="literal">description</code>
						</p><p class="simpara">
							An optional text that better describes the intend of the script file
						</p></li><li class="listitem"><p class="simpara">
							<code class="literal">fileName</code>
						</p><p class="simpara">
							The name of the script file. This property is <span class="strong strong"><strong>mandatory</strong></span> and should map to a file within the JAR.
						</p></li></ul></div></section><section class="section" id="deploy_the_script_jar"><div class="titlepage"><div><div><h3 class="title">6.4.3. Deploy the Script JAR</h3></div></div></div><p>
					Once you have a JAR file with a descriptor and the scripts you want to deploy, you just need to copy the JAR to the to the Red Hat Single Sign-On <code class="literal">standalone/deployments/</code> directory.
				</p></section><section class="section" id="using_red_hat_single_sign_on_administration_console_to_upload_scripts"><div class="titlepage"><div><div><h3 class="title">6.4.4. Using Red Hat Single Sign-On Administration Console to upload scripts</h3></div></div></div><div class="admonition note"><div class="admonition_header">Note</div><div><p>
						Ability to upload scripts through the admin console is deprecated and will be removed in a future version of Red Hat Single Sign-On
					</p></div></div><p>
					Administrators cannot upload scripts to the server. This behavior prevents potential harm to the system in case malicious scripts are accidentally executed. Administrators should always deploy scripts directly to the server using a JAR file to prevent attacks when you run scripts at runtime.
				</p><p>
					Ability to upload scripts can be explicitly enabled. This should be used with great care and plans should be created to deploy all scripts directly to the server as soon as possible.
				</p><p>
					For more details about how to enable the <code class="literal">upload_scripts</code> feature. Please, take a look at the <a class="link" href="https://access.redhat.com/documentation/en-us/red_hat_single_sign-on/7.4/html-single/server_installation_and_configuration_guide/#profiles">Profiles</a>.
				</p></section></section><section class="section" id="available_spis"><div class="titlepage"><div><div><h2 class="title">6.5. Available SPIs</h2></div></div></div><p>
				If you want to see list of all available SPIs at runtime, you can check <code class="literal">Server Info</code> page in admin console as described in <a class="link" href="#providers_admin_console" title="6.1.1. Show info from your SPI implementation in admin console">Admin Console</a> section.
			</p></section></section><section class="chapter" id="user-storage-spi"><div class="titlepage"><div><div><h1 class="title">Chapter 7. User Storage SPI</h1></div></div></div><p>
			You can use the User Storage SPI to write extensions to Red Hat Single Sign-On to connect to external user databases and credential stores. The built-in LDAP and ActiveDirectory support is an implementation of this SPI in action. Out of the box, Red Hat Single Sign-On uses its local database to create, update, and look up users and validate credentials. Often though, organizations have existing external proprietary user databases that they cannot migrate to Red Hat Single Sign-On’s data model. For those situations, application developers can write implementations of the User Storage SPI to bridge the external user store and the internal user object model that Red Hat Single Sign-On uses to log in users and manage them.
		</p><p>
			When the Red Hat Single Sign-On runtime needs to look up a user, such as when a user is logging in, it performs a number of steps to locate the user. It first looks to see if the user is in the user cache; if the user is found it uses that in-memory representation. Then it looks for the user within the Red Hat Single Sign-On local database. If the user is not found, it then loops through User Storage SPI provider implementations to perform the user query until one of them returns the user the runtime is looking for. The provider queries the external user store for the user and maps the external data representation of the user to Red Hat Single Sign-On’s user metamodel.
		</p><p>
			User Storage SPI provider implementations can also perform complex criteria queries, perform CRUD operations on users, validate and manage credentials, or perform bulk updates of many users at once. It depends on the capabilities of the external store.
		</p><p>
			User Storage SPI provider implementations are packaged and deployed similarly to (and often are) Java EE components. They are not enabled by default, but instead must be enabled and configured per realm under the <code class="literal">User Federation</code> tab in the administration console.
		</p><section class="section" id="provider_interfaces"><div class="titlepage"><div><div><h2 class="title">7.1. Provider Interfaces</h2></div></div></div><p>
				When building an implementation of the User Storage SPI you have to define a provider class and a provider factory. Provider class instances are created per transaction by provider factories. Provider classes do all the heavy lifting of user lookup and other user operations. They must implement the <code class="literal">org.keycloak.storage.UserStorageProvider</code> interface.
			</p><pre class="programlisting language-java">package org.keycloak.storage;

public interface UserStorageProvider extends Provider {


    /**
     * Callback when a realm is removed.  Implement this if, for example, you want to do some
     * cleanup in your user storage when a realm is removed
     *
     * @param realm
     */
    default
    void preRemove(RealmModel realm) {

    }

    /**
     * Callback when a group is removed.  Allows you to do things like remove a user
     * group mapping in your external store if appropriate
     *
     * @param realm
     * @param group
     */
    default
    void preRemove(RealmModel realm, GroupModel group) {

    }

    /**
     * Callback when a role is removed.  Allows you to do things like remove a user
     * role mapping in your external store if appropriate

     * @param realm
     * @param role
     */
    default
    void preRemove(RealmModel realm, RoleModel role) {

    }

}</pre><p>
				You may be thinking that the <code class="literal">UserStorageProvider</code> interface is pretty sparse? You’ll see later in this chapter that there are other mix-in interfaces your provider class may implement to support the meat of user integration.
			</p><p>
				<code class="literal">UserStorageProvider</code> instances are created once per transaction. When the transaction is complete, the <code class="literal">UserStorageProvider.close()</code> method is invoked and the instance is then garbage collected. Instances are created by provider factories. Provider factories implement the <code class="literal">org.keycloak.storage.UserStorageProviderFactory</code> interface.
			</p><pre class="programlisting language-java">package org.keycloak.storage;

/**
 * @author &lt;a href="mailto:bill@burkecentral.com"&gt;Bill Burke&lt;/a&gt;
 * @version $Revision: 1 $
 */
public interface UserStorageProviderFactory&lt;T extends UserStorageProvider&gt; extends ComponentFactory&lt;T, UserStorageProvider&gt; {

    /**
     * This is the name of the provider and will be shown in the admin console as an option.
     *
     * @return
     */
    @Override
    String getId();

    /**
     * called per Keycloak transaction.
     *
     * @param session
     * @param model
     * @return
     */
    T create(KeycloakSession session, ComponentModel model);
...
}</pre><p>
				Provider factory classes must specify the concrete provider class as a template parameter when implementing the <code class="literal">UserStorageProviderFactory</code>. This is a must as the runtime will introspect this class to scan for its capabilities (the other interfaces it implements). So for example, if your provider class is named <code class="literal">FileProvider</code>, then the factory class should look like this:
			</p><pre class="programlisting language-java">public class FileProviderFactory implements UserStorageProviderFactory&lt;FileProvider&gt; {

    public String getId() { return "file-provider"; }

    public FileProvider create(KeycloakSession session, ComponentModel model) {
       ...
    }</pre><p>
				The <code class="literal">getId()</code> method returns the name of the User Storage provider. This id will be displayed in the admin console’s User Federation page when you want to enable the provider for a specific realm.
			</p><p>
				The <code class="literal">create()</code> method is responsible for allocating an instance of the provider class. It takes a <code class="literal">org.keycloak.models.KeycloakSession</code> parameter. This object can be used to look up other information and metadata as well as provide access to various other components within the runtime. The <code class="literal">ComponentModel</code> parameter represents how the provider was enabled and configured within a specific realm. It contains the instance id of the enabled provider as well as any configuration you may have specified for it when you enabled through the admin console.
			</p><p>
				The <code class="literal">UserStorageProviderFactory</code> has other capabilities as well which we will go over later in this chapter.
			</p></section><section class="section" id="provider_capability_interfaces"><div class="titlepage"><div><div><h2 class="title">7.2. Provider Capability Interfaces</h2></div></div></div><p>
				If you have examined the <code class="literal">UserStorageProvider</code> interface closely you might notice that it does not define any methods for locating or managing users. These methods are actually defined in other <span class="emphasis"><em>capability interfaces</em></span> depending on what scope of capabilities your external user store can provide and execute on. For example, some external stores are read-only and can only do simple queries and credential validation. You will only be required to implement the <span class="emphasis"><em>capability interfaces</em></span> for the features you are able to. You can implement these interfaces:
			</p><div class="informaltable"><table class="lt-4-cols lt-7-rows"><colgroup><col style="width: 50%; " class="col_1"/><col style="width: 50%; " class="col_2"/></colgroup><thead><tr><th align="left" valign="top" id="idm140046321808832" scope="col">SPI</th><th align="left" valign="top" id="idm140046321807744" scope="col">Description</th></tr></thead><tbody><tr><td align="left" valign="top" headers="idm140046321808832">
							<p>
								<code class="literal">org.keycloak.storage.user.UserLookupProvider</code>
							</p>
							</td><td align="left" valign="top" headers="idm140046321807744">
							<p>
								This interface is required if you want to be able to log in with users from this external store. Most (all?) providers implement this interface.
							</p>
							</td></tr><tr><td align="left" valign="top" headers="idm140046321808832">
							<p>
								<code class="literal">org.keycloak.storage.user.UserQueryProvider</code>
							</p>
							</td><td align="left" valign="top" headers="idm140046321807744">
							<p>
								Defines complex queries that are used to locate one or more users. You must implement this interface if you want to view and manage users from the administration console.
							</p>
							</td></tr><tr><td align="left" valign="top" headers="idm140046321808832">
							<p>
								<code class="literal">org.keycloak.storage.user.UserRegistrationProvider</code>
							</p>
							</td><td align="left" valign="top" headers="idm140046321807744">
							<p>
								Implement this interface if your provider supports adding and removing users.
							</p>
							</td></tr><tr><td align="left" valign="top" headers="idm140046321808832">
							<p>
								<code class="literal">org.keycloak.storage.user.UserBulkUpdateProvider</code>
							</p>
							</td><td align="left" valign="top" headers="idm140046321807744">
							<p>
								Implement this interface if your provider supports bulk update of a set of users.
							</p>
							</td></tr><tr><td align="left" valign="top" headers="idm140046321808832">
							<p>
								<code class="literal">org.keycloak.credential.CredentialInputValidator</code>
							</p>
							</td><td align="left" valign="top" headers="idm140046321807744">
							<p>
								Implement this interface if your provider can validate one or more different credential types (for example, if your provider can validate a password).
							</p>
							</td></tr><tr><td align="left" valign="top" headers="idm140046321808832">
							<p>
								<code class="literal">org.keycloak.credential.CredentialInputUpdater</code>
							</p>
							</td><td align="left" valign="top" headers="idm140046321807744">
							<p>
								Implement this interface if your provider supports updating one or more different credential types.
							</p>
							</td></tr></tbody></table></div></section><section class="section" id="model_interfaces"><div class="titlepage"><div><div><h2 class="title">7.3. Model Interfaces</h2></div></div></div><p>
				Most of the methods defined in the <span class="emphasis"><em>capability</em></span> <span class="emphasis"><em>interfaces</em></span> either return or are passed in representations of a user. These representations are defined by the <code class="literal">org.keycloak.models.UserModel</code> interface. App developers are required to implement this interface. It provides a mapping between the external user store and the user metamodel that Red Hat Single Sign-On uses.
			</p><pre class="programlisting language-java">package org.keycloak.models;

public interface UserModel extends RoleMapperModel {
    String getId();

    String getUsername();
    void setUsername(String username);

    String getFirstName();
    void setFirstName(String firstName);

    String getLastName();
    void setLastName(String lastName);

    String getEmail();
    void setEmail(String email);
...
}</pre><p>
				<code class="literal">UserModel</code> implementations provide access to read and update metadata about the user including things like username, name, email, role and group mappings, as well as other arbitrary attributes.
			</p><p>
				There are other model classes within the <code class="literal">org.keycloak.models</code> package that represent other parts of the Red Hat Single Sign-On metamodel: <code class="literal">RealmModel</code>, <code class="literal">RoleModel</code>, <code class="literal">GroupModel</code>, and <code class="literal">ClientModel</code>.
			</p><section class="section" id="storage_ids"><div class="titlepage"><div><div><h3 class="title">7.3.1. Storage Ids</h3></div></div></div><p>
					One important method of <code class="literal">UserModel</code> is the <code class="literal">getId()</code> method. When implementing <code class="literal">UserModel</code> developers must be aware of the user id format. The format must be:
				</p><pre class="screen">"f:" + component id + ":" + external id</pre><p>
					The Red Hat Single Sign-On runtime often has to look up users by their user id. The user id contains enough information so that the runtime does not have to query every single <code class="literal">UserStorageProvider</code> in the system to find the user.
				</p><p>
					The component id is the id returned from <code class="literal">ComponentModel.getId()</code>. The <code class="literal">ComponentModel</code> is passed in as a parameter when creating the provider class so you can get it from there. The external id is information your provider class needs to find the user in the external store. This is often a username or a uid. For example, it might look something like this:
				</p><pre class="screen">f:332a234e31234:wburke</pre><p>
					When the runtime does a lookup by id, the id is parsed to obtain the component id. The component id is used to locate the <code class="literal">UserStorageProvider</code> that was originally used to load the user. That provider is then passed the id. The provider again parses the id to obtain the external id and it will use to locate the user in external user storage.
				</p></section></section><section class="section" id="packaging_and_deployment"><div class="titlepage"><div><div><h2 class="title">7.4. Packaging and Deployment</h2></div></div></div><p>
				User Storage providers are packaged in a JAR and deployed or undeployed to the Red Hat Single Sign-On runtime in the same way you would deploy something in the JBoss EAP application server. You can either copy the JAR directly to the <code class="literal">standalone/deployments/</code> directory of the server, or use the JBoss CLI to execute the deployment.
			</p><p>
				In order for Red Hat Single Sign-On to recognize the provider, you need to add a file to the JAR: <code class="literal">META-INF/services/org.keycloak.storage.UserStorageProviderFactory</code>. This file must contain a line-separated list of fully qualified classnames of the <code class="literal">UserStorageProviderFactory</code> implementations:
			</p><pre class="screen">org.keycloak.examples.federation.properties.ClasspathPropertiesStorageFactory
org.keycloak.examples.federation.properties.FilePropertiesStorageFactory</pre><p>
				Red Hat Single Sign-On supports hot deployment of these provider JARs. You’ll also see later in this chapter that you can package it within and as Java EE components.
			</p></section><section class="section" id="simple_read_only_lookup_example"><div class="titlepage"><div><div><h2 class="title">7.5. Simple Read-Only, Lookup Example</h2></div></div></div><p>
				To illustrate the basics of implementing the User Storage SPI let’s walk through a simple example. In this chapter you’ll see the implementation of a simple <code class="literal">UserStorageProvider</code> that looks up users in a simple property file. The property file contains username and password definitions and is hardcoded to a specific location on the classpath. The provider will be able to look up the user by ID and username and also be able to validate passwords. Users that originate from this provider will be read-only.
			</p><section class="section" id="provider_class"><div class="titlepage"><div><div><h3 class="title">7.5.1. Provider Class</h3></div></div></div><p>
					The first thing we will walk through is the <code class="literal">UserStorageProvider</code> class.
				</p><pre class="programlisting language-java">public class PropertyFileUserStorageProvider implements
        UserStorageProvider,
        UserLookupProvider,
        CredentialInputValidator,
        CredentialInputUpdater
{
...
}</pre><p>
					Our provider class, <code class="literal">PropertyFileUserStorageProvider</code>, implements many interfaces. It implements the <code class="literal">UserStorageProvider</code> as that is a base requirement of the SPI. It implements the <code class="literal">UserLookupProvider</code> interface because we want to be able to log in with users stored by this provider. It implements the <code class="literal">CredentialInputValidator</code> interface because we want to be able to validate passwords entered in using the login screen. Our property file is read-only. We implement the <code class="literal">CredentialInputUpdater</code> because we want to post an error condition when the user attempts to update his password.
				</p><pre class="programlisting language-java">    protected KeycloakSession session;
    protected Properties properties;
    protected ComponentModel model;
    // map of loaded users in this transaction
    protected Map&lt;String, UserModel&gt; loadedUsers = new HashMap&lt;&gt;();

    public PropertyFileUserStorageProvider(KeycloakSession session, ComponentModel model, Properties properties) {
        this.session = session;
        this.model = model;
        this.properties = properties;
    }</pre><p>
					The constructor for this provider class is going to store the reference to the <code class="literal">KeycloakSession</code>, <code class="literal">ComponentModel</code>, and property file. We’ll use all of these later. Also notice that there is a map of loaded users. Whenever we find a user we will store it in this map so that we avoid re-creating it again within the same transaction. This is a good practice to follow as many providers will need to do this (that is, any provider that integrates with JPA). Remember also that provider class instances are created once per transaction and are closed after the transaction completes.
				</p><section class="section" id="userlookupprovider_implementation"><div class="titlepage"><div><div><h4 class="title">7.5.1.1. UserLookupProvider Implementation</h4></div></div></div><pre class="programlisting language-java">    @Override
    public UserModel getUserByUsername(String username, RealmModel realm) {
        UserModel adapter = loadedUsers.get(username);
        if (adapter == null) {
            String password = properties.getProperty(username);
            if (password != null) {
                adapter = createAdapter(realm, username);
                loadedUsers.put(username, adapter);
            }
        }
        return adapter;
    }

    protected UserModel createAdapter(RealmModel realm, String username) {
        return new AbstractUserAdapter(session, realm, model) {
            @Override
            public String getUsername() {
                return username;
            }
        };
    }

    @Override
    public UserModel getUserById(String id, RealmModel realm) {
        StorageId storageId = new StorageId(id);
        String username = storageId.getExternalId();
        return getUserByUsername(username, realm);
    }

    @Override
    public UserModel getUserByEmail(String email, RealmModel realm) {
        return null;
    }</pre><p>
						The <code class="literal">getUserByUsername()</code> method is invoked by the Red Hat Single Sign-On login page when a user logs in. In our implementation we first check the <code class="literal">loadedUsers</code> map to see if the user has already been loaded within this transaction. If it hasn’t been loaded we look in the property file for the username. If it exists we create an implementation of <code class="literal">UserModel</code>, store it in <code class="literal">loadedUsers</code> for future reference, and return this instance.
					</p><p>
						The <code class="literal">createAdapter()</code> method uses the helper class <code class="literal">org.keycloak.storage.adapter.AbstractUserAdapter</code>. This provides a base implementation for <code class="literal">UserModel</code>. It automatically generates a user id based on the required storage id format using the username of the user as the external id.
					</p><pre class="screen">"f:" + component id + ":" + username</pre><p>
						Every get method of <code class="literal">AbstractUserAdapter</code> either returns null or empty collections. However, methods that return role and group mappings will return the default roles and groups configured for the realm for every user. Every set method of <code class="literal">AbstractUserAdapter</code> will throw a <code class="literal">org.keycloak.storage.ReadOnlyException</code>. So if you attempt to modify the user in the admininstration console, you will get an error.
					</p><p>
						The <code class="literal">getUserById()</code> method parses the <code class="literal">id</code> parameter using the <code class="literal">org.keycloak.storage.StorageId</code> helper class. The <code class="literal">StorageId.getExternalId()</code> method is invoked to obtain the username embeded in the <code class="literal">id</code> parameter. The method then delegates to <code class="literal">getUserByUsername()</code>.
					</p><p>
						Emails are not stored, so the <code class="literal">getUserByEmail()</code> method returns null.
					</p></section><section class="section" id="credentialinputvalidator_implementation"><div class="titlepage"><div><div><h4 class="title">7.5.1.2. CredentialInputValidator Implementation</h4></div></div></div><p>
						Next let’s look at the method implementations for <code class="literal">CredentialInputValidator</code>.
					</p><pre class="programlisting language-java">    @Override
    public boolean isConfiguredFor(RealmModel realm, UserModel user, String credentialType) {
        String password = properties.getProperty(user.getUsername());
        return credentialType.equals(CredentialModel.PASSWORD) &amp;&amp; password != null;
    }

    @Override
    public boolean supportsCredentialType(String credentialType) {
        return credentialType.equals(CredentialModel.PASSWORD);
    }

    @Override
    public boolean isValid(RealmModel realm, UserModel user, CredentialInput input) {
        if (!supportsCredentialType(input.getType())) return false;

        String password = properties.getProperty(user.getUsername());
        if (password == null) return false;
        return password.equals(input.getChallengeResponse());
    }</pre><p>
						The <code class="literal">isConfiguredFor()</code> method is called by the runtime to determine if a specific credential type is configured for the user. This method checks to see that the password is set for the user.
					</p><p>
						The <code class="literal">supportsCredentialType()</code> method returns whether validation is supported for a specific credential type. We check to see if the credential type is <code class="literal">password</code>.
					</p><p>
						The <code class="literal">isValid()</code> method is responsible for validating passwords. The <code class="literal">CredentialInput</code> parameter is really just an abstract interface for all credential types. We make sure that we support the credential type and also that it is an instance of <code class="literal">UserCredentialModel</code>. When a user logs in through the login page, the plain text of the password input is put into an instance of <code class="literal">UserCredentialModel</code>. The <code class="literal">isValid()</code> method checks this value against the plain text password stored in the properties file. A return value of <code class="literal">true</code> means the password is valid.
					</p></section><section class="section" id="credentialinputupdater_implementation"><div class="titlepage"><div><div><h4 class="title">7.5.1.3. CredentialInputUpdater Implementation</h4></div></div></div><p>
						As noted before, the only reason we implement the <code class="literal">CredentialInputUpdater</code> interface in this example is to forbid modifications of user passwords. The reason we have to do this is because otherwise the runtime would allow the password to be overridden in Red Hat Single Sign-On local storage. We’ll talk more about this later in this chapter.
					</p><pre class="programlisting language-java">    @Override
    public boolean updateCredential(RealmModel realm, UserModel user, CredentialInput input) {
        if (input.getType().equals(CredentialModel.PASSWORD)) throw new ReadOnlyException("user is read only for this update");

        return false;
    }

    @Override
    public void disableCredentialType(RealmModel realm, UserModel user, String credentialType) {

    }

    @Override
    public Set&lt;String&gt; getDisableableCredentialTypes(RealmModel realm, UserModel user) {
        return Collections.EMPTY_SET;
    }</pre><p>
						The <code class="literal">updateCredential()</code> method just checks to see if the credential type is password. If it is, a <code class="literal">ReadOnlyException</code> is thrown.
					</p></section></section><section class="section" id="provider_factory_implementation"><div class="titlepage"><div><div><h3 class="title">7.5.2. Provider Factory Implementation</h3></div></div></div><p>
					Now that the provider class is complete, we now turn our attention to the provider factory class.
				</p><pre class="programlisting language-java">public class PropertyFileUserStorageProviderFactory
                 implements UserStorageProviderFactory&lt;PropertyFileUserStorageProvider&gt; {

    public static final String PROVIDER_NAME = "readonly-property-file";

    @Override
    public String getId() {
        return PROVIDER_NAME;
    }</pre><p>
					First thing to notice is that when implementing the <code class="literal">UserStorageProviderFactory</code> class, you must pass in the concrete provider class implementation as a template parameter. Here we specify the provider class we defined before: <code class="literal">PropertyFileUserStorageProvider</code>.
				</p><div class="admonition warning"><div class="admonition_header">Warning</div><div><p>
						If you do not specify the template parameter, your provider will not function. The runtime does class introspection to determine the <span class="emphasis"><em>capability interfaces</em></span> that the provider implements.
					</p></div></div><p>
					The <code class="literal">getId()</code> method identifies the factory in the runtime and will also be the string shown in the admin console when you want to enable a user storage provider for the realm.
				</p><section class="section" id="initialization"><div class="titlepage"><div><div><h4 class="title">7.5.2.1. Initialization</h4></div></div></div><pre class="programlisting language-java">    private static final Logger logger = Logger.getLogger(PropertyFileUserStorageProviderFactory.class);
    protected Properties properties = new Properties();

    @Override
    public void init(Config.Scope config) {
        InputStream is = getClass().getClassLoader().getResourceAsStream("/users.properties");

        if (is == null) {
            logger.warn("Could not find users.properties in classpath");
        } else {
            try {
                properties.load(is);
            } catch (IOException ex) {
                logger.error("Failed to load users.properties file", ex);
            }
        }
    }

    @Override
    public PropertyFileUserStorageProvider create(KeycloakSession session, ComponentModel model) {
        return new PropertyFileUserStorageProvider(session, model, properties);
    }</pre><p>
						The <code class="literal">UserStorageProviderFactory</code> interface has an optional <code class="literal">init()</code> method you can implement. When Red Hat Single Sign-On boots up, only one instance of each provider factory is created. Also at boot time, the <code class="literal">init()</code> method is called on each of these factory instances. There’s also a <code class="literal">postInit()</code> method you can implement as well. After each factory’s <code class="literal">init()</code> method is invoked, their <code class="literal">postInit()</code> methods are called.
					</p><p>
						In our <code class="literal">init()</code> method implementation, we find the property file containing our user declarations from the classpath. We then load the <code class="literal">properties</code> field with the username and password combinations stored there.
					</p><p>
						The <code class="literal">Config.Scope</code> parameter is factory configuration that can be set up within <code class="literal">standalone.xml</code>, <code class="literal">standalone-ha.xml</code>, or <code class="literal">domain.xml</code>.
					</p><p>
						For example, by adding the following to <code class="literal">standalone.xml</code>:
					</p><pre class="programlisting language-xml">&lt;spi name="storage"&gt;
    &lt;provider name="readonly-property-file" enabled="true"&gt;
        &lt;properties&gt;
            &lt;property name="path" value="/other-users.properties"/&gt;
        &lt;/properties&gt;
    &lt;/provider&gt;
&lt;/spi&gt;</pre><p>
						We can specify the classpath of the user property file instead of hardcoding it. Then you can retrieve the configuration in the <code class="literal">PropertyFileUserStorageProviderFactory.init()</code>:
					</p><pre class="programlisting language-java">public void init(Config.Scope config) {
    String path = config.get("path");
    InputStream is = getClass().getClassLoader().getResourceAsStream(path);

    ...
}</pre></section><section class="section" id="create_method"><div class="titlepage"><div><div><h4 class="title">7.5.2.2. Create Method</h4></div></div></div><p>
						Our last step in creating the provider factory is the <code class="literal">create()</code> method.
					</p><pre class="programlisting language-java">    @Override
    public PropertyFileUserStorageProvider create(KeycloakSession session, ComponentModel model) {
        return new PropertyFileUserStorageProvider(session, model, properties);
    }</pre><p>
						We simply allocate the <code class="literal">PropertyFileUserStorageProvider</code> class. This create method will be called once per transaction.
					</p></section></section><section class="section" id="packaging_and_deployment_2"><div class="titlepage"><div><div><h3 class="title">7.5.3. Packaging and Deployment</h3></div></div></div><p>
					The class files for our provider implementation should be placed in a jar. You also have to declare the provider factory class within the <code class="literal">META-INF/services/org.keycloak.storage.UserStorageProviderFactory</code> file.
				</p><pre class="screen">org.keycloak.examples.federation.properties.FilePropertiesStorageFactory</pre><p>
					Once you create the jar you can deploy it using regular JBoss EAP means: copy the jar into the <code class="literal">standalone/deployments/</code> directory or using the JBoss CLI.
				</p></section><section class="section" id="enabling_the_provider_in_the_administration_console"><div class="titlepage"><div><div><h3 class="title">7.5.4. Enabling the Provider in the Administration Console</h3></div></div></div><p>
					You enable user storage providers per realm within the <code class="literal">User Federation</code> page in the administration console.
				</p><p>
					Select the provider we just created from the list: <code class="literal">readonly-property-file</code>. It brings you to the configuration page for our provider. We do not have anything to configure, so click <span class="strong strong"><strong>Save</strong></span>.
				</p><p>
					When you go back to the main <code class="literal">User Federation</code> page, you now see your provider listed.
				</p><p>
					You will now be able to log in with a user declared in the <code class="literal">users.properties</code> file. This user will only be able to view the account page after logging in.
				</p></section></section><section class="section" id="configuration_techniques"><div class="titlepage"><div><div><h2 class="title">7.6. Configuration Techniques</h2></div></div></div><p>
				Our <code class="literal">PropertyFileUserStorageProvider</code> example is bit contrived. It is hardcoded to a property file that is embedded in the jar of the provider, which is not terribly useful. We might want to make the location of this file configurable per instance of the provider. In other words, we might want to reuse this provider mulitple times in multiple different realms and point to completely different user property files. We’ll also want to perform this configuration within the administration console UI.
			</p><p>
				The <code class="literal">UserStorageProviderFactory</code> has additional methods you can implement that handle provider configuration. You describe the variables you want to configure per provider and the administration console automatically renders a generic input page to gather this configuration. When implemented, callback methods also validate the configuration before it is saved, when a provider is created for the first time, and when it is updated. <code class="literal">UserStorageProviderFactory</code> inherits these methods from the <code class="literal">org.keycloak.component.ComponentFactory</code> interface.
			</p><pre class="programlisting language-java">    List&lt;ProviderConfigProperty&gt; getConfigProperties();

    default
    void validateConfiguration(KeycloakSession session, RealmModel realm, ComponentModel model)
            throws ComponentValidationException
    {

    }

    default
    void onCreate(KeycloakSession session, RealmModel realm, ComponentModel model) {

    }

    default
    void onUpdate(KeycloakSession session, RealmModel realm, ComponentModel model) {

    }</pre><p>
				The <code class="literal">ComponentFactory.getConfigProperties()</code> method returns a list of <code class="literal">org.keycloak.provider.ProviderConfigProperty</code> instances. These instances declare metadata that is needed to render and store each configuration variable of the provider.
			</p><section class="section" id="configuration_example"><div class="titlepage"><div><div><h3 class="title">7.6.1. Configuration Example</h3></div></div></div><p>
					Let’s expand our <code class="literal">PropertyFileUserStorageProviderFactory</code> example to allow you to point a provider instance to a specific file on disk.
				</p><div class="formalpara"><p class="title"><strong>PropertyFileUserStorageProviderFactory</strong></p><p>
						
<pre class="programlisting language-java">public class PropertyFileUserStorageProviderFactory
                  implements UserStorageProviderFactory&lt;PropertyFileUserStorageProvider&gt; {

    protected static final List&lt;ProviderConfigProperty&gt; configMetadata;

    static {
        configMetadata = ProviderConfigurationBuilder.create()
                .property().name("path")
                .type(ProviderConfigProperty.STRING_TYPE)
                .label("Path")
                .defaultValue("${jboss.server.config.dir}/example-users.properties")
                .helpText("File path to properties file")
                .add().build();
    }

    @Override
    public List&lt;ProviderConfigProperty&gt; getConfigProperties() {
        return configMetadata;
    }</pre>
					</p></div><p>
					The <code class="literal">ProviderConfigurationBuilder</code> class is a great helper class to create a list of configuration properties. Here we specify a variable named <code class="literal">path</code> that is a String type. On the administration console configuration page for this provider, this configuration variable is labeled as <code class="literal">Path</code> and has a default value of <code class="literal">${jboss.server.config.dir}/example-users.properties</code>. When you hover over the tooltip of this configuration option, it displays the help text, <code class="literal">File path to properties file</code>.
				</p><p>
					The next thing we want to do is to verify that this file exists on disk. We do not want to enable an instance of this provider in the realm unless it points to a valid user property file. To do this, we implement the <code class="literal">validateConfiguration()</code> method.
				</p><pre class="programlisting language-java">    @Override
    public void validateConfiguration(KeycloakSession session, RealmModel realm, ComponentModel config)
                   throws ComponentValidationException {
        String fp = config.getConfig().getFirst("path");
        if (fp == null) throw new ComponentValidationException("user property file does not exist");
        fp = EnvUtil.replace(fp);
        File file = new File(fp);
        if (!file.exists()) {
            throw new ComponentValidationException("user property file does not exist");
        }
    }</pre><p>
					In the <code class="literal">validateConfiguration()</code> method we get the configuration variable from the <code class="literal">ComponentModel</code> and we check to see if that file exists on disk. Notice that we use the <code class="literal">org.keycloak.common.util.EnvUtil.replace()</code> method. With this method any string that has <code class="literal">${}</code> within it will replace that with a system property value. The <code class="literal">${jboss.server.config.dir}</code> string corresponds to the <code class="literal">configuration/</code> directory of our server and is really useful for this example.
				</p><p>
					Next thing we have to do is remove the old <code class="literal">init()</code> method. We do this because user property files are going to be unique per provider instance. We move this logic to the <code class="literal">create()</code> method.
				</p><pre class="programlisting language-java">    @Override
    public PropertyFileUserStorageProvider create(KeycloakSession session, ComponentModel model) {
        String path = model.getConfig().getFirst("path");

        Properties props = new Properties();
        try {
            InputStream is = new FileInputStream(path);
            props.load(is);
            is.close();
        } catch (IOException e) {
            throw new RuntimeException(e);
        }

        return new PropertyFileUserStorageProvider(session, model, props);
    }</pre><p>
					This logic is, of course, inefficient as every transaction reads the entire user property file from disk, but hopefully this illustrates, in a simple way, how to hook in configuration variables.
				</p></section><section class="section" id="configuring_the_provider_in_the_administration_console"><div class="titlepage"><div><div><h3 class="title">7.6.2. Configuring the Provider in the Administration Console</h3></div></div></div><p>
					Now that the configuration is enabled, you can set the <code class="literal">path</code> variable when you configure the provider in the administration console.
				</p></section></section><section class="section" id="add_remove_user_and_query_capability_interfaces"><div class="titlepage"><div><div><h2 class="title">7.7. Add/Remove User and Query Capability interfaces</h2></div></div></div><p>
				One thing we have not done with our example is allow it to add and remove users or change passwords. Users defined in our example are also not queryable or viewable in the administration console. To add these enhancements, our example provider must implement the <code class="literal">UserQueryProvider</code> and <code class="literal">UserRegistrationProvider</code> interfaces.
			</p><section class="section" id="implementing_userregistrationprovider"><div class="titlepage"><div><div><h3 class="title">7.7.1. Implementing UserRegistrationProvider</h3></div></div></div><p>
					To implement adding and removing users from this particular store, we first have to be able to save our properties file to disk.
				</p><div class="formalpara"><p class="title"><strong>PropertyFileUserStorageProvider</strong></p><p>
						
<pre class="programlisting language-java">    public void save() {
        String path = model.getConfig().getFirst("path");
        path = EnvUtil.replace(path);
        try {
            FileOutputStream fos = new FileOutputStream(path);
            properties.store(fos, "");
            fos.close();
        } catch (IOException e) {
            throw new RuntimeException(e);
        }
    }</pre>
					</p></div><p>
					Then, the implementation of the <code class="literal">addUser()</code> and <code class="literal">removeUser()</code> methods becomes simple.
				</p><div class="formalpara"><p class="title"><strong>PropertyFileUserStorageProvider</strong></p><p>
						
<pre class="programlisting language-java">    public static final String UNSET_PASSWORD="#$!-UNSET-PASSWORD";

    @Override
    public UserModel addUser(RealmModel realm, String username) {
        synchronized (properties) {
            properties.setProperty(username, UNSET_PASSWORD);
            save();
        }
        return createAdapter(realm, username);
    }

    @Override
    public boolean removeUser(RealmModel realm, UserModel user) {
        synchronized (properties) {
            if (properties.remove(user.getUsername()) == null) return false;
            save();
            return true;
        }
    }</pre>
					</p></div><p>
					Notice that when adding a user we set the password value of the property map to be <code class="literal">UNSET_PASSWORD</code>. We do this as we can’t have null values for a property in the property value. We also have to modify the <code class="literal">CredentialInputValidator</code> methods to reflect this.
				</p><p>
					The <code class="literal">addUser()</code> method will be called if the provider implements the <code class="literal">UserRegistrationProvider</code> interface. If your provider has a configuration switch to turn off adding a user, returning <code class="literal">null</code> from this method will skip the provider and call the next one.
				</p><div class="formalpara"><p class="title"><strong>PropertyFileUserStorageProvider</strong></p><p>
						
<pre class="programlisting language-java">    @Override
    public boolean isValid(RealmModel realm, UserModel user, CredentialInput input) {
        if (!supportsCredentialType(input.getType()) || !(input instanceof UserCredentialModel)) return false;

        UserCredentialModel cred = (UserCredentialModel)input;
        String password = properties.getProperty(user.getUsername());
        if (password == null || UNSET_PASSWORD.equals(password)) return false;
        return password.equals(cred.getValue());
    }</pre>
					</p></div><p>
					Since we can now save our property file, it also makes sense to allow password updates.
				</p><div class="formalpara"><p class="title"><strong>PropertyFileUserStorageProvider</strong></p><p>
						
<pre class="programlisting language-java">    @Override
    public boolean updateCredential(RealmModel realm, UserModel user, CredentialInput input) {
        if (!(input instanceof UserCredentialModel)) return false;
        if (!input.getType().equals(CredentialModel.PASSWORD)) return false;
        UserCredentialModel cred = (UserCredentialModel)input;
        synchronized (properties) {
            properties.setProperty(user.getUsername(), cred.getValue());
            save();
        }
        return true;
    }</pre>
					</p></div><p>
					We can now also implement disabling a password.
				</p><div class="formalpara"><p class="title"><strong>PropertyFileUserStorageProvider</strong></p><p>
						
<pre class="programlisting language-java">    @Override
    public void disableCredentialType(RealmModel realm, UserModel user, String credentialType) {
        if (!credentialType.equals(CredentialModel.PASSWORD)) return;
        synchronized (properties) {
            properties.setProperty(user.getUsername(), UNSET_PASSWORD);
            save();
        }

    }

    private static final Set&lt;String&gt; disableableTypes = new HashSet&lt;&gt;();

    static {
        disableableTypes.add(CredentialModel.PASSWORD);
    }

    @Override
    public Set&lt;String&gt; getDisableableCredentialTypes(RealmModel realm, UserModel user) {

        return disableableTypes;
    }</pre>
					</p></div><p>
					With these methods implemented, you’ll now be able to change and disable the password for the user in the administration console.
				</p></section><section class="section" id="implementing_userqueryprovider"><div class="titlepage"><div><div><h3 class="title">7.7.2. Implementing UserQueryProvider</h3></div></div></div><p>
					Without implementing <code class="literal">UserQueryProvider</code> the administration console would not be able to view and manage users that were loaded by our example provider. Let’s look at implementing this interface.
				</p><div class="formalpara"><p class="title"><strong>PropertyFileUserStorageProvider</strong></p><p>
						
<pre class="programlisting language-java">    @Override
    public int getUsersCount(RealmModel realm) {
        return properties.size();
    }

    @Override
    public List&lt;UserModel&gt; getUsers(RealmModel realm) {
        return getUsers(realm, 0, Integer.MAX_VALUE);
    }

    @Override
    public List&lt;UserModel&gt; getUsers(RealmModel realm, int firstResult, int maxResults) {
        List&lt;UserModel&gt; users = new LinkedList&lt;&gt;();
        int i = 0;
        for (Object obj : properties.keySet()) {
            if (i++ &lt; firstResult) continue;
            String username = (String)obj;
            UserModel user = getUserByUsername(username, realm);
            users.add(user);
            if (users.size() &gt;= maxResults) break;
        }
        return users;
    }</pre>
					</p></div><p>
					The <code class="literal">getUsers()</code> method iterates over the key set of the property file, delegating to <code class="literal">getUserByUsername()</code> to load a user. Notice that we are indexing this call based on the <code class="literal">firstResult</code> and <code class="literal">maxResults</code> parameter. If your external store does not support pagination, you will have to do similar logic.
				</p><div class="formalpara"><p class="title"><strong>PropertyFileUserStorageProvider</strong></p><p>
						
<pre class="programlisting language-java">    @Override
    public List&lt;UserModel&gt; searchForUser(String search, RealmModel realm) {
        return searchForUser(search, realm, 0, Integer.MAX_VALUE);
    }

    @Override
    public List&lt;UserModel&gt; searchForUser(String search, RealmModel realm, int firstResult, int maxResults) {
        List&lt;UserModel&gt; users = new LinkedList&lt;&gt;();
        int i = 0;
        for (Object obj : properties.keySet()) {
            String username = (String)obj;
            if (!username.contains(search)) continue;
            if (i++ &lt; firstResult) continue;
            UserModel user = getUserByUsername(username, realm);
            users.add(user);
            if (users.size() &gt;= maxResults) break;
        }
        return users;
    }</pre>
					</p></div><p>
					The first declaration of <code class="literal">searchForUser()</code> takes a <code class="literal">String</code> parameter. This is supposed to be a string that you use to search username and email attributes to find the user. This string can be a substring, which is why we use the <code class="literal">String.contains()</code> method when doing our search.
				</p><div class="formalpara"><p class="title"><strong>PropertyFileUserStorageProvider</strong></p><p>
						
<pre class="programlisting language-java">    @Override
    public List&lt;UserModel&gt; searchForUser(Map&lt;String, String&gt; params, RealmModel realm) {
        return searchForUser(params, realm, 0, Integer.MAX_VALUE);
    }

    @Override
    public List&lt;UserModel&gt; searchForUser(Map&lt;String, String&gt; params, RealmModel realm, int firstResult, int maxResults) {
        // only support searching by username
        String usernameSearchString = params.get("username");
        if (usernameSearchString == null) return Collections.EMPTY_LIST;
        return searchForUser(usernameSearchString, realm, firstResult, maxResults);
    }</pre>
					</p></div><p>
					The <code class="literal">searchForUser()</code> method that takes a <code class="literal">Map</code> parameter can search for a user based on first, last name, username, and email. We only store usernames, so we only search based on usernames. We delegate to <code class="literal">searchForUser()</code> for this.
				</p><div class="formalpara"><p class="title"><strong>PropertyFileUserStorageProvider</strong></p><p>
						
<pre class="programlisting language-java">    @Override
    public List&lt;UserModel&gt; getGroupMembers(RealmModel realm, GroupModel group, int firstResult, int maxResults) {
        return Collections.EMPTY_LIST;
    }

    @Override
    public List&lt;UserModel&gt; getGroupMembers(RealmModel realm, GroupModel group) {
        return Collections.EMPTY_LIST;
    }

    @Override
    public List&lt;UserModel&gt; searchForUserByUserAttribute(String attrName, String attrValue, RealmModel realm) {
        return Collections.EMPTY_LIST;
    }</pre>
					</p></div><p>
					We do not store groups or attributes, so the other methods return an empty list.
				</p></section></section><section class="section" id="augmenting_external_storage"><div class="titlepage"><div><div><h2 class="title">7.8. Augmenting External Storage</h2></div></div></div><p>
				The <code class="literal">PropertyFileUserStorageProvider</code> example is really limited. While we will be able to login with users stored in a property file, we won’t be able to do much else. If users loaded by this provider need special role or group mappings to fully access particular applications there is no way for us to add additional role mappings to these users. You also can’t modify or add additional important attributes like email, first and last name.
			</p><p>
				For these types of situations, Red Hat Single Sign-On allows you to augment your external store by storing extra information in Red Hat Single Sign-On’s database. This is called federated user storage and is encapsulated within the <code class="literal">org.keycloak.storage.federated.UserFederatedStorageProvider</code> class.
			</p><div class="formalpara"><p class="title"><strong>UserFederatedStorageProvider</strong></p><p>
					
<pre class="programlisting language-java">package org.keycloak.storage.federated;

public interface UserFederatedStorageProvider extends Provider {

    Set&lt;GroupModel&gt; getGroups(RealmModel realm, String userId);
    void joinGroup(RealmModel realm, String userId, GroupModel group);
    void leaveGroup(RealmModel realm, String userId, GroupModel group);
    List&lt;String&gt; getMembership(RealmModel realm, GroupModel group, int firstResult, int max);

...</pre>
				</p></div><p>
				The <code class="literal">UserFederatedStorageProvider</code> instance is available on the <code class="literal">KeycloakSession.userFederatedStorage()</code> method. It has all different kinds of methods for storing attributes, group and role mappings, different credential types, and required actions. If your external store’s datamodel cannot support the full Red Hat Single Sign-On feature set, then this service can fill in the gaps.
			</p><p>
				Red Hat Single Sign-On comes with a helper class <code class="literal">org.keycloak.storage.adapter.AbstractUserAdapterFederatedStorage</code> that will delegate every single <code class="literal">UserModel</code> method except get/set of username to user federated storage. Override the methods you need to override to delegate to your external storage representations. It is strongly suggested you read the javadoc of this class as it has smaller protected methods you may want to override. Specifically surrounding group membership and role mappings.
			</p><section class="section" id="augmentation_example"><div class="titlepage"><div><div><h3 class="title">7.8.1. Augmentation Example</h3></div></div></div><p>
					In our <code class="literal">PropertyFileUserStorageProvider</code> example, we just need a simple change to our provider to use the <code class="literal">AbstractUserAdapterFederatedStorage</code>.
				</p><div class="formalpara"><p class="title"><strong>PropertyFileUserStorageProvider</strong></p><p>
						
<pre class="programlisting language-java">    protected UserModel createAdapter(RealmModel realm, String username) {
        return new AbstractUserAdapterFederatedStorage(session, realm, model) {
            @Override
            public String getUsername() {
                return username;
            }

            @Override
            public void setUsername(String username) {
                String pw = (String)properties.remove(username);
                if (pw != null) {
                    properties.put(username, pw);
                    save();
                }
            }
        };
    }</pre>
					</p></div><p>
					We instead define an anonymous class implementation of <code class="literal">AbstractUserAdapterFederatedStorage</code>. The <code class="literal">setUsername()</code> method makes changes to the properties file and saves it.
				</p></section></section><section class="section" id="import_implementation_strategy"><div class="titlepage"><div><div><h2 class="title">7.9. Import Implementation Strategy</h2></div></div></div><p>
				When implementing a user storage provider, there’s another strategy you can take. Instead of using user federated storage, you can create a user locally in the Red Hat Single Sign-On built-in user database and copy attributes from your external store into this local copy. There are many advantages to this approach.
			</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">
						Red Hat Single Sign-On basically becomes a persistence user cache for your external store. Once the user is imported you’ll no longer hit the external store thus taking load off of it.
					</li><li class="listitem">
						If you are moving to Red Hat Single Sign-On as your official user store and deprecating the old external store, you can slowly migrate applications to use Red Hat Single Sign-On. When all applications have been migrated, unlink the imported user, and retire the old legacy external store.
					</li></ul></div><p>
				There are some obvious disadvantages though to using an import strategy:
			</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">
						Looking up a user for the first time will require multiple updates to Red Hat Single Sign-On database. This can be a big performance loss under load and put a lot of strain on the Red Hat Single Sign-On database. The user federated storage approach will only store extra data as needed and may never be used depending on the capabilities of your external store.
					</li><li class="listitem">
						With the import approach, you have to keep local Red Hat Single Sign-On storage and external storage in sync. The User Storage SPI has capability interfaces that you can implement to support synchronization, but this can quickly become painful and messy.
					</li></ul></div><p>
				To implement the import strategy you simply check to see first if the user has been imported locally. If so return the local user, if not create the user locally and import data from the external store. You can also proxy the local user so that most changes are automatically synchronized.
			</p><p>
				This will be a bit contrived, but we can extend our <code class="literal">PropertyFileUserStorageProvider</code> to take this approach. We begin first by modifying the <code class="literal">createAdapter()</code> method.
			</p><div class="formalpara"><p class="title"><strong>PropertyFileUserStorageProvider</strong></p><p>
					
<pre class="programlisting language-java">    protected UserModel createAdapter(RealmModel realm, String username) {
        UserModel local = session.userLocalStorage().getUserByUsername(username, realm);
        if (local == null) {
            local = session.userLocalStorage().addUser(realm, username);
            local.setFederationLink(model.getId());
        }
        return new UserModelDelegate(local) {
            @Override
            public void setUsername(String username) {
                String pw = (String)properties.remove(username);
                if (pw != null) {
                    properties.put(username, pw);
                    save();
                }
                super.setUsername(username);
            }
        };
    }</pre>
				</p></div><p>
				In this method we call the <code class="literal">KeycloakSession.userLocalStorage()</code> method to obtain a reference to local Red Hat Single Sign-On user storage. We see if the user is stored locally, if not, we add it locally. Do not set the <code class="literal">id</code> of the local user. Let Red Hat Single Sign-On automatically generate the <code class="literal">id</code>. Also note that we call <code class="literal">UserModel.setFederationLink()</code> and pass in the ID of the <code class="literal">ComponentModel</code> of our provider. This sets a link between the provider and the imported user.
			</p><div class="admonition note"><div class="admonition_header">Note</div><div><p>
					When a user storage provider is removed, any user imported by it will also be removed. This is one of the purposes of calling <code class="literal">UserModel.setFederationLink()</code>.
				</p></div></div><p>
				Another thing to note is that if a local user is linked, your storage provider will still be delegated to for methods that it implements from the <code class="literal">CredentialInputValidator</code> and <code class="literal">CredentialInputUpdater</code> interfaces. Returning <code class="literal">false</code> from a validation or update will just result in Red Hat Single Sign-On seeing if it can validate or update using local storage.
			</p><p>
				Also notice that we are proxying the local user using the <code class="literal">org.keycloak.models.utils.UserModelDelegate</code> class. This class is an implementation of <code class="literal">UserModel</code>. Every method just delegates to the <code class="literal">UserModel</code> it was instantiated with. We override the <code class="literal">setUsername()</code> method of this delegate class to synchronize automatically with the property file. For your providers, you can use this to <span class="emphasis"><em>intercept</em></span> other methods on the local <code class="literal">UserModel</code> to perform synchronization with your external store. For example, get methods could make sure that the local store is in sync. Set methods keep the external store in sync with the local one. One thing to note is that the <code class="literal">getId()</code> method should always return the id that was auto generated when you created the user locally. You should not return a federated id as shown in the other non-import examples.
			</p><div class="admonition note"><div class="admonition_header">Note</div><div><p>
					If your provider is implementing the <code class="literal">UserRegistrationProvider</code> interface, your <code class="literal">removeUser()</code> method does not need to remove the user from local storage. The runtime will automatically perform this operation. Also note that <code class="literal">removeUser()</code> will be invoked before it is removed from local storage.
				</p></div></div><section class="section" id="importeduservalidation_interface"><div class="titlepage"><div><div><h3 class="title">7.9.1. ImportedUserValidation Interface</h3></div></div></div><p>
					If you remember earlier in this chapter, we discussed how querying for a user worked. Local storage is queried first, if the user is found there, then the query ends. This is a problem for our above implementation as we want to proxy the local <code class="literal">UserModel</code> so that we can keep usernames in sync. The User Storage SPI has a callback for whenever a linked local user is loaded from the local database.
				</p><pre class="programlisting language-java">package org.keycloak.storage.user;
public interface ImportedUserValidation {
    /**
     * If this method returns null, then the user in local storage will be removed
     *
     * @param realm
     * @param user
     * @return null if user no longer valid
     */
    UserModel validate(RealmModel realm, UserModel user);
}</pre><p>
					Whenever a linked local user is loaded, if the user storage provider class implements this interface, then the <code class="literal">validate()</code> method is called. Here you can proxy the local user passed in as a parameter and return it. That new <code class="literal">UserModel</code> will be used. You can also optionally do a check to see if the user still exists in the external store. If <code class="literal">validate()</code> returns <code class="literal">null</code>, then the local user will be removed from the database.
				</p></section><section class="section" id="importsynchronization_interface"><div class="titlepage"><div><div><h3 class="title">7.9.2. ImportSynchronization Interface</h3></div></div></div><p>
					With the import strategy you can see that it is possible for the local user copy to get out of sync with external storage. For example, maybe a user has been removed from the external store. The User Storage SPI has an additional interface you can implement to deal with this, <code class="literal">org.keycloak.storage.user.ImportSynchronization</code>:
				</p><pre class="programlisting language-java">package org.keycloak.storage.user;

public interface ImportSynchronization {
    SynchronizationResult sync(KeycloakSessionFactory sessionFactory, String realmId, UserStorageProviderModel model);
    SynchronizationResult syncSince(Date lastSync, KeycloakSessionFactory sessionFactory, String realmId, UserStorageProviderModel model);
}</pre><p>
					This interface is implemented by the provider factory. Once this interface is implemented by the provider factory, the administration console management page for the provider shows additional options. You can manually force a synchronization by clicking a button. This invokes the <code class="literal">ImportSynchronization.sync()</code> method. Also, additional configuration options are displayed that allow you to automatically schedule a synchronization. Automatic synchronizations invoke the <code class="literal">syncSince()</code> method.
				</p></section></section><section class="section" id="user_caches"><div class="titlepage"><div><div><h2 class="title">7.10. User Caches</h2></div></div></div><p>
				When a user object is loaded by ID, username, or email queries it is cached. When a user object is being cached, it iterates through the entire <code class="literal">UserModel</code> interface and pulls this information to a local in-memory-only cache. In a cluster, this cache is still local, but it becomes an invalidation cache. When a user object is modified, it is evicted. This eviction event is propagated to the entire cluster so that the other nodes' user cache is also invalidated.
			</p><section class="section" id="managing_the_user_cache"><div class="titlepage"><div><div><h3 class="title">7.10.1. Managing the user cache</h3></div></div></div><p>
					You can access the user cache by calling <code class="literal">KeycloakSession.userCache()</code>.
				</p><pre class="programlisting language-java">/**
 * All these methods effect an entire cluster of Keycloak instances.
 *
 * @author &lt;a href="mailto:bill@burkecentral.com"&gt;Bill Burke&lt;/a&gt;
 * @version $Revision: 1 $
 */
public interface UserCache extends UserProvider {
    /**
     * Evict user from cache.
     *
     * @param user
     */
    void evict(RealmModel realm, UserModel user);

    /**
     * Evict users of a specific realm
     *
     * @param realm
     */
    void evict(RealmModel realm);

    /**
     * Clear cache entirely.
     *
     */
    void clear();
}</pre><p>
					There are methods for evicting specific users, users contained in a specific realm, or the entire cache.
				</p></section><section class="section" id="onusercache_callback_interface"><div class="titlepage"><div><div><h3 class="title">7.10.2. OnUserCache Callback Interface</h3></div></div></div><p>
					You might want to cache additional information that is specific to your provider implementation. The User Storage SPI has a callback whenever a user is cached: <code class="literal">org.keycloak.models.cache.OnUserCache</code>.
				</p><pre class="programlisting language-java">public interface OnUserCache {
    void onCache(RealmModel realm, CachedUserModel user, UserModel delegate);
}</pre><p>
					Your provider class should implement this interface if it wants this callback. The <code class="literal">UserModel</code> delegate parameter is the <code class="literal">UserModel</code> instance returned by your provider. The <code class="literal">CachedUserModel</code> is an expanded <code class="literal">UserModel</code> interface. This is the instance that is cached locally in local storage.
				</p><pre class="programlisting language-java">public interface CachedUserModel extends UserModel {

    /**
     * Invalidates the cache for this user and returns a delegate that represents the actual data provider
     *
     * @return
     */
    UserModel getDelegateForUpdate();

    boolean isMarkedForEviction();

    /**
     * Invalidate the cache for this model
     *
     */
    void invalidate();

    /**
     * When was the model was loaded from database.
     *
     * @return
     */
    long getCacheTimestamp();

    /**
     * Returns a map that contains custom things that are cached along with this model.  You can write to this map.
     *
     * @return
     */
    ConcurrentHashMap getCachedWith();
}</pre><p>
					This <code class="literal">CachedUserModel</code> interface allows you to evict the user from the cache and get the provider <code class="literal">UserModel</code> instance. The <code class="literal">getCachedWith()</code> method returns a map that allows you to cache additional information pertaining to the user. For example, credentials are not part of the <code class="literal">UserModel</code> interface. If you wanted to cache credentials in memory, you would implement <code class="literal">OnUserCache</code> and cache your user’s credentials using the <code class="literal">getCachedWith()</code> method.
				</p></section><section class="section" id="cache_policies"><div class="titlepage"><div><div><h3 class="title">7.10.3. Cache Policies</h3></div></div></div><p>
					On the administration console management page for your user storage provider, you can specify a unique cache policy.
				</p></section></section><section class="section" id="leveraging_java_ee_2"><div class="titlepage"><div><div><h2 class="title">7.11. Leveraging Java EE</h2></div></div></div><p>
				The user storage providers can be packaged within any Java EE component if you set up the <code class="literal">META-INF/services</code> file correctly to point to your providers. For example, if your provider needs to use third-party libraries, you can package up your provider within an EAR and store these third-party libraries in the <code class="literal">lib/</code> directory of the EAR. Also note that provider JARs can make use of the <code class="literal">jboss-deployment-structure.xml</code> file that EJBs, WARS, and EARs can use in a JBoss EAP environment. For more details on this file, see the JBoss EAP documentation. It allows you to pull in external dependencies among other fine-grained actions.
			</p><p>
				Provider implementations are required to be plain java objects. But we also currently support implementing <code class="literal">UserStorageProvider</code> classes as Stateful EJBs. This is especially useful if you want to use JPA to connect to a relational store. This is how you would do it:
			</p><pre class="programlisting language-java">@Stateful
@Local(EjbExampleUserStorageProvider.class)
public class EjbExampleUserStorageProvider implements UserStorageProvider,
        UserLookupProvider,
        UserRegistrationProvider,
        UserQueryProvider,
        CredentialInputUpdater,
        CredentialInputValidator,
        OnUserCache
{
    @PersistenceContext
    protected EntityManager em;

    protected ComponentModel model;
    protected KeycloakSession session;

    public void setModel(ComponentModel model) {
        this.model = model;
    }

    public void setSession(KeycloakSession session) {
        this.session = session;
    }


    @Remove
    @Override
    public void close() {
    }
...
}</pre><p>
				You have to define the <code class="literal">@Local</code> annotation and specify your provider class there. If you do not do this, EJB will not proxy the user correctly and your provider won’t work.
			</p><p>
				You must put the <code class="literal">@Remove</code> annotation on the <code class="literal">close()</code> method of your provider. If you do not, the stateful bean will never be cleaned up and you might eventually see error messages.
			</p><p>
				Implementations of <code class="literal">UserStorageProvider</code> are required to be plain Java objects. Your factory class would perform a JNDI lookup of the Stateful EJB in its create() method.
			</p><pre class="programlisting language-java">public class EjbExampleUserStorageProviderFactory
        implements UserStorageProviderFactory&lt;EjbExampleUserStorageProvider&gt; {

    @Override
    public EjbExampleUserStorageProvider create(KeycloakSession session, ComponentModel model) {
        try {
            InitialContext ctx = new InitialContext();
            EjbExampleUserStorageProvider provider = (EjbExampleUserStorageProvider)ctx.lookup(
                     "java:global/user-storage-jpa-example/" + EjbExampleUserStorageProvider.class.getSimpleName());
            provider.setModel(model);
            provider.setSession(session);
            return provider;
        } catch (Exception e) {
            throw new RuntimeException(e);
        }
    }</pre><p>
				This example also assumes that you have defined a JPA deployment in the same JAR as the provider. This means a <code class="literal">persistence.xml</code> file as well as any JPA <code class="literal">@Entity</code> classes.
			</p><div class="admonition warning"><div class="admonition_header">Warning</div><div><p>
					When using JPA any additional datasource must be an XA datasource. The Red Hat Single Sign-On datasource is not an XA datasource. If you interact with two or more non-XA datasources in the same transaction, the server returns an error message. Only one non-XA resource is permitted in a single transaction. See the JBoss EAP manual for more details on deploying an XA datasource.
				</p></div></div><p>
				CDI is not supported.
			</p></section><section class="section" id="rest_management_api"><div class="titlepage"><div><div><h2 class="title">7.12. REST Management API</h2></div></div></div><p>
				You can create, remove, and update your user storage provider deployments through the administrator REST API. The User Storage SPI is built on top of a generic component interface so you will be using that generic API to manage your providers.
			</p><p>
				The REST Component API lives under your realm admin resource.
			</p><pre class="screen">/admin/realms/{realm-name}/components</pre><p>
				We will only show this REST API interaction with the Java client. Hopefully you can extract how to do this from <code class="literal">curl</code> from this API.
			</p><pre class="programlisting language-java">public interface ComponentsResource {
    @GET
    @Produces(MediaType.APPLICATION_JSON)
    public List&lt;ComponentRepresentation&gt; query();

    @GET
    @Produces(MediaType.APPLICATION_JSON)
    public List&lt;ComponentRepresentation&gt; query(@QueryParam("parent") String parent);

    @GET
    @Produces(MediaType.APPLICATION_JSON)
    public List&lt;ComponentRepresentation&gt; query(@QueryParam("parent") String parent, @QueryParam("type") String type);

    @GET
    @Produces(MediaType.APPLICATION_JSON)
    public List&lt;ComponentRepresentation&gt; query(@QueryParam("parent") String parent,
                                               @QueryParam("type") String type,
                                               @QueryParam("name") String name);

    @POST
    @Consumes(MediaType.APPLICATION_JSON)
    Response add(ComponentRepresentation rep);

    @Path("{id}")
    ComponentResource component(@PathParam("id") String id);
}

public interface ComponentResource {
    @GET
    public ComponentRepresentation toRepresentation();

    @PUT
    @Consumes(MediaType.APPLICATION_JSON)
    public void update(ComponentRepresentation rep);

    @DELETE
    public void remove();
}</pre><p>
				To create a user storage provider, you must specify the provider id, a provider type of the string <code class="literal">org.keycloak.storage.UserStorageProvider</code>, as well as the configuration.
			</p><pre class="programlisting language-java">import org.keycloak.admin.client.Keycloak;
import org.keycloak.representations.idm.RealmRepresentation;
...

Keycloak keycloak = Keycloak.getInstance(
    "http://localhost:8080/auth",
    "master",
    "admin",
    "password",
    "admin-cli");
RealmResource realmResource = keycloak.realm("master");
RealmRepresentation realm = realmResource.toRepresentation();

ComponentRepresentation component = new ComponentRepresentation();
component.setName("home");
component.setProviderId("readonly-property-file");
component.setProviderType("org.keycloak.storage.UserStorageProvider");
component.setParentId(realm.getId());
component.setConfig(new MultivaluedHashMap());
component.getConfig().putSingle("path", "~/users.properties");

realmResource.components().add(component);

// retrieve a component

List&lt;ComponentRepresentation&gt; components = realmResource.components().query(realm.getId(),
                                                                    "org.keycloak.storage.UserStorageProvider",
                                                                    "home");
component = components.get(0);

// Update a component

component.getConfig().putSingle("path", "~/my-users.properties");
realmResource.components().component(component.getId()).update(component);

// Remove a component

realmREsource.components().component(component.getId()).remove();</pre></section><section class="section" id="migrating_from_an_earlier_user_federation_spi"><div class="titlepage"><div><div><h2 class="title">7.13. Migrating from an Earlier User Federation SPI</h2></div></div></div><div class="admonition note"><div class="admonition_header">Note</div><div><p>
					This chapter is only applicable if you have implemented a provider using the earlier (and now removed) User Federation SPI.
				</p></div></div><p>
				In Keycloak version 2.4.0 and earlier there was a User Federation SPI. Red Hat Single Sign-On version 7.0, although unsupported, had this earlier SPI available as well. This earlier User Federation SPI has been removed from Keycloak version 2.5.0 and Red Hat Single Sign-On version 7.1. However, if you have written a provider with this earlier SPI, this chapter discusses some strategies you can use to port it.
			</p><section class="section" id="import_vs_non_import"><div class="titlepage"><div><div><h3 class="title">7.13.1. Import vs. Non-Import</h3></div></div></div><p>
					The earlier User Federation SPI required you to create a local copy of a user in the Red Hat Single Sign-On’s database and import information from your external store to the local copy. However, this is no longer a requirement. You can still port your earlier provider as-is, but you should consider whether a non-import strategy might be a better approach.
				</p><p>
					Advantages of the import strategy:
				</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">
							Red Hat Single Sign-On basically becomes a persistence user cache for your external store. Once the user is imported you’ll no longer hit the external store, thus taking load off of it.
						</li><li class="listitem">
							If you are moving to Red Hat Single Sign-On as your official user store and deprecating the earlier external store, you can slowly migrate applications to use Red Hat Single Sign-On. When all applications have been migrated, unlink the imported user, and retire the earlier legacy external store.
						</li></ul></div><p>
					There are some obvious disadvantages though to using an import strategy:
				</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">
							Looking up a user for the first time will require multiple updates to Red Hat Single Sign-On database. This can be a big performance loss under load and put a lot of strain on the Red Hat Single Sign-On database. The user federated storage approach will only store extra data as needed and might never be used depending on the capabilities of your external store.
						</li><li class="listitem">
							With the import approach, you have to keep local Red Hat Single Sign-On storage and external storage in sync. The User Storage SPI has capability interfaces that you can implement to support synchronization, but this can quickly become painful and messy.
						</li></ul></div></section><section class="section" id="userfederationprovider_vs_userstorageprovider"><div class="titlepage"><div><div><h3 class="title">7.13.2. UserFederationProvider vs. UserStorageProvider</h3></div></div></div><p>
					The first thing to notice is that <code class="literal">UserFederationProvider</code> was a complete interface. You implemented every method in this interface. However, <code class="literal">UserStorageProvider</code> has instead broken up this interface into multiple capability interfaces that you implement as needed.
				</p><p>
					<code class="literal">UserFederationProvider.getUserByUsername()</code> and <code class="literal">getUserByEmail()</code> have exact equivalents in the new SPI. The difference between the two is how you import. If you are going to continue with an import strategy, you no longer call <code class="literal">KeycloakSession.userStorage().addUser()</code> to create the user locally. Instead you call <code class="literal">KeycloakSession.userLocalStorage().addUser()</code>. The <code class="literal">userStorage()</code> method no longer exists.
				</p><p>
					The <code class="literal">UserFederationProvider.validateAndProxy()</code> method has been moved to an optional capability interface, <code class="literal">ImportedUserValidation</code>. You want to implement this interface if you are porting your earlier provider as-is. Also note that in the earlier SPI, this method was called every time the user was accessed, even if the local user is in the cache. In the later SPI, this method is only called when the local user is loaded from local storage. If the local user is cached, then the <code class="literal">ImportedUserValidation.validate()</code> method is not called at all.
				</p><p>
					The <code class="literal">UserFederationProvider.isValid()</code> method no longer exists in the later SPI.
				</p><p>
					The <code class="literal">UserFederationProvider</code> methods <code class="literal">synchronizeRegistrations()</code>, <code class="literal">registerUser()</code>, and <code class="literal">removeUser()</code> have been moved to the <code class="literal">UserRegistrationProvider</code> capability interface. This new interface is optional to implement so if your provider does not support creating and removing users, you don’t have to implement it. If your earlier provider had switch to toggle support for registering new users, this is supported in the new SPI, returning <code class="literal">null</code> from <code class="literal">UserRegistrationProvider.addUser()</code> if the provider doesn’t support adding users.
				</p><p>
					The earlier <code class="literal">UserFederationProvider</code> methods centered around credentials are now encapsulated in the <code class="literal">CredentialInputValidator</code> and <code class="literal">CredentialInputUpdater</code> interfaces, which are also optional to implement depending on if you support validating or updating credentials. Credential management used to exist in <code class="literal">UserModel</code> methods. These also have been moved to the <code class="literal">CredentialInputValidator</code> and <code class="literal">CredentialInputUpdater</code> interfaces. One thing to note that if you do not implement the <code class="literal">CredentialInputUpdater</code> interface, then any credentials provided by your provider can be overridden locally in Red Hat Single Sign-On storage. So if you want your credentials to be read-only, implement the <code class="literal">CredentialInputUpdater.updateCredential()</code> method and return a <code class="literal">ReadOnlyException</code>.
				</p><p>
					The <code class="literal">UserFederationProvider</code> query methods such as <code class="literal">searchByAttributes()</code> and <code class="literal">getGroupMembers()</code> are now encapsulated in an optional interface <code class="literal">UserQueryProvider</code>. If you do not implement this interface, then users will not be viewable in the admin console. You’ll still be able to login though.
				</p></section><section class="section" id="userfederationproviderfactory_vs_userstorageproviderfactory"><div class="titlepage"><div><div><h3 class="title">7.13.3. UserFederationProviderFactory vs. UserStorageProviderFactory</h3></div></div></div><p>
					The synchronization methods in the earlier SPI are now encapsulated within an optional <code class="literal">ImportSynchronization</code> interface. If you have implemented synchronization logic, then have your new <code class="literal">UserStorageProviderFactory</code> implement the <code class="literal">ImportSynchronization</code> interface.
				</p></section><section class="section" id="upgrading_to_a_new_model"><div class="titlepage"><div><div><h3 class="title">7.13.4. Upgrading to a New Model</h3></div></div></div><p>
					The User Storage SPI instances are stored in a different set of relational tables. Red Hat Single Sign-On automatically runs a migration script. If any earlier User Federation providers are deployed for a realm, they are converted to the later storage model as is, including the <code class="literal">id</code> of the data. This migration will only happen if a User Storage provider exists with the same provider ID (i.e., "ldap", "kerberos") as the earlier User Federation provider.
				</p><p>
					So, knowing this there are different approaches you can take.
				</p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem">
							You can remove the earlier provider in your earlier Red Hat Single Sign-On deployment. This will remove the local linked copies of all users you imported. Then, when you upgrade Red Hat Single Sign-On, just deploy and configure your new provider for your realm.
						</li><li class="listitem">
							The second option is to write your new provider making sure it has the same provider ID: <code class="literal">UserStorageProviderFactory.getId()</code>. Make sure this provider is in the <code class="literal">standalone/deployments/</code> directory of the new Red Hat Single Sign-On installation. Boot the server, and have the built-in migration script convert from the earlier data model to the later data model. In this case all your earlier linked imported users will work and be the same.
						</li></ol></div><p>
					If you have decided to get rid of the import strategy and rewrite your User Storage provider, we suggest that you remove the earlier provider before upgrading Red Hat Single Sign-On. This will remove linked local imported copies of any user you imported.
				</p></section></section></section><section class="chapter" id="vault-spi"><div class="titlepage"><div><div><h1 class="title">Chapter 8. Vault SPI</h1></div></div></div><section class="section" id="vault_provider"><div class="titlepage"><div><div><h2 class="title">8.1. Vault provider</h2></div></div></div><p>
				You can use a vault SPI from <code class="literal">org.keycloak.vault</code> package to write custom extension for Red Hat Single Sign-On to connect to arbitrary vault implementation.
			</p><p>
				The built-in <code class="literal">files-plaintext</code> provider is an example of the implementation of this SPI. In general the following rules apply:
			</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">
						To prevent a secret from leaking across realms, you may want to isolate or limit the secrets that can be retrieved by a realm. In that case, your provider should take into account the realm name when looking up secrets, for example by prefixing entries with the realm name. For example, an expression <code class="literal">${vault.key}</code> would then evaluate generally to different entry names, depending on whether it was used in a realm <span class="emphasis"><em>A</em></span> or realm <span class="emphasis"><em>B</em></span>. To differentiate between realms, the realm needs to be passed to the created <code class="literal">VaultProvider</code> instance from <code class="literal">VaultProviderFactory.create()</code> method where it is available from the <code class="literal">KeycloakSession</code> parameter.
					</li><li class="listitem">
						The vault provider needs to implement a single method <code class="literal">obtainSecret</code> that returns a <code class="literal">VaultRawSecret</code> for the given secret name. That class holds the representation of the secret either in <code class="literal">byte[]</code> or <code class="literal">ByteBuffer</code> and is expected to convert between the two upon demand. Note that this buffer would be discarded after usage as explained below.
					</li></ul></div><p>
				For details on how to package and deploy a custom provider refer to the <a class="link" href="#providers" title="Chapter 6. Service Provider Interfaces (SPI)">Service Provider Interfaces</a> chapter.
			</p></section><section class="section" id="consuming_values_from_vault"><div class="titlepage"><div><div><h2 class="title">8.2. Consuming values from vault</h2></div></div></div><p>
				The vault contains sensitive data and Red Hat Single Sign-On treats the secrets accordingly. When accessing a secret, the secret is obtained from the vault and retained in JVM memory only for the necessary time. Then all possible attempts to discard its content from JVM memory is done. This is achieved by using the vault secrets only within <code class="literal">try</code>-with-resources statement as outlined below:
			</p><pre class="programlisting language-java">    char[] c;
    try (VaultCharSecret cSecret = session.vault().getCharSecret(SECRET_NAME)) {
        // ... use cSecret
        c = cSecret.getAsArray().orElse(null);
        // if c != null, it now contains password
    }

    // if c != null, it now contains garbage</pre><p>
				The example uses <code class="literal">KeycloakSession.vault()</code> as the entrypoint for accessing the secrets. Using the <code class="literal">VaultProvider.obtainSecret</code> method directly is indeed also possible. However the <code class="literal">vault()</code> method has the benefit of ability to interpret the raw secret (which is generally a byte array) as a character array (via <code class="literal">vault().getCharSecret()</code>) or a <code class="literal">String</code> (via <code class="literal">vault().getStringSecret()</code>) in addition to obtaining the original uninterpreted value (via <code class="literal">vault().getRawSecret()</code> method).
			</p><p>
				Note that since <code class="literal">String</code> objects are immutable, their content cannot be discarded by overriding with random garbage. Even though measures have been taken in the default <code class="literal">VaultStringSecret</code> implementation to prevent internalizing <code class="literal">String</code>s, the secrets stored in <code class="literal">String</code> objects would live at least to the next GC round. Thus using plain byte and character arrays and buffers is preferable.
			</p></section></section><div><div xml:lang="en-US" class="legalnotice" id="idm140046320197568"><h1 class="legalnotice">Legal Notice</h1><div class="para">
				Copyright <span class="trademark"/>© 2019 Red Hat, Inc.
			</div><div class="para">
				Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with the License. You may obtain a copy of the License at
			</div><div class="para">
				<a class="ulink" href="http://www.apache.org/licenses/LICENSE-2.0"> http://www.apache.org/licenses/LICENSE-2.0</a>
			</div><div class="para">
				Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.
			</div></div></div></div></div></div><script type="text/javascript">
                        jQuery(document).ready(function() {
                            initSwitchery();
                            jQuery('pre[class*="language-"]').each(function(i, block){hljs.highlightBlock(block);});
                        });
                    </script></body></html>