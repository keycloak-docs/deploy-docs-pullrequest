<?xml version='1.0' encoding='UTF-8'?>
<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" class="chrometwo"><head><title>Server Administration Guide</title><link rel="stylesheet" type="text/css" href="Common_Content/css/default.css"/><meta name="generator" content="publican v4.3.4"/><meta name="description" content="This guide consists of information for administrators to configure Red Hat Single Sign-On 7.4"/><link rel="next" href="#overview" title="Chapter 1. Overview"/><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/><script type="text/javascript" src="Common_Content/scripts/jquery-1.7.1.min.js"> </script><script type="text/javascript" src="Common_Content/scripts/utils.js"> </script><script type="text/javascript" src="Common_Content/scripts/highlight.js/highlight.pack.js"> </script></head><body><div id="chrometwo"><div id="main"><div xml:lang="en-US" class="book" id="idm140464633734976"><div class="titlepage"><div><div class="producttitle"><span class="productname">Red Hat Single Sign-On</span> <span class="productnumber">7.4</span></div><div><h1 class="title">Server Administration Guide</h1></div><div><h2 class="subtitle">For Use with Red Hat Single Sign-On 7.4</h2></div><div><div xml:lang="en-US" class="authorgroup"><span class="orgname">Red Hat Customer Content Services</span></div></div><div><a href="#idm140464637189680">Legal Notice</a></div><div><div class="abstract"><p class="title"><strong>Abstract</strong></p><div class="para">
				This guide consists of information for administrators to configure Red Hat Single Sign-On 7.4
			</div></div></div></div><hr/></div><div class="toc"><ul class="toc"><li><span class="chapter"><a href="#overview">1. Overview</a></span><ul><li><span class="section"><a href="#features">1.1. Features</a></span></li><li><span class="section"><a href="#how_does_security_work">1.2. How Does Security Work?</a></span></li><li><span class="section"><a href="#core_concepts_and_terms">1.3. Core Concepts and Terms</a></span></li></ul></li><li><span class="chapter"><a href="#server_initialization">2. Server Initialization</a></span></li><li><span class="chapter"><a href="#admin_console">3. Admin Console</a></span><ul><li><span class="section"><a href="#the_master_realm">3.1. The Master Realm</a></span></li><li><span class="section"><a href="#create-realm">3.2. Create a New Realm</a></span></li><li><span class="section"><a href="#ssl_modes">3.3. SSL Mode</a></span></li><li><span class="section"><a href="#clear-cache">3.4. Clearing Server Caches</a></span></li><li><span class="section"><a href="#email">3.5. Email Settings</a></span></li><li><span class="section"><a href="#themes">3.6. Themes and Internationalization</a></span><ul><li><span class="section"><a href="#internationalization">3.6.1. Internationalization</a></span></li></ul></li></ul></li><li><span class="chapter"><a href="#user_management">4. User Management</a></span><ul><li><span class="section"><a href="#searching_for_users">4.1. Searching For Users</a></span></li><li><span class="section"><a href="#create-new-user">4.2. Creating New Users</a></span></li><li><span class="section"><a href="#delete-user">4.3. Deleting Users</a></span></li><li><span class="section"><a href="#user_attributes">4.4. User Attributes</a></span></li><li><span class="section"><a href="#user-credentials">4.5. User Credentials</a></span><ul><li><span class="section"><a href="#creating_a_password_for_the_user">4.5.1. Creating a Password for the User</a></span></li><li><span class="section"><a href="#creating_other_credentials">4.5.2. Creating other credentials</a></span></li></ul></li><li><span class="section"><a href="#required_actions">4.6. Required Actions</a></span><ul><li><span class="section"><a href="#default_required_actions">4.6.1. Default Required Actions</a></span></li><li><span class="section"><a href="#terms_and_conditions">4.6.2. Terms and Conditions</a></span></li></ul></li><li><span class="section"><a href="#impersonation">4.7. Impersonation</a></span></li><li><span class="section"><a href="#user-registration">4.8. User Registration</a></span><ul><li><span class="section"><a href="#recaptcha">4.8.1. reCAPTCHA Support</a></span></li></ul></li><li><span class="section"><a href="#personal_data">4.9. Personal data collected by Red Hat Single Sign-On</a></span></li></ul></li><li><span class="chapter"><a href="#login_page_settings">5. Login Page Settings</a></span><ul><li><span class="section"><a href="#forgot_password">5.1. Forgot Password</a></span></li><li><span class="section"><a href="#remember_me">5.2. Remember Me</a></span></li></ul></li><li><span class="chapter"><a href="#authentication">6. Authentication</a></span><ul><li><span class="section"><a href="#password-policies">6.1. Password Policies</a></span><ul><li><span class="section"><a href="#password_policy_types">6.1.1. Password Policy Types</a></span></li></ul></li><li><span class="section"><a href="#otp_policies">6.2. OTP Policies</a></span><ul><li><span class="section"><a href="#totp_vs_hotp">6.2.1. TOTP vs. HOTP</a></span></li><li><span class="section"><a href="#totp_configuration_options">6.2.2. TOTP Configuration Options</a></span></li><li><span class="section"><a href="#hotp_configuration_options">6.2.3. HOTP Configuration Options</a></span></li></ul></li><li><span class="section"><a href="#authentication-flows">6.3. Authentication Flows</a></span><ul><li><span class="section"><a href="#built_in_flows">6.3.1. Built-in flows</a></span></li><li><span class="section"><a href="#creating_flows">6.3.2. Creating flows</a></span></li><li><span class="section"><a href="#creating_a_password_less_browser_login_flow">6.3.3. Creating a password-less browser login flow</a></span></li></ul></li><li><span class="section"><a href="#kerberos">6.4. Kerberos</a></span><ul><li><span class="section"><a href="#setup_of_kerberos_server">6.4.1. Setup of Kerberos server</a></span></li><li><span class="section"><a href="#setup_and_configuration_of_red_hat_single_sign_on_server">6.4.2. Setup and configuration of Red Hat Single Sign-On server</a></span></li><li><span class="section"><a href="#setup_and_configuration_of_client_machines">6.4.3. Setup and configuration of client machines</a></span></li><li><span class="section"><a href="#credential_delegation">6.4.4. Credential Delegation</a></span></li><li><span class="section"><a href="#cross_realm_trust">6.4.5. Cross-realm trust</a></span></li><li><span class="section"><a href="#troubleshooting">6.4.6. Troubleshooting</a></span></li></ul></li><li><span class="section"><a href="#x509">6.5. X.509 Client Certificate User Authentication</a></span><ul><li><span class="section"><a href="#features_2">6.5.1. Features</a></span></li><li><span class="section"><a href="#enable_x_509_client_certificate_user_authentication">6.5.2. Enable X.509 Client Certificate User Authentication</a></span></li><li><span class="section"><a href="#adding_x_509_client_certificate_authentication_to_a_browser_flow">6.5.3. Adding X.509 Client Certificate Authentication to a Browser Flow</a></span></li><li><span class="section"><a href="#adding_x_509_client_certificate_authentication_to_a_direct_grant_flow">6.5.4. Adding X.509 Client Certificate Authentication to a Direct Grant Flow</a></span></li><li><span class="section"><a href="#client_certificate_lookup">6.5.5. Client certificate lookup</a></span></li><li><span class="section"><a href="#troubleshooting_2">6.5.6. Troubleshooting</a></span></li></ul></li><li><span class="section"><a href="#webauthn">6.6. W3C Web Authentication (WebAuthn)</a></span><ul><li><span class="section"><a href="#setup">6.6.1. Setup</a></span></li><li><span class="section"><a href="#authenticate_with_webauthn_authenticator">6.6.2. Authenticate with WebAuthn Authenticator</a></span></li><li><span class="section"><a href="#managing_webauthn_as_an_administrator">6.6.3. Managing WebAuthn as an administrator</a></span></li><li><span class="section"><a href="#attestation_statement_verification">6.6.4. Attestation Statement Verification</a></span></li><li><span class="section"><a href="#managing_webauthn_credentials_as_a_user">6.6.5. Managing WebAuthn credentials as a user</a></span></li><li><span class="section"><a href="#passwordless_webauthn_together_with_two_factor">6.6.6. Passwordless WebAuthn together with Two-Factor</a></span></li></ul></li></ul></li><li><span class="chapter"><a href="#sso_protocols">7. SSO Protocols</a></span><ul><li><span class="section"><a href="#oidc">7.1. OpenID Connect</a></span><ul><li><span class="section"><a href="#oidc-auth-flows">7.1.1. OIDC Auth Flows</a></span></li><li><span class="section"><a href="#red_hat_single_sign_on_server_oidc_uri_endpoints">7.1.2. Red Hat Single Sign-On Server OIDC URI Endpoints</a></span></li></ul></li><li><span class="section"><a href="#saml">7.2. SAML</a></span><ul><li><span class="section"><a href="#saml_bindings">7.2.1. SAML Bindings</a></span></li><li><span class="section"><a href="#red_hat_single_sign_on_server_saml_uri_endpoints">7.2.2. Red Hat Single Sign-On Server SAML URI Endpoints</a></span></li></ul></li><li><span class="section"><a href="#openid_connect_vs_saml">7.3. OpenID Connect vs. SAML</a></span></li><li><span class="section"><a href="#docker">7.4. Docker Registry v2 Authentication</a></span><ul><li><span class="section"><a href="#docker_auth_flow">7.4.1. Docker Auth Flow</a></span></li><li><span class="section"><a href="#red_hat_single_sign_on_docker_registry_v2_authentication_server_uri_endpoints">7.4.2. Red Hat Single Sign-On Docker Registry v2 Authentication Server URI Endpoints</a></span></li></ul></li></ul></li><li><span class="chapter"><a href="#clients">8. Managing Clients</a></span><ul><li><span class="section"><a href="#oidc_clients">8.1. OIDC Clients</a></span><ul><li><span class="section"><a href="#advanced_settings">8.1.1. Advanced Settings</a></span></li><li><span class="section"><a href="#client-credentials">8.1.2. Confidential Client Credentials</a></span></li><li><span class="section"><a href="#service_accounts">8.1.3. Service Accounts</a></span></li><li><span class="section"><a href="#audience">8.1.4. Audience Support</a></span></li></ul></li><li><span class="section"><a href="#saml_clients">8.2. SAML Clients</a></span><ul><li><span class="section"><a href="#idp_initiated_login">8.2.1. IDP Initiated Login</a></span></li><li><span class="section"><a href="#saml_entity_descriptors">8.2.2. SAML Entity Descriptors</a></span></li></ul></li><li><span class="section"><a href="#client_links">8.3. Client Links</a></span></li><li><span class="section"><a href="#protocol-mappers">8.4. OIDC Token and SAML Assertion Mappings</a></span><ul><li><span class="section"><a href="#priority_order">8.4.1. Priority order</a></span></li><li><span class="section"><a href="#protocol-mappers_oidc-user-session-note-mappers">8.4.2. OIDC User Session Note Mappers</a></span></li><li><span class="section"><a href="#script_mapper">8.4.3. Script Mapper</a></span></li></ul></li><li><span class="section"><a href="#client_installation">8.5. Generating Client Adapter Config</a></span></li><li><span class="section"><a href="#client_scopes">8.6. Client Scopes</a></span><ul><li><span class="section"><a href="#protocol">8.6.1. Protocol</a></span></li><li><span class="section"><a href="#consent_related_settings">8.6.2. Consent related settings</a></span></li><li><span class="section"><a href="#client_scopes_linking">8.6.3. Link Client Scope with the Client</a></span></li><li><span class="section"><a href="#client_scopes_evaluate">8.6.4. Evaluating Client Scopes</a></span></li><li><span class="section"><a href="#client_scopes_permissions">8.6.5. Client Scopes Permissions</a></span></li><li><span class="section"><a href="#realm_default_client_scopes">8.6.6. Realm Default Client Scopes</a></span></li><li><span class="section"><a href="#scopes_explained">8.6.7. Scopes explained</a></span></li></ul></li></ul></li><li><span class="chapter"><a href="#roles">9. Roles</a></span><ul><li><span class="section"><a href="#realm_roles">9.1. Realm Roles</a></span></li><li><span class="section"><a href="#client_roles">9.2. Client Roles</a></span></li><li><span class="section"><a href="#composite-roles">9.3. Composite Roles</a></span></li><li><span class="section"><a href="#user_role_mappings">9.4. User Role Mappings</a></span><ul><li><span class="section"><a href="#default_roles">9.4.1. Default Roles</a></span></li></ul></li><li><span class="section"><a href="#role_scope_mappings">9.5. Role Scope Mappings</a></span></li></ul></li><li><span class="chapter"><a href="#groups">10. Groups</a></span><ul><li><span class="section"><a href="#groups_vs_roles">10.1. Groups vs. Roles</a></span></li><li><span class="section"><a href="#default_groups">10.2. Default Groups</a></span></li></ul></li><li><span class="chapter"><a href="#admin_permissions">11. Admin Console Access Control and Permissions</a></span><ul><li><span class="section"><a href="#master_realm_access_control">11.1. Master Realm Access Control</a></span><ul><li><span class="section"><a href="#global_roles">11.1.1. Global Roles</a></span></li><li><span class="section"><a href="#realm_specific_roles">11.1.2. Realm Specific Roles</a></span></li></ul></li><li><span class="section"><a href="#per_realm_admin_permissions">11.2. Dedicated Realm Admin Consoles</a></span></li><li><span class="section"><a href="#fine_grain_permissions">11.3. Fine Grain Admin Permissions</a></span><ul><li><span class="section"><a href="#managing_one_specific_client">11.3.1. Managing One Specific Client</a></span></li><li><span class="section"><a href="#restrict_user_role_mapping">11.3.2. Restrict User Role Mapping</a></span></li><li><span class="section"><a href="#full_list_of_permissions">11.3.3. Full List of Permissions</a></span></li></ul></li><li><span class="section"><a href="#realm_keys">11.4. Realm Keys</a></span><ul><li><span class="section"><a href="#rotating_keys">11.4.1. Rotating keys</a></span></li><li><span class="section"><a href="#adding_a_generated_keypair">11.4.2. Adding a generated keypair</a></span></li><li><span class="section"><a href="#adding_an_existing_keypair_and_certificate">11.4.3. Adding an existing keypair and certificate</a></span></li><li><span class="section"><a href="#loading_keys_from_a_java_keystore">11.4.4. Loading keys from a Java Keystore</a></span></li><li><span class="section"><a href="#making_keys_passive">11.4.5. Making keys passive</a></span></li><li><span class="section"><a href="#disabling_keys">11.4.6. Disabling keys</a></span></li><li><span class="section"><a href="#compromised_keys">11.4.7. Compromised keys</a></span></li></ul></li></ul></li><li><span class="chapter"><a href="#identity_broker">12. Identity Brokering</a></span><ul><li><span class="section"><a href="#identity_broker_overview">12.1. Brokering Overview</a></span></li><li><span class="section"><a href="#default_identity_provider">12.2. Default Identity Provider</a></span></li><li><span class="section"><a href="#general-idp-config">12.3. General Configuration</a></span></li><li><span class="section"><a href="#social_identity_providers">12.4. Social Identity Providers</a></span><ul><li><span class="section"><a href="#bitbucket">12.4.1. Bitbucket</a></span></li><li><span class="section"><a href="#facebook">12.4.2. Facebook</a></span></li><li><span class="section"><a href="#github">12.4.3. GitHub</a></span></li><li><span class="section"><a href="#gitlab">12.4.4. GitLab</a></span></li><li><span class="section"><a href="#google">12.4.5. Google</a></span></li><li><span class="section"><a href="#linkedin">12.4.6. LinkedIn</a></span></li><li><span class="section"><a href="#microsoft">12.4.7. Microsoft</a></span></li><li><span class="section"><a href="#openshift_3">12.4.8. OpenShift 3</a></span></li><li><span class="section"><a href="#openshift_4">12.4.9. OpenShift 4</a></span></li><li><span class="section"><a href="#paypal">12.4.10. PayPal</a></span></li><li><span class="section"><a href="#stack_overflow">12.4.11. Stack Overflow</a></span></li><li><span class="section"><a href="#twitter">12.4.12. Twitter</a></span></li></ul></li><li><span class="section"><a href="#identity_broker_oidc">12.5. OpenID Connect v1.0 Identity Providers</a></span></li><li><span class="section"><a href="#saml_v2_0_identity_providers">12.6. SAML v2.0 Identity Providers</a></span><ul><li><span class="section"><a href="#identity_broker_saml_sp_descriptor">12.6.1. SP Descriptor</a></span></li></ul></li><li><span class="section"><a href="#client_suggested_idp">12.7. Client-suggested Identity Provider</a></span></li><li><span class="section"><a href="#mappers">12.8. Mapping Claims and Assertions</a></span></li><li><span class="section"><a href="#available_user_session_data">12.9. Available User Session Data</a></span></li><li><span class="section"><a href="#identity_broker_first_login">12.10. First Login Flow</a></span><ul><li><span class="section"><a href="#default_first_login_flow">12.10.1. Default First Login Flow</a></span></li><li><span class="section"><a href="#automatically_link_existing_first_login_flow">12.10.2. Automatically Link Existing First Login Flow</a></span></li><li><span class="section"><a href="#disabling_automatic_user_creation">12.10.3. Disabling Automatic User Creation</a></span></li></ul></li><li><span class="section"><a href="#retrieving_external_idp_tokens">12.11. Retrieving External IDP Tokens</a></span></li><li><span class="section"><a href="#identity_broker_logout">12.12. Identity broker logout</a></span></li></ul></li><li><span class="chapter"><a href="#user_session_management">13. User Session Management</a></span><ul><li><span class="section"><a href="#administering_sessions">13.1. Administering Sessions</a></span><ul><li><span class="section"><a href="#limitations_of_the_literal_logout_all_literal_operation">13.1.1. Limitations of the <code class="literal">Logout all</code> Operation</a></span></li><li><span class="section"><a href="#application_drilldown">13.1.2. Application Drilldown</a></span></li><li><span class="section"><a href="#user_drilldown">13.1.3. User Drilldown</a></span></li></ul></li><li><span class="section"><a href="#revocation-policy">13.2. Revocation Policies</a></span></li><li><span class="section"><a href="#timeouts">13.3. Session and Token Timeouts</a></span></li><li><span class="section"><a href="#offline-access">13.4. Offline Access</a></span></li></ul></li><li><span class="chapter"><a href="#user-storage-federation">14. User Storage Federation</a></span><ul><li><span class="section"><a href="#adding_a_provider">14.1. Adding a Provider</a></span></li><li><span class="section"><a href="#dealing_with_provider_failures">14.2. Dealing with Provider Failures</a></span></li><li><span class="section"><a href="#ldap">14.3. LDAP and Active Directory</a></span><ul><li><span class="section"><a href="#storage_mode">14.3.1. Storage Mode</a></span></li><li><span class="section"><a href="#edit_mode">14.3.2. Edit Mode</a></span></li><li><span class="section"><a href="#other_config_options">14.3.3. Other config options</a></span></li><li><span class="section"><a href="#connect_to_ldap_over_ssl">14.3.4. Connect to LDAP over SSL</a></span></li><li><span class="section"><a href="#sync_of_ldap_users_to_red_hat_single_sign_on">14.3.5. Sync of LDAP users to Red Hat Single Sign-On</a></span></li><li><span class="section"><a href="#ldap_mappers">14.3.6. LDAP Mappers</a></span></li><li><span class="section"><a href="#ldap_password_hashing">14.3.7. Password Hashing</a></span></li></ul></li><li><span class="section"><a href="#sssd">14.4. SSSD and FreeIPA Identity Management Integration</a></span><ul><li><span class="section"><a href="#freeipa_idm_server">14.4.1. FreeIPA/IdM Server</a></span></li><li><span class="section"><a href="#sssd_and_d_bus">14.4.2. SSSD and D-Bus</a></span></li><li><span class="section"><a href="#enabling_the_sssd_federation_provider">14.4.3. Enabling the SSSD Federation Provider</a></span></li></ul></li><li><span class="section"><a href="#configuring_a_federated_sssd_store">14.5. Configuring a Federated SSSD Store</a></span></li><li><span class="section"><a href="#custom_providers">14.6. Custom Providers</a></span></li></ul></li><li><span class="chapter"><a href="#auditing_and_events">15. Auditing and Events</a></span><ul><li><span class="section"><a href="#login_events">15.1. Login Events</a></span><ul><li><span class="section"><a href="#event_types">15.1.1. Event Types</a></span></li><li><span class="section"><a href="#event_listener">15.1.2. Event Listener</a></span></li></ul></li><li><span class="section"><a href="#admin_events">15.2. Admin Events</a></span></li></ul></li><li><span class="chapter"><a href="#export_import">16. Export and Import</a></span><ul><li><span class="section"><a href="#admin_console_export_import">16.1. Admin console export/import</a></span></li></ul></li><li><span class="chapter"><a href="#vault-administration">17. Using Vault to Obtain Secrets</a></span><ul><li><span class="section"><a href="#kubernetes_openshift_files_plaintext_vault_provider">17.1. Kubernetes / OpenShift Files Plaintext Vault Provider</a></span></li><li><span class="section"><a href="#elytron_credential_store_vault_provider">17.2. Elytron Credential Store Vault Provider</a></span></li><li><span class="section"><a href="#key_resolvers">17.3. Key Resolvers</a></span></li></ul></li><li><span class="chapter"><a href="#account-service">18. User Account Service</a></span><ul><li><span class="section"><a href="#themeable">18.1. Themeable</a></span></li></ul></li><li><span class="chapter"><a href="#threat_model_mitigation">19. Threat Model Mitigation</a></span><ul><li><span class="section"><a href="#host">19.1. Host</a></span></li><li><span class="section"><a href="#admin_endpoints_and_console">19.2. Admin Endpoints and Console</a></span><ul><li><span class="section"><a href="#ip_restriction">19.2.1. IP Restriction</a></span></li><li><span class="section"><a href="#port_restriction">19.2.2. Port Restriction</a></span></li></ul></li><li><span class="section"><a href="#password_guess_brute_force_attacks">19.3. Password guess: brute force attacks</a></span><ul><li><span class="section"><a href="#password_policies">19.3.1. Password Policies</a></span></li></ul></li><li><span class="section"><a href="#clickjacking">19.4. Clickjacking</a></span></li><li><span class="section"><a href="#ssl_https_requirement">19.5. SSL/HTTPS Requirement</a></span></li><li><span class="section"><a href="#csrf_attacks">19.6. CSRF Attacks</a></span></li><li><span class="section"><a href="#unspecific-redirect-uris">19.7. Unspecific Redirect URIs</a></span></li><li><span class="section"><a href="#compromised_access_and_refresh_tokens">19.8. Compromised Access and Refresh Tokens</a></span></li><li><span class="section"><a href="#compromised_authorization_code">19.9. Compromised Authorization Code</a></span></li><li><span class="section"><a href="#open_redirectors">19.10. Open redirectors</a></span></li><li><span class="section"><a href="#password_database_compromised">19.11. Password database compromised</a></span></li><li><span class="section"><a href="#limiting_scope">19.12. Limiting Scope</a></span></li><li><span class="section"><a href="#limit_token_audience">19.13. Limit Token Audience</a></span></li><li><span class="section"><a href="#sql_injection_attacks">19.14. SQL Injection Attacks</a></span></li></ul></li><li><span class="chapter"><a href="#the_admin_cli">20. The Admin CLI</a></span><ul><li><span class="section"><a href="#installing_the_admin_cli">20.1. Installing the Admin CLI</a></span></li><li><span class="section"><a href="#using_the_admin_cli">20.2. Using the Admin CLI</a></span></li><li><span class="section"><a href="#authenticating">20.3. Authenticating</a></span></li><li><span class="section"><a href="#working_with_alternative_configurations">20.4. Working with alternative configurations</a></span></li><li><span class="section"><a href="#basic_operations_and_resource_uris">20.5. Basic operations and resource URIs</a></span></li><li><span class="section"><a href="#realm_operations">20.6. Realm operations</a></span></li><li><span class="section"><a href="#role_operations">20.7. Role operations</a></span></li><li><span class="section"><a href="#client_operations">20.8. Client operations</a></span></li><li><span class="section"><a href="#user_operations">20.9. User operations</a></span></li><li><span class="section"><a href="#group_operations">20.10. Group operations</a></span></li><li><span class="section"><a href="#identity_provider_operations">20.11. Identity provider operations</a></span></li><li><span class="section"><a href="#storage_provider_operations">20.12. Storage provider operations</a></span></li><li><span class="section"><a href="#adding_mappers">20.13. Adding mappers</a></span></li><li><span class="section"><a href="#authentication_operations">20.14. Authentication operations</a></span></li></ul></li></ul></div><section class="chapter" id="overview"><div class="titlepage"><div><div><h1 class="title">Chapter 1. Overview</h1></div></div></div><p>
			Red Hat Single Sign-On is a single sign on solution for web apps and RESTful web services. The goal of Red Hat Single Sign-On is to make security simple so that it is easy for application developers to secure the apps and services they have deployed in their organization. Security features that developers normally have to write for themselves are provided out of the box and are easily tailorable to the individual requirements of your organization. Red Hat Single Sign-On provides customizable user interfaces for login, registration, administration, and account management. You can also use Red Hat Single Sign-On as an integration platform to hook it into existing LDAP and Active Directory servers. You can also delegate authentication to third party identity providers like Facebook and Google+.
		</p><section class="section" id="features"><div class="titlepage"><div><div><h2 class="title">1.1. Features</h2></div></div></div><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">
						Single-Sign On and Single-Sign Out for browser applications.
					</li><li class="listitem">
						OpenID Connect support.
					</li><li class="listitem">
						OAuth 2.0 support.
					</li><li class="listitem">
						SAML support.
					</li><li class="listitem">
						Identity Brokering - Authenticate with external OpenID Connect or SAML Identity Providers.
					</li><li class="listitem">
						Social Login - Enable login with Google, GitHub, Facebook, Twitter, and other social networks.
					</li><li class="listitem">
						User Federation - Sync users from LDAP and Active Directory servers.
					</li><li class="listitem">
						Kerberos bridge - Automatically authenticate users that are logged-in to a Kerberos server.
					</li><li class="listitem">
						Admin Console for central management of users, roles, role mappings, clients and configuration.
					</li><li class="listitem">
						Account Management console that allows users to centrally manage their account.
					</li><li class="listitem">
						Theme support - Customize all user facing pages to integrate with your applications and branding.
					</li><li class="listitem">
						Two-factor Authentication - Support for TOTP/HOTP via Google Authenticator or FreeOTP.
					</li><li class="listitem">
						Login flows - optional user self-registration, recover password, verify email, require password update, etc.
					</li><li class="listitem">
						Session management - Admins and users themselves can view and manage user sessions.
					</li><li class="listitem">
						Token mappers - Map user attributes, roles, etc. how you want into tokens and statements.
					</li><li class="listitem">
						Not-before revocation policies per realm, application and user.
					</li><li class="listitem">
						CORS support - Client adapters have built-in support for CORS.
					</li><li class="listitem">
						Client adapters for JavaScript applications, JBoss EAP, Fuse, etc.
					</li><li class="listitem">
						Supports any platform/language that has an OpenID Connect Relying Party library or SAML 2.0 Service Provider library.
					</li></ul></div></section><section class="section" id="how_does_security_work"><div class="titlepage"><div><div><h2 class="title">1.2. How Does Security Work?</h2></div></div></div><p>
				Red Hat Single Sign-On is a separate server that you manage on your network. Applications are configured to point to and be secured by this server. Red Hat Single Sign-On uses open protocol standards like <a class="link" href="https://openid.net/connect/">OpenID Connect</a> or <a class="link" href="http://saml.xml.org/saml-specifications">SAML 2.0</a> to secure your applications. Browser applications redirect a user’s browser from the application to the Red Hat Single Sign-On authentication server where they enter their credentials. This is important because users are completely isolated from applications and applications never see a user’s credentials. Applications instead are given an identity token or assertion that is cryptographically signed. These tokens can have identity information like username, address, email, and other profile data. They can also hold permission data so that applications can make authorization decisions. These tokens can also be used to make secure invocations on REST-based services.
			</p></section><section class="section" id="core_concepts_and_terms"><div class="titlepage"><div><div><h2 class="title">1.3. Core Concepts and Terms</h2></div></div></div><p>
				There are some key concepts and terms you should be aware of before attempting to use Red Hat Single Sign-On to secure your web applications and REST services.
			</p><div class="variablelist"><dl class="variablelist"><dt><span class="term">users</span></dt><dd>
							Users are entities that are able to log into your system. They can have attributes associated with themselves like email, username, address, phone number, and birth day. They can be assigned group membership and have specific roles assigned to them.
						</dd><dt><span class="term">authentication</span></dt><dd>
							The process of identifying and validating a user.
						</dd><dt><span class="term">authorization</span></dt><dd>
							The process of granting access to a user.
						</dd><dt><span class="term">credentials</span></dt><dd>
							Credentials are pieces of data that Red Hat Single Sign-On uses to verify the identity of a user. Some examples are passwords, one-time-passwords, digital certificates, or even fingerprints.
						</dd><dt><span class="term">roles</span></dt><dd>
							Roles identify a type or category of user. <code class="literal">Admin</code>, <code class="literal">user</code>, <code class="literal">manager</code>, and <code class="literal">employee</code> are all typical roles that may exist in an organization. Applications often assign access and permissions to specific roles rather than individual users as dealing with users can be too fine grained and hard to manage.
						</dd><dt><span class="term">user role mapping</span></dt><dd>
							A user role mapping defines a mapping between a role and a user. A user can be associated with zero or more roles. This role mapping information can be encapsulated into tokens and assertions so that applications can decide access permissions on various resources they manage.
						</dd><dt><span class="term">composite roles</span></dt><dd>
							A composite role is a role that can be associated with other roles. For example a <code class="literal">superuser</code> composite role could be associated with the <code class="literal">sales-admin</code> and <code class="literal">order-entry-admin</code> roles. If a user is mapped to the <code class="literal">superuser</code> role they also inherit the <code class="literal">sales-admin</code> and <code class="literal">order-entry-admin</code> roles.
						</dd><dt><span class="term">groups</span></dt><dd>
							Groups manage groups of users. Attributes can be defined for a group. You can map roles to a group as well. Users that become members of a group inherit the attributes and role mappings that group defines.
						</dd><dt><span class="term">realms</span></dt><dd>
							A realm manages a set of users, credentials, roles, and groups. A user belongs to and logs into a realm. Realms are isolated from one another and can only manage and authenticate the users that they control.
						</dd><dt><span class="term">clients</span></dt><dd>
							Clients are entities that can request Red Hat Single Sign-On to authenticate a user. Most often, clients are applications and services that want to use Red Hat Single Sign-On to secure themselves and provide a single sign-on solution. Clients can also be entities that just want to request identity information or an access token so that they can securely invoke other services on the network that are secured by Red Hat Single Sign-On.
						</dd><dt><span class="term">client adapters</span></dt><dd>
							Client adapters are plugins that you install into your application environment to be able to communicate and be secured by Red Hat Single Sign-On. Red Hat Single Sign-On has a number of adapters for different platforms that you can download. There are also third-party adapters you can get for environments that we don’t cover.
						</dd><dt><span class="term">consent</span></dt><dd>
							Consent is when you as an admin want a user to give permission to a client before that client can participate in the authentication process. After a user provides their credentials, Red Hat Single Sign-On will pop up a screen identifying the client requesting a login and what identity information is requested of the user. User can decide whether or not to grant the request.
						</dd><dt><span class="term">client scopes</span></dt><dd>
							When a client is registered, you must define protocol mappers and role scope mappings for that client. It is often useful to store a client scope, to make creating new clients easier by sharing some common settings. This is also useful for requesting some claims or roles to be conditionally based on the value of <code class="literal">scope</code> parameter. Red Hat Single Sign-On provides the concept of a client scope for this.
						</dd><dt><span class="term">client role</span></dt><dd>
							Clients can define roles that are specific to them. This is basically a role namespace dedicated to the client.
						</dd><dt><span class="term">identity token</span></dt><dd>
							A token that provides identity information about the user. Part of the OpenID Connect specification.
						</dd><dt><span class="term">access token</span></dt><dd>
							A token that can be provided as part of an HTTP request that grants access to the service being invoked on. This is part of the OpenID Connect and OAuth 2.0 specification.
						</dd><dt><span class="term">assertion</span></dt><dd>
							Information about a user. This usually pertains to an XML blob that is included in a SAML authentication response that provided identity metadata about an authenticated user.
						</dd><dt><span class="term">service account</span></dt><dd>
							Each client has a built-in service account which allows it to obtain an access token.
						</dd><dt><span class="term">direct grant</span></dt><dd>
							A way for a client to obtain an access token on behalf of a user via a REST invocation.
						</dd><dt><span class="term">protocol mappers</span></dt><dd>
							For each client you can tailor what claims and assertions are stored in the OIDC token or SAML assertion. You do this per client by creating and configuring protocol mappers.
						</dd><dt><span class="term">session</span></dt><dd>
							When a user logs in, a session is created to manage the login session. A session contains information like when the user logged in and what applications have participated within single-sign on during that session. Both admins and users can view session information.
						</dd><dt><span class="term">user federation provider</span></dt><dd>
							Red Hat Single Sign-On can store and manage users. Often, companies already have LDAP or Active Directory services that store user and credential information. You can point Red Hat Single Sign-On to validate credentials from those external stores and pull in identity information.
						</dd><dt><span class="term">identity provider</span></dt><dd>
							An identity provider (IDP) is a service that can authenticate a user. Red Hat Single Sign-On is an IDP.
						</dd><dt><span class="term">identity provider federation</span></dt><dd>
							Red Hat Single Sign-On can be configured to delegate authentication to one or more IDPs. Social login via Facebook or Google+ is an example of identity provider federation. You can also hook Red Hat Single Sign-On to delegate authentication to any other OpenID Connect or SAML 2.0 IDP.
						</dd><dt><span class="term">identity provider mappers</span></dt><dd>
							When doing IDP federation you can map incoming tokens and assertions to user and session attributes. This helps you propagate identity information from the external IDP to your client requesting authentication.
						</dd><dt><span class="term">required actions</span></dt><dd>
							Required actions are actions a user must perform during the authentication process. A user will not be able to complete the authentication process until these actions are complete. For example, an admin may schedule users to reset their passwords every month. An <code class="literal">update password</code> required action would be set for all these users.
						</dd><dt><span class="term">authentication flows</span></dt><dd>
							Authentication flows are work flows a user must perform when interacting with certain aspects of the system. A login flow can define what credential types are required. A registration flow defines what profile information a user must enter and whether something like reCAPTCHA must be used to filter out bots. Credential reset flow defines what actions a user must do before they can reset their password.
						</dd><dt><span class="term">events</span></dt><dd>
							Events are audit streams that admins can view and hook into.
						</dd><dt><span class="term">themes</span></dt><dd>
							Every screen provided by Red Hat Single Sign-On is backed by a theme. Themes define HTML templates and stylesheets which you can override as needed.
						</dd></dl></div></section></section><section class="chapter" id="server_initialization"><div class="titlepage"><div><div><h1 class="title">Chapter 2. Server Initialization</h1></div></div></div><p>
			After performing all the installation and configuration tasks defined in the <a class="link" href="https://access.redhat.com/documentation/en-us/red_hat_single_sign-on/7.4/html-single/server_installation_and_configuration_guide/">Server Installation and Configuration Guide</a>, you will need to create an initial admin account. Red Hat Single Sign-On does not have any configured admin account out of the box. This account will allow you to create an admin that can log into the <span class="emphasis"><em>master</em></span> realm’s administration console so that you can start creating realms, users and registering applications to be secured by Red Hat Single Sign-On.
		</p><p>
			If your server is accessible from <code class="literal">localhost</code>, you can boot it up and create this admin user by going to the <a class="link" href="http://localhost:8080/auth">http://localhost:8080/auth</a> URL.
		</p><div class="formalpara"><p class="title"><strong>Welcome Page</strong></p><p>
				<span class="inlinemediaobject"><img src="images/rhsso-images/initial-welcome-page.png" alt="initial welcome page"/></span>
			</p></div><p>
			Simply specify the username and password you want for this initial admin.
		</p><p>
			If you cannot access the server via a <code class="literal">localhost</code> address, or just want to provision Red Hat Single Sign-On from the command line you can do this with the <code class="literal">…​/bin/add-user-keycloak</code> script.
		</p><div class="formalpara"><p class="title"><strong>add-user-keycloak script</strong></p><p>
				<span class="inlinemediaobject"><img src="images/rhsso-images/add-user-script.png" alt="add user script"/></span>
			</p></div><p>
			The parameters are a little different depending if you are using the standalone operation mode or domain operation mode. For standalone mode, here is how you use the script.
		</p><div class="formalpara"><p class="title"><strong>Linux/Unix</strong></p><p>
				
<pre class="screen">$ .../bin/add-user-keycloak.sh -r master -u &lt;username&gt; -p &lt;password&gt;</pre>
			</p></div><div class="formalpara"><p class="title"><strong>Windows</strong></p><p>
				
<pre class="screen">&gt; ...\bin\add-user-keycloak.bat -r master -u &lt;username&gt; -p &lt;password&gt;</pre>
			</p></div><p>
			For domain mode, you have to point the script to one of your server hosts using the <code class="literal">-sc</code> switch.
		</p><div class="formalpara"><p class="title"><strong>Linux/Unix</strong></p><p>
				
<pre class="screen">$ .../bin/add-user-keycloak.sh --sc domain/servers/server-one/configuration -r master -u &lt;username&gt; -p &lt;password&gt;</pre>
			</p></div><div class="formalpara"><p class="title"><strong>Windows</strong></p><p>
				
<pre class="screen">&gt; ...\bin\add-user-keycloak.bat --sc domain/servers/server-one/configuration -r master -u &lt;username&gt; -p &lt;password&gt;</pre>
			</p></div></section><section class="chapter" id="admin_console"><div class="titlepage"><div><div><h1 class="title">Chapter 3. Admin Console</h1></div></div></div><p>
			The bulk of your administrative tasks will be done through the Red Hat Single Sign-On Admin Console. You can go to the console url directly at <a class="link" href="http://localhost:8080/auth/admin/">http://localhost:8080/auth/admin/</a>
		</p><div class="formalpara"><p class="title"><strong>Login Page</strong></p><p>
				<span class="inlinemediaobject"><img src="images/rhsso-images/login-page.png" alt="login page"/></span>
			</p></div><p>
			Enter the username and password you created on the Welcome Page or the <code class="literal">add-user-keycloak</code> script in the bin directory. This will bring you to the Red Hat Single Sign-On Admin Console.
		</p><div class="formalpara"><p class="title"><strong>Admin Console</strong></p><p>
				<span class="inlinemediaobject"><img src="images/rhsso-images/admin-console.png" alt="admin console"/></span>
			</p></div><p>
			The left drop down menu allows you to pick a realm you want to manage or to create a new one. The right drop down menu allows you to view your user account or logout. If you are curious about a certain feature, button, or field within the Admin Console, simply hover your mouse over any question mark <code class="literal">?</code> icon. This will pop up tooltip text to describe the area of the console you are interested in. The image above shows the tooltip in action.
		</p><section class="section" id="the_master_realm"><div class="titlepage"><div><div><h2 class="title">3.1. The Master Realm</h2></div></div></div><p>
				When you boot Red Hat Single Sign-On for the first time Red Hat Single Sign-On creates a pre-defined realm for you. This initial realm is the <span class="emphasis"><em>master</em></span> realm. It is the highest level in the hierarchy of realms. Admin accounts in this realm have permissions to view and manage any other realm created on the server instance. When you define your initial admin account, you create an account in the <span class="emphasis"><em>master</em></span> realm. Your initial login to the admin console will also be via the <span class="emphasis"><em>master</em></span> realm.
			</p><p>
				We recommend that you do not use the <span class="emphasis"><em>master</em></span> realm to manage the users and applications in your organization. Reserve use of the <span class="emphasis"><em>master</em></span> realm for <span class="emphasis"><em>super</em></span> admins to create and manage the realms in your system. Following this security model helps prevent accidental changes and follows the tradition of permitting user accounts access to only those privileges and powers necessary for the successful completion of their current task.
			</p><p>
				It is possible to disable the <span class="emphasis"><em>master</em></span> realm and define admin accounts within each individual new realm you create. Each realm has its own dedicated Admin Console that you can log into with local accounts. This guide talks more about this in the <a class="link" href="#per_realm_admin_permissions" title="11.2. Dedicated Realm Admin Consoles">Dedicated Realm Admin Consoles</a> chapter.
			</p></section><section class="section" id="create-realm"><div class="titlepage"><div><div><h2 class="title">3.2. Create a New Realm</h2></div></div></div><p>
				Creating a new realm is very simple. Mouse over the top left corner drop down menu that is titled with <code class="literal">Master</code>. If you are logged in the master realm this drop down menu lists all the realms created. The last entry of this drop down menu is always <code class="literal">Add Realm</code>. Click this to add a realm.
			</p><div class="formalpara"><p class="title"><strong>Add Realm Menu</strong></p><p>
					<span class="inlinemediaobject"><img src="images/rhsso-images/add-realm-menu.png" alt="add realm menu"/></span>
				</p></div><p>
				This menu option will bring you to the <code class="literal">Add Realm</code> page. Specify the realm name you want to define and click the <code class="literal">Create</code> button. Alternatively you can import a JSON document that defines your new realm. We’ll go over this in more detail in the <a class="link" href="#export_import" title="Chapter 16. Export and Import">Export and Import</a> chapter.
			</p><div class="formalpara"><p class="title"><strong>Create Realm</strong></p><p>
					<span class="inlinemediaobject"><img src="images/rhsso-images/create-realm.png" alt="create realm"/></span>
				</p></div><p>
				After creating the realm you are brought back to the main Admin Console page. The current realm will now be set to the realm you just created. You can switch between managing different realms by doing a mouse over on the top left corner drop down menu.
			</p></section><section class="section" id="ssl_modes"><div class="titlepage"><div><div><h2 class="title">3.3. SSL Mode</h2></div></div></div><p>
				Each realm has an SSL Mode associated with it. The SSL Mode defines the SSL/HTTPS requirements for interacting with the realm. Browsers and applications that interact with the realm must honor the SSL/HTTPS requirements defined by the SSL Mode or they will not be allowed to interact with the server.
			</p><div class="admonition warning"><div class="admonition_header">Warning</div><div><p>
					Red Hat Single Sign-On generates a self-signed certificate the first time it runs. Please note that self-signed certificates are not secure, and should only be used for testing purposes. It is highly recommended that you install a CA-signed certificate on the Red Hat Single Sign-On server itself or on a reverse proxy in front of the Red Hat Single Sign-On server. See the <a class="link" href="https://access.redhat.com/documentation/en-us/red_hat_single_sign-on/7.4/html-single/server_installation_and_configuration_guide/">Server Installation and Configuration Guide</a>.
				</p></div></div><p>
				To configure the SSL Mode of your realm, you need to click on the <code class="literal">Realm Settings</code> left menu item and go to the <code class="literal">Login</code> tab.
			</p><div class="formalpara"><p class="title"><strong>Login Tab</strong></p><p>
					<span class="inlinemediaobject"><img src="images/rhsso-images/login-tab.png" alt="login tab"/></span>
				</p></div><p>
				The <code class="literal">Require SSL</code> option allows you to pick the SSL Mode you want. Here is an explanation of each mode:
			</p><div class="variablelist"><dl class="variablelist"><dt><span class="term">external requests</span></dt><dd>
							Users can interact with Red Hat Single Sign-On without SSL so long as they stick to private IP addresses like <code class="literal">localhost</code>, <code class="literal">127.0.0.1</code>, <code class="literal">10.x.x.x</code>, <code class="literal">192.168.x.x</code>, and <code class="literal">172.16.x.x</code>. If you try to access Red Hat Single Sign-On without SSL from a non-private IP address you will get an error.
						</dd><dt><span class="term">none</span></dt><dd>
							Red Hat Single Sign-On does not require SSL. This should really only be used in development when you are playing around with things and don’t want to bother configuring SSL on your server.
						</dd><dt><span class="term">all requests</span></dt><dd>
							Red Hat Single Sign-On requires SSL for all IP addresses.
						</dd></dl></div></section><section class="section" id="clear-cache"><div class="titlepage"><div><div><h2 class="title">3.4. Clearing Server Caches</h2></div></div></div><p>
				Red Hat Single Sign-On will cache everything it can in memory within the limits of your JVM and/or the limits you’ve configured it for. If the Red Hat Single Sign-On database is modified by a third party (i.e. a DBA) outside the scope of the server’s REST APIs or Admin Console there’s a chance parts of the in-memory cache may be stale. You can clear the realm cache, user cache or cache of external public keys (Public keys of external clients or Identity providers, which Red Hat Single Sign-On usually uses to verify signatures of particular external entity) from the Admin Console by going to the <code class="literal">Realm Settings</code> left menu item and the <code class="literal">Cache</code> tab.
			</p><div class="formalpara"><p class="title"><strong>Cache tab</strong></p><p>
					<span class="inlinemediaobject"><img src="images/rhsso-images/cache-tab.png" alt="cache tab"/></span>
				</p></div><p>
				Just click the <code class="literal">clear</code> button on the cache you want to evict.
			</p></section><section class="section" id="email"><div class="titlepage"><div><div><h2 class="title">3.5. Email Settings</h2></div></div></div><p>
				Red Hat Single Sign-On sends emails to users to verify their email address, when they forget their passwords, or when an admin needs to receive notifications about a server event. To enable Red Hat Single Sign-On to send emails you need to provide Red Hat Single Sign-On with your SMTP server settings. This is configured per realm. Go to the <code class="literal">Realm Settings</code> left menu item and click the <code class="literal">Email</code> tab.
			</p><div class="formalpara"><p class="title"><strong>Email Tab</strong></p><p>
					<span class="inlinemediaobject"><img src="images/rhsso-images/email-tab.png" alt="email tab"/></span>
				</p></div><div class="variablelist"><dl class="variablelist"><dt><span class="term">Host</span></dt><dd>
							<code class="literal">Host</code> denotes the SMTP server hostname used for sending emails.
						</dd><dt><span class="term">Port</span></dt><dd>
							<code class="literal">Port</code> denotes the SMTP server port.
						</dd><dt><span class="term">From</span></dt><dd>
							<code class="literal">From</code> denotes the address used for the <code class="literal">From</code> SMTP-Header for the emails sent.
						</dd><dt><span class="term">From Display Name</span></dt><dd>
							<code class="literal">From Display Name</code> allows to configure a user friendly email address aliases (optional). If not set the plain <code class="literal">From</code> email address will be displayed in email clients.
						</dd><dt><span class="term">Reply To</span></dt><dd>
							<code class="literal">Reply To</code> denotes the address used for the <code class="literal">Reply-To</code> SMTP-Header for the mails sent (optional). If not set the plain <code class="literal">From</code> email address will be used.
						</dd><dt><span class="term">Reply To Display Name</span></dt><dd>
							<code class="literal">Reply To Display Name</code> allows to configure a user friendly email address aliases (optional). If not set the plain <code class="literal">Reply To</code> email address will be displayed.
						</dd><dt><span class="term">Envelope From</span></dt><dd>
							<code class="literal">Envelope From</code> denotes the <a class="link" href="https://en.wikipedia.org/wiki/Bounce_address">Bounce Address</a> used for the <code class="literal">Return-Path</code> SMTP-Header for the mails sent (optional).
						</dd></dl></div><p>
				As emails are used for recovering usernames and passwords it’s recommended to use SSL or TLS, especially if the SMTP server is on an external network. To enable SSL click on <code class="literal">Enable SSL</code> or to enable TLS click on <code class="literal">Enable TLS</code>. You will most likely also need to change the <code class="literal">Port</code> (the default port for SSL/TLS is 465).
			</p><p>
				If your SMTP server requires authentication click on <code class="literal">Enable Authentication</code> and insert the <code class="literal">Username</code> and <code class="literal">Password</code>. The value of the <code class="literal">Password</code> field can refer a value from an external <a class="link" href="#vault-administration" title="Chapter 17. Using Vault to Obtain Secrets">vault</a>.
			</p></section><section class="section" id="themes"><div class="titlepage"><div><div><h2 class="title">3.6. Themes and Internationalization</h2></div></div></div><p>
				Themes allow you to change the look and feel of any UI in Red Hat Single Sign-On. Themes are configured per realm. To change a theme go to the <code class="literal">Realm Settings</code> left menu item and click on the <code class="literal">Themes</code> tab.
			</p><div class="formalpara"><p class="title"><strong>Themes Tab</strong></p><p>
					<span class="inlinemediaobject"><img src="images/rhsso-images/themes-tab.png" alt="themes tab"/></span>
				</p></div><p>
				Pick the theme you want for each UI category and click <code class="literal">Save</code>.
			</p><div class="variablelist"><dl class="variablelist"><dt><span class="term">Login Theme</span></dt><dd>
							Username password entry, OTP entry, new user registration, and other similar screens related to login.
						</dd><dt><span class="term">Account Theme</span></dt><dd>
							Each user has an User Account Management UI.
						</dd><dt><span class="term">Admin Console Theme</span></dt><dd>
							The skin of the Red Hat Single Sign-On Admin Console.
						</dd><dt><span class="term">Email Theme</span></dt><dd>
							Whenever Red Hat Single Sign-On has to send out an email, it uses templates defined in this theme to craft the email.
						</dd></dl></div><p>
				The <a class="link" href="https://access.redhat.com/documentation/en-us/red_hat_single_sign-on/7.4/html-single/server_developer_guide/">Server Developer Guide</a> goes into how to create a new themes or modify existing ones.
			</p><section class="section" id="internationalization"><div class="titlepage"><div><div><h3 class="title">3.6.1. Internationalization</h3></div></div></div><p>
					Every UI screen is internationalized in Red Hat Single Sign-On. The default language is English, but if you turn on the <code class="literal">Internationalization</code> switch on the <code class="literal">Theme</code> tab you can choose which locales you want to support and what the default locale will be. The next time a user logs in, they will be able to choose a language on the login page to use for the login screens, User Account Management UI, and Admin Console. The <a class="link" href="https://access.redhat.com/documentation/en-us/red_hat_single_sign-on/7.4/html-single/server_developer_guide/">Server Developer Guide</a> explains how you can offer additional languages.
				</p><section class="section" id="user_locale_selection"><div class="titlepage"><div><div><h4 class="title">3.6.1.1. User Locale selection</h4></div></div></div><p>
						In order to select the best possible locale for a user there is a locale selector provider that handles deciding what is the best locale on the information available. One thing to note here is that it is not always known who the user is. For this reason the previously authenticated users locale is remembered in a persisted cookie.
					</p><p>
						The logic for selecting the locale uses the first of the following that is available:
					</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">
								User selected - when the user has selected a locale using the drop-down locale selector
							</li><li class="listitem">
								User profile - when there is an authenticated user and the user has a preferred locale set
							</li><li class="listitem">
								Client selected - passed by the client using for example ui_locales parameter
							</li><li class="listitem">
								Cookie - last locale selected on the browser
							</li><li class="listitem">
								Accepted language - locale from <code class="literal">Accept-Language</code> header
							</li><li class="listitem">
								Realm default
							</li><li class="listitem">
								If none of the above, fallback to English
							</li></ul></div><p>
						When a user is authenticated an action is triggered to update the locale in the persisted cookie mentioned earlier. If the user has actively switched the locale through the locale selector on the login pages the users locale is also updated at this point.
					</p></section></section></section></section><section class="chapter" id="user_management"><div class="titlepage"><div><div><h1 class="title">Chapter 4. User Management</h1></div></div></div><p>
			This section describes the administration functions for managing users.
		</p><section class="section" id="searching_for_users"><div class="titlepage"><div><div><h2 class="title">4.1. Searching For Users</h2></div></div></div><p>
				If you need to manage a specific user, click on <code class="literal">Users</code> in the left menu bar.
			</p><div class="formalpara"><p class="title"><strong>Users</strong></p><p>
					<span class="inlinemediaobject"><img src="images/rhsso-images/users.png" alt="users"/></span>
				</p></div><p>
				This menu option brings you to the user list page. In the search box you can type in a full name, last name, or email address you want to search for in the user database. The query will bring up all users that match your criteria. The <code class="literal">View all users</code> button will list every user in the system. This will search just local Red Hat Single Sign-On database and not the federated database (ie. LDAP) because some backends like LDAP don’t have a way to page through users. So if you want the users from federated backend to be synced into Red Hat Single Sign-On database you need to either:
			</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">
						Adjust search criteria. That will sync just the backend users matching the criteria into Red Hat Single Sign-On database.
					</li><li class="listitem">
						Go to <code class="literal">User Federation</code> tab and click <code class="literal">Sync all users</code> or <code class="literal">Sync changed users</code> in the page with your federation provider.
					</li></ul></div><p>
				See <a class="link" href="#user-storage-federation" title="Chapter 14. User Storage Federation">User Federation</a> for more details.
			</p></section><section class="section" id="create-new-user"><div class="titlepage"><div><div><h2 class="title">4.2. Creating New Users</h2></div></div></div><p>
				To create a user click on <code class="literal">Users</code> in the left menu bar.
			</p><div class="formalpara"><p class="title"><strong>Users</strong></p><p>
					<span class="inlinemediaobject"><img src="images/rhsso-images/users.png" alt="users"/></span>
				</p></div><p>
				This menu option brings you to the user list page. On the right side of the empty user list, you should see an <code class="literal">Add User</code> button. Click that to start creating your new user.
			</p><div class="formalpara"><p class="title"><strong>Add User</strong></p><p>
					<span class="inlinemediaobject"><img src="images/rhsso-images/add-user.png" alt="add user"/></span>
				</p></div><p>
				The only required field is <code class="literal">Username</code>. Click save. This will bring you to the management page for your new user.
			</p></section><section class="section" id="delete-user"><div class="titlepage"><div><div><h2 class="title">4.3. Deleting Users</h2></div></div></div><p>
				To delete a user click on <code class="literal">Users</code> in the left menu bar.
			</p><div class="formalpara"><p class="title"><strong>Users</strong></p><p>
					<span class="inlinemediaobject"><img src="images/rhsso-images/users.png" alt="users"/></span>
				</p></div><p>
				This menu option brings you to the user list page. Click <code class="literal">View all users</code> or search to find the user you intend to delete.
			</p><div class="formalpara"><p class="title"><strong>View All Users</strong></p><p>
					<span class="inlinemediaobject"><img src="images/rhsso-images/delete-user.png" alt="delete user"/></span>
				</p></div><p>
				In the list of users, click <code class="literal">Delete</code> next to the user you want to remove. You will be asked to confirm that you are sure you want to delete this user. Click <code class="literal">Delete</code> in the confirmation box to confirm.
			</p></section><section class="section" id="user_attributes"><div class="titlepage"><div><div><h2 class="title">4.4. User Attributes</h2></div></div></div><p>
				Beyond basic user metadata like name and email, you can store arbitrary user attributes. Choose a user to manage then click on the <code class="literal">Attributes</code> tab.
			</p><div class="formalpara"><p class="title"><strong>Users</strong></p><p>
					<span class="inlinemediaobject"><img src="images/rhsso-images/user-attributes.png" alt="user attributes"/></span>
				</p></div><p>
				Enter in the attribute name and value in the empty fields and click the <code class="literal">Add</code> button next to it to add a new field. Note that any edits you make on this page will not be stored until you hit the <code class="literal">Save</code> button.
			</p></section><section class="section" id="user-credentials"><div class="titlepage"><div><div><h2 class="title">4.5. User Credentials</h2></div></div></div><p>
				When viewing a user if you go to the <code class="literal">Credentials</code> tab you can manage a user’s credentials.
			</p><div class="formalpara"><p class="title"><strong>Credential Management</strong></p><p>
					<span class="inlinemediaobject"><img src="images/rhsso-images/user-credentials.png" alt="user credentials"/></span>
				</p></div><p>
				The credentials are listed in a table, which has the following fields:
			</p><div class="variablelist"><dl class="variablelist"><dt><span class="term">Position</span></dt><dd>
							The arrow buttons in this column allows you to shift the priority of the credential for the user, with the topmost credential having the highest priority. This priority determines which credential will be shown first to a user in case of a choice during login. The highest priority of those available to the user will be the one selected.
						</dd><dt><span class="term">Type</span></dt><dd>
							This shows the type of the credential, for example <code class="literal">password</code> or <code class="literal">otp</code>.
						</dd><dt><span class="term">User Label</span></dt><dd>
							This is an assignable label to recognise the credential when presented as a selection option during login. It can be set to any value to describe the credential.
						</dd><dt><span class="term">Data</span></dt><dd>
							This shows the non-confidential technical information about the credential. It is originally hidden, but you can press <code class="literal">Show data…​</code> to reveal it for a credential.
						</dd><dt><span class="term">Actions</span></dt><dd>
							This column has two buttons. <code class="literal">Save</code> records the value of the User Label, while <code class="literal">Delete</code> will remove the credential.
						</dd></dl></div><section class="section" id="creating_a_password_for_the_user"><div class="titlepage"><div><div><h3 class="title">4.5.1. Creating a Password for the User</h3></div></div></div><p>
					If a user doesn’t have a password, or if the password has been deleted, the <code class="literal">Set Password</code> section will be shown on the page.
				</p><div class="formalpara"><p class="title"><strong>Credential Management - Set Password</strong></p><p>
						<span class="inlinemediaobject"><img src="images/user-credentials-set-password.png" alt="user credentials set password"/></span>
					</p></div><p>
					To create a password for a user, type in a new one. Click on the <code class="literal">Set Password</code> button after you’ve typed everything in. If the <code class="literal">Temporary</code> switch is on, this new password can only be used once and the user will be asked to change their password after they have logged in.
				</p><p>
					If a user already has a password, it can be reset in the <code class="literal">Reset Password</code> section.
				</p><p>
					Alternatively, if you have <a class="link" href="#email" title="3.5. Email Settings">email</a> set up, you can send an email to the user that asks them to reset their password. Choose <code class="literal">Update Password</code> from the <code class="literal">Reset Actions</code> list box and click <code class="literal">Send Email</code>. You can optionally set the validity of the e-mail link which defaults to the one preset in <code class="literal">Tokens</code> tab in the realm settings. The sent email contains a link that will bring the user to the update password screen.
				</p><p>
					Note that a user can only have a single credential of type password.
				</p></section><section class="section" id="creating_other_credentials"><div class="titlepage"><div><div><h3 class="title">4.5.2. Creating other credentials</h3></div></div></div><p>
					You cannot configure other types of credentials for a specific user within the Admin Console. This is the responsibility of the user. You can only delete credentials for a user on the <code class="literal">Credentials</code> tab, for example if the user has lost an OTP device, or if a credential has been compromised.
				</p><section class="section" id="creating_an_otp"><div class="titlepage"><div><div><h4 class="title">4.5.2.1. Creating an OTP</h4></div></div></div><p>
						If OTP is conditional in your realm, the user will have to go to the User Account Management service to re-configure a new OTP generator. If OTP is required, then the user will be asked to re-configure a new OTP generator when they log in.
					</p><p>
						Like passwords, you can alternatively send an email to the user that will ask them to reset their OTP generator. Choose <code class="literal">Configure OTP</code> in the <code class="literal">Reset Actions</code> list box and click the <code class="literal">Send Email</code> button. The sent email contains a link that will bring the user to the OTP setup screen. You can use this method even if the user already has an OTP credential, and would like to set up some more.
					</p></section></section></section><section class="section" id="required_actions"><div class="titlepage"><div><div><h2 class="title">4.6. Required Actions</h2></div></div></div><p>
				Required Actions are tasks that a user must finish before they are allowed to log in. A user must provide their credentials before required actions are executed. Once a required action is completed, the user will not have to perform the action again. Here are explanations of some of the built-in required action types:
			</p><div class="variablelist"><dl class="variablelist"><dt><span class="term">Update Password</span></dt><dd>
							When set, a user must change their password.
						</dd><dt><span class="term">Configure OTP</span></dt><dd>
							When set, a user must configure a one-time password generator on their mobile device using either the Free OTP or Google Authenticator application.
						</dd><dt><span class="term">Verify Email</span></dt><dd>
							When set, a user must verify that they have a valid email account. An email will be sent to the user with a link they have to click. Once this workflow is successfully completed, they will be allowed to log in.
						</dd><dt><span class="term">Update Profile</span></dt><dd>
							This required action asks the user to update their profile information, i.e. their name, address, email, and/or phone number.
						</dd></dl></div><p>
				Admins can add required actions for each individual user within the user’s <code class="literal">Details</code> tab in the Admin Console.
			</p><div class="formalpara"><p class="title"><strong>Setting Required Action</strong></p><p>
					<span class="inlinemediaobject"><img src="images/rhsso-images/user-required-action.png" alt="user required action"/></span>
				</p></div><p>
				In the <code class="literal">Required User Actions</code> list box, select all the actions you want to add to the account. If you want to remove one, click the <code class="literal">X</code> next to the action name. Also remember to click the <code class="literal">Save</code> button after you’ve decided what actions to add.
			</p><section class="section" id="default_required_actions"><div class="titlepage"><div><div><h3 class="title">4.6.1. Default Required Actions</h3></div></div></div><p>
					You can also specify required actions that will be added to an account whenever a new user is created, i.e. through the <code class="literal">Add User</code> button the user list screen, or via the <a class="link" href="#user-registration" title="4.8. User Registration">user registration</a> link on the login page. To specify the default required actions go to the <code class="literal">Authentication</code> left menu item and click on the <code class="literal">Required Actions</code> tab.
				</p><div class="formalpara"><p class="title"><strong>Default Required Actions</strong></p><p>
						<span class="inlinemediaobject"><img src="images/rhsso-images/default-required-actions.png" alt="default required actions"/></span>
					</p></div><p>
					Simply click the checkbox in the <code class="literal">Default Action</code> column of the required actions that you want to be executed when a brand new user logs in.
				</p></section><section class="section" id="terms_and_conditions"><div class="titlepage"><div><div><h3 class="title">4.6.2. Terms and Conditions</h3></div></div></div><p>
					Many organizations have a requirement that when a new user logs in for the first time, they need to agree to the terms and conditions of the website. Red Hat Single Sign-On has this functionality implemented as a required action, but it requires some configuration. For one, you have to go to the <code class="literal">Required Actions</code> tab described earlier and enable the <code class="literal">Terms and Conditions</code> action. You must also edit the <span class="emphasis"><em>terms.ftl</em></span> file in the <span class="emphasis"><em>base</em></span> login theme. See the <a class="link" href="https://access.redhat.com/documentation/en-us/red_hat_single_sign-on/7.4/html-single/server_developer_guide/">Server Developer Guide</a> for more information on extending and creating themes.
				</p></section></section><section class="section" id="impersonation"><div class="titlepage"><div><div><h2 class="title">4.7. Impersonation</h2></div></div></div><p>
				It is often useful for an admin to impersonate a user. For example, a user may be experiencing a bug in one of your applications and an admin may want to impersonate the user to see if they can duplicate the problem. Admins with the appropriate permission can impersonate a user. There are two locations an admin can initiate impersonation. The first is on the <code class="literal">Users</code> list tab.
			</p><div class="formalpara"><p class="title"><strong>Users</strong></p><p>
					<span class="inlinemediaobject"><img src="images/rhsso-images/user-search.png" alt="user search"/></span>
				</p></div><p>
				You can see here that the admin has searched for <code class="literal">john</code>. Next to John’s account you can see an impersonate button. Click that to impersonate the user.
			</p><p>
				Also, you can impersonate the user from the user <code class="literal">Details</code> tab.
			</p><div class="formalpara"><p class="title"><strong>User Details</strong></p><p>
					<span class="inlinemediaobject"><img src="images/rhsso-images/user-details.png" alt="user details"/></span>
				</p></div><p>
				Near the bottom of the page you can see the <code class="literal">Impersonate</code> button. Click that to impersonate the user.
			</p><p>
				When impersonating, if the admin and the user are in the same realm, then the admin will be logged out and automatically logged in as the user being impersonated. If the admin and user are not in the same realm, the admin will remain logged in, but additionally be logged in as the user in that user’s realm. In both cases, the browser will be redirected to the impersonated user’s User Account Management page.
			</p><p>
				Any user with the realm’s <code class="literal">impersonation</code> role can impersonate a user. Please see the <a class="link" href="#admin_permissions" title="Chapter 11. Admin Console Access Control and Permissions">Admin Console Access Control</a> chapter for more details on assigning administration permissions.
			</p></section><section class="section" id="user-registration"><div class="titlepage"><div><div><h2 class="title">4.8. User Registration</h2></div></div></div><p>
				You can enable Red Hat Single Sign-On to allow user self registration. When enabled, the login page has a registration link the user can click on to create their new account.
			</p><p>
				When user self registration is enabled it is possible to use the registration form to detect valid usernames and emails. It is also possible to enable <a class="link" href="#recaptcha" title="4.8.1. reCAPTCHA Support">reCAPTCHA Support</a>.
			</p><p>
				Enabling registration is pretty simple. Go to the <code class="literal">Realm Settings</code> left menu and click it. Then go to the <code class="literal">Login</code> tab. There is a <code class="literal">User Registration</code> switch on this tab. Turn it on, then click the <code class="literal">Save</code> button.
			</p><div class="formalpara"><p class="title"><strong>Login Tab</strong></p><p>
					<span class="inlinemediaobject"><img src="images/rhsso-images/login-tab.png" alt="login tab"/></span>
				</p></div><p>
				After you enable this setting, a <code class="literal">Register</code> link should show up on the login page.
			</p><div class="formalpara"><p class="title"><strong>Registration Link</strong></p><p>
					<span class="inlinemediaobject"><img src="images/rhsso-images/registration-link.png" alt="registration link"/></span>
				</p></div><p>
				Clicking on this link will bring the user to the registration page where they have to enter in some user profile information and a new password.
			</p><div class="formalpara"><p class="title"><strong>Registration Form</strong></p><p>
					<span class="inlinemediaobject"><img src="images/rhsso-images/registration-form.png" alt="registration form"/></span>
				</p></div><p>
				You can change the look and feel of the registration form as well as removing or adding additional fields that must be entered. See the <a class="link" href="https://access.redhat.com/documentation/en-us/red_hat_single_sign-on/7.4/html-single/server_developer_guide/">Server Developer Guide</a> for more information.
			</p><section class="section" id="recaptcha"><div class="titlepage"><div><div><h3 class="title">4.8.1. reCAPTCHA Support</h3></div></div></div><p>
					To safeguard registration against bots, Red Hat Single Sign-On has integration with Google reCAPTCHA. To enable this you need to first go to <a class="link" href="https://developers.google.com/recaptcha/">Google Recaptcha Website</a> and create an API key so that you can get your reCAPTCHA site key and secret. (FYI, localhost works by default so you don’t have to specify a domain).
				</p><p>
					Next, there are a few steps you need to perform in the Red Hat Single Sign-On Admin Console. Click the <code class="literal">Authentication</code> left menu item and go to the <code class="literal">Flows</code> tab. Select the <code class="literal">Registration</code> flow from the drop down list on this page.
				</p><div class="formalpara"><p class="title"><strong>Registration Flow</strong></p><p>
						<span class="inlinemediaobject"><img src="images/rhsso-images/registration-flow.png" alt="registration flow"/></span>
					</p></div><p>
					Set the 'reCAPTCHA' requirement to <code class="literal">Required</code> by clicking the appropriate radio button. This will enable reCAPTCHA on the screen. Next, you have to enter in the reCAPTCHA site key and secret that you generated at the Google reCAPTCHA Website. Click on the 'Actions' button that is to the right of the reCAPTCHA flow entry, then "Config" link, and enter in the reCAPTCHA site key and secret on this config page.
				</p><div class="formalpara"><p class="title"><strong>Recaptcha Config Page</strong></p><p>
						<span class="inlinemediaobject"><img src="images/rhsso-images/recaptcha-config.png" alt="recaptcha config"/></span>
					</p></div><p>
					The final step you have to do is to change some default HTTP response headers that Red Hat Single Sign-On sets. Red Hat Single Sign-On will prevent a website from including any login page within an iframe. This is to prevent clickjacking attacks. You need to authorize Google to use the registration page within an iframe. Go to the <code class="literal">Realm Settings</code> left menu item and then go to the <code class="literal">Security Defenses</code> tab. You will need to add <code class="literal">https://www.google.com</code> to the values of both the <code class="literal">X-Frame-Options</code> and <code class="literal">Content-Security-Policy</code> headers.
				</p><div class="formalpara"><p class="title"><strong>Authorizing Iframes</strong></p><p>
						<span class="inlinemediaobject"><img src="images/rhsso-images/security-headers.png" alt="security headers"/></span>
					</p></div><p>
					Once you do this, reCAPTCHA should show up on your registration page. You may want to edit <span class="emphasis"><em>register.ftl</em></span> in your login theme to muck around with the placement and styling of the reCAPTCHA button. See the <a class="link" href="https://access.redhat.com/documentation/en-us/red_hat_single_sign-on/7.4/html-single/server_developer_guide/">Server Developer Guide</a> for more information on extending and creating themes.
				</p></section></section><section class="section" id="personal_data"><div class="titlepage"><div><div><h2 class="title">4.9. Personal data collected by Red Hat Single Sign-On</h2></div></div></div><p>
				By default, Red Hat Single Sign-On collects the following:
			</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">
						Basic user profile, such as email, firstname, and lastname
					</li><li class="listitem">
						Basic user profile used for social accounts and references to the social account when using a social login
					</li><li class="listitem">
						Device information collected for audit and security purposes, such as the IP address, operating system name, and browser name
					</li></ul></div><p>
				The information collected in Red Hat Single Sign-On is highly customizable. Be aware of the following guidelines when making customizations:
			</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">
						Registration and account forms could contain custom fields, such as birthday, gender, and nationality. An administrator could configure Red Hat Single Sign-On to retrieve that data from a social provider or a user storage provider such as LDAP.
					</li><li class="listitem">
						Red Hat Single Sign-On collects user credentials, such as password, OTP codes, and WebAuthn public keys. This information is encrypted and saved in a database, so it is not visible to Red Hat Single Sign-On administrators. However, each type of credential can include non-confidential metadata that is visible to administrators such as the algorithm that is used to hash the password and the number of hash iterations used to hash the password.
					</li><li class="listitem">
						With authorization services and UMA support enabled, Red Hat Single Sign-On can hold information about some objects for which a particular user is the owner. For example, Red Hat Single Sign-On can track that the user <span class="strong strong"><strong>john</strong></span> is the owner of a photoalbum <span class="strong strong"><strong>album with animals</strong></span> and a few photos called <span class="strong strong"><strong>lion picture</strong></span> and <span class="strong strong"><strong>cow picture</strong></span> in this album.
					</li></ul></div></section></section><section class="chapter" id="login_page_settings"><div class="titlepage"><div><div><h1 class="title">Chapter 5. Login Page Settings</h1></div></div></div><p>
			There are several nice built-in login page features you can enable if you need the functionality.
		</p><section class="section" id="forgot_password"><div class="titlepage"><div><div><h2 class="title">5.1. Forgot Password</h2></div></div></div><p>
				If you enable it, users are able to reset their credentials if they forget their password or lose their OTP generator. Go to the <code class="literal">Realm Settings</code> left menu item, and click on the <code class="literal">Login</code> tab. Switch on the <code class="literal">Forgot Password</code> switch.
			</p><div class="formalpara"><p class="title"><strong>Login Tab</strong></p><p>
					<span class="inlinemediaobject"><img src="images/rhsso-images/login-tab.png" alt="login tab"/></span>
				</p></div><p>
				A <code class="literal">forgot password</code> link will now show up on your login pages.
			</p><div class="formalpara"><p class="title"><strong>Forgot Password Link</strong></p><p>
					<span class="inlinemediaobject"><img src="images/rhsso-images/forgot-password-link.png" alt="forgot password link"/></span>
				</p></div><p>
				Clicking on this link will bring the user to a page where they can enter in their username or email and receive an email with a link to reset their credentials.
			</p><div class="formalpara"><p class="title"><strong>Forgot Password Page</strong></p><p>
					<span class="inlinemediaobject"><img src="images/rhsso-images/forgot-password-page.png" alt="forgot password page"/></span>
				</p></div><p>
				The text sent in the email is completely configurable. You just need to extend or edit the theme associated with it. See the <a class="link" href="https://access.redhat.com/documentation/en-us/red_hat_single_sign-on/7.4/html-single/server_developer_guide/">Server Developer Guide</a> for more information.
			</p><p>
				When the user clicks on the email link, they will be asked to update their password, and, if they have an OTP generator set up, they will also be asked to reconfigure this as well. Depending on the security requirements of your organization you may not want users to be able to reset their OTP generator through email. You can change this behavior by going to the <code class="literal">Authentication</code> left menu item, clicking on the <code class="literal">Flows</code> tab, and selecting the <code class="literal">Reset Credentials</code> flow:
			</p><div class="formalpara"><p class="title"><strong>Reset Credentials Flow</strong></p><p>
					<span class="inlinemediaobject"><img src="images/rhsso-images/reset-credentials-flow.png" alt="reset credentials flow"/></span>
				</p></div><p>
				If you do not want OTP reset, then just chose the <code class="literal">disabled</code> radio button to the right of <code class="literal">Reset OTP</code>.
			</p><div class="admonition note"><div class="admonition_header">Note</div><div><p>
					Be sure to leave Update Password enabled on the Required Actions tab. Otherwise, Forgot Password does not work.
				</p></div></div></section><section class="section" id="remember_me"><div class="titlepage"><div><div><h2 class="title">5.2. Remember Me</h2></div></div></div><p>
				If a logged in user closes their browser, their session is destroyed and they will have to log in again. You can set things up so that if a user checks a <span class="emphasis"><em>remember me</em></span> checkbox, they will remain logged in even if the browser is closed. This basically turns the login cookie from a session-only cookie to a persistence cookie.
			</p><p>
				To enable this feature go to <code class="literal">Realm Settings</code> left menu item and click on the <code class="literal">Login</code> tab and turn on the <code class="literal">Remember Me</code> switch:
			</p><div class="formalpara"><p class="title"><strong>Login Tab</strong></p><p>
					<span class="inlinemediaobject"><img src="images/rhsso-images/login-tab.png" alt="login tab"/></span>
				</p></div><p>
				Once you save this setting, a <code class="literal">remember me</code> checkbox will be displayed on the realm’s login page.
			</p><div class="formalpara"><p class="title"><strong>Remember Me</strong></p><p>
					<span class="inlinemediaobject"><img src="images/rhsso-images/remember-me.png" alt="remember me"/></span>
				</p></div></section></section><section class="chapter" id="authentication"><div class="titlepage"><div><div><h1 class="title">Chapter 6. Authentication</h1></div></div></div><p>
			There are a few features you should be aware of when configuring authentication for your realm. Many organizations have strict password and OTP policies that you can enforce via settings in the Admin Console. You may or may not want to require different credential types for authentication. You may want to give users the option to login via Kerberos or disable or enable various built-in credential types. This chapter covers all of these topics.
		</p><section class="section" id="password-policies"><div class="titlepage"><div><div><h2 class="title">6.1. Password Policies</h2></div></div></div><p>
				Each new realm created has no password policies associated with it. Users can have as short, as long, as complex, as insecure a password, as they want. Simple settings are fine for development or learning Red Hat Single Sign-On, but unacceptable in production environments. Red Hat Single Sign-On has a rich set of password policies you can enable through the Admin Console.
			</p><p>
				Click on the <code class="literal">Authentication</code> left menu item and go to the <code class="literal">Password Policy</code> tab. Choose the policy you want to add in the right side drop down list box. This will add the policy in the table on the screen. Choose the parameters for the policy. Hit the <code class="literal">Save</code> button to store your changes.
			</p><div class="formalpara"><p class="title"><strong>Password Policy</strong></p><p>
					<span class="inlinemediaobject"><img src="images/rhsso-images/password-policy.png" alt="password policy"/></span>
				</p></div><p>
				After saving your policy, user registration and the Update Password required action will enforce your new policy. An example of a user failing the policy check:
			</p><div class="formalpara"><p class="title"><strong>Failed Password Policy</strong></p><p>
					<span class="inlinemediaobject"><img src="images/rhsso-images/failed-password-policy.png" alt="failed password policy"/></span>
				</p></div><p>
				If the password policy is updated, an Update Password action must be set for every user. An automatic trigger is scheduled as a future enhancement.
			</p><section class="section" id="password_policy_types"><div class="titlepage"><div><div><h3 class="title">6.1.1. Password Policy Types</h3></div></div></div><p>
					Here’s an explanation of each policy type:
				</p><div class="variablelist"><dl class="variablelist"><dt><span class="term">Hashing Algorithm</span></dt><dd>
								Passwords are not stored as clear text. Instead they are hashed using standard hashing algorithms before they are stored or validated. Supported values are pbkdf2, pbkdf2-sha256 and pbkdf2-sha512.
							</dd><dt><span class="term">Hashing Iterations</span></dt><dd>
								This value specifies the number of times a password will be hashed before it is stored or verified. The default value is 27,500. This hashing is done in the rare case that a hacker gets access to your password database. Once they have access to the database, they can reverse engineer user passwords. The industry recommended value for this parameter changes every year as CPU power improves. A higher hashing iteration value takes more CPU power for hashing, and can impact performance. You’ll have to weigh what is more important to you: performance or protecting your passwords stores. There may be more cost effective ways of protecting your password stores.
							</dd><dt><span class="term">Digits</span></dt><dd>
								The number of digits required to be in the password string.
							</dd><dt><span class="term">Lowercase Characters</span></dt><dd>
								The number of lower case letters required to be in the password string.
							</dd><dt><span class="term">Uppercase Characters</span></dt><dd>
								The number of upper case letters required to be in the password string.
							</dd><dt><span class="term">Special Characters</span></dt><dd>
								The number of special characters like '?!#%$' required to be in the password string.
							</dd><dt><span class="term">Not Username</span></dt><dd>
								When set, the password is not allowed to be the same as the username.
							</dd><dt><span class="term">Regular Expression</span></dt><dd>
								Define one or more regular expression patterns (defined in <code class="literal">java.util.regex.Pattern</code>) that passwords must match.
							</dd><dt><span class="term">Expire Password</span></dt><dd>
								The number of days for which the password is valid. After the number of days has expired, the user is required to change their password.
							</dd><dt><span class="term">Not Recently Used</span></dt><dd>
								This policy saves a history of previous passwords. The number of old passwords stored is configurable. When a user changes their password they cannot use any stored passwords.
							</dd><dt><span class="term">Password Blacklist</span></dt><dd>
								This policy checks if a given password (converted to lowercase) is contained in a blacklist file, which is potentially a very large file. Password blacklists are UTF-8 plain-text files with Unix line endings where every line represents a blacklisted password. All passwords in the blacklist must be lowercased to facilitate case-insensitive comparison. The file name of the blacklist file must be provided as the password policy value, e.g. <code class="literal">10_million_password_list_top_1000000.txt</code>. Blacklist files are resolved against <code class="literal">${jboss.server.data.dir}/password-blacklists/</code> by default. This path can be customized via the <code class="literal">keycloak.password.blacklists.path</code> system property, or the <code class="literal">blacklistsPath</code> property of the <code class="literal">passwordBlacklist</code> policy SPI configuration.
							</dd></dl></div></section></section><section class="section" id="otp_policies"><div class="titlepage"><div><div><h2 class="title">6.2. OTP Policies</h2></div></div></div><p>
				Red Hat Single Sign-On has a number of policies you can set up for your FreeOTP or Google Authenticator One-Time Password generator. Click on the <code class="literal">Authentication</code> left menu item and go to the <code class="literal">OTP Policy</code> tab.
			</p><div class="formalpara"><p class="title"><strong>OTP Policy</strong></p><p>
					<span class="inlinemediaobject"><img src="images/rhsso-images/otp-policy.png" alt="otp policy"/></span>
				</p></div><p>
				Any policies you set here will be used to validate one-time passwords. When configuring OTP, FreeOTP and Google Authenticator can scan a QR code that is generated on the OTP set up page that Red Hat Single Sign-On has. The bar code is also generated from information configured on the <code class="literal">OTP Policy</code> tab.
			</p><section class="section" id="totp_vs_hotp"><div class="titlepage"><div><div><h3 class="title">6.2.1. TOTP vs. HOTP</h3></div></div></div><p>
					There are two different algorithms to choose from for your OTP generators. Time Based (TOTP) and Counter Based (HOTP). For TOTP, your token generator will hash the current time and a shared secret. The server validates the OTP by comparing all the hashes within a certain window of time to the submitted value. So, TOTPs are valid only for a short window of time (usually 30 seconds). For HOTP a shared counter is used instead of the current time. The server increments the counter with each successful OTP login. So, valid OTPs only change after a successful login.
				</p><p>
					TOTP is considered a little more secure because the matchable OTP is only valid for a short window of time while the OTP for HOTP can be valid for an indeterminate amount of time. HOTP is much more user friendly as the user won’t have to hurry to enter in their OTP before the time interval is up. With the way Red Hat Single Sign-On has implemented TOTP this distinction becomes a little more blurry. HOTP requires a database update every time the server wants to increment the counter. This can be a performance drain on the authentication server when there is heavy load. So, to provide a more efficient alternative, TOTP does not remember passwords used. This bypasses the need to do any DB updates, but the downside is that TOTPs can be re-used in the valid time interval. For future versions of Red Hat Single Sign-On it is planned that you will be able to configure whether TOTP checks older OTPs in the time interval.
				</p></section><section class="section" id="totp_configuration_options"><div class="titlepage"><div><div><h3 class="title">6.2.2. TOTP Configuration Options</h3></div></div></div><div class="variablelist"><dl class="variablelist"><dt><span class="term">OTP Hash Algorithm</span></dt><dd>
								Default is SHA1, more secure options are SHA256 and SHA512.
							</dd><dt><span class="term">Number of Digits</span></dt><dd>
								How many characters is the OTP? Short means more user friendly as it is less the user has to type. More means more security.
							</dd><dt><span class="term">Look Ahead Window</span></dt><dd>
								How many intervals ahead should the server try and match the hash? This exists so just in case the clock of the TOTP generator or authentication server get out of sync. The default value of 1 is usually good enough. For example, if the time interval for a new token is every 30 seconds, the default value of 1 means that it will only accept valid tokens in that 30 second window. Each increment of this config value will increase the valid window by 30 seconds.
							</dd><dt><span class="term">OTP Token Period</span></dt><dd>
								Time interval in seconds during which the server will match a hash. Each time the interval passes, a new TOTP will be generated by the token generator.
							</dd></dl></div></section><section class="section" id="hotp_configuration_options"><div class="titlepage"><div><div><h3 class="title">6.2.3. HOTP Configuration Options</h3></div></div></div><div class="variablelist"><dl class="variablelist"><dt><span class="term">OTP Hash Algorithm</span></dt><dd>
								Default is SHA1, more secure options are SHA256 and SHA512.
							</dd><dt><span class="term">Number of Digits</span></dt><dd>
								How many characters is the OTP? Short means more user friendly as it is less the user has to type. More means more security.
							</dd><dt><span class="term">Look Ahead Window</span></dt><dd>
								How many counters ahead should the server try and match the hash? The default value is 1. This exists to cover the case where the user’s counter gets ahead of the server’s. This can often happen as users often increment the counter manually too many times by accident. This value really should be increased to a value of 10 or so.
							</dd><dt><span class="term">Initial Counter</span></dt><dd>
								What is the value of the initial counter?
							</dd></dl></div></section></section><section class="section" id="authentication-flows"><div class="titlepage"><div><div><h2 class="title">6.3. Authentication Flows</h2></div></div></div><p>
				An <span class="emphasis"><em>authentication flow</em></span> is a container for all authentications, screens, and actions that must happen during login, registration, and other Red Hat Single Sign-On workflows. If you go to the admin console <code class="literal">Authentication</code> left menu item and go to the <code class="literal">Flows</code> tab, you can view all the defined flows in the system and what actions and checks each flow requires.
			</p><section class="section" id="built_in_flows"><div class="titlepage"><div><div><h3 class="title">6.3.1. Built-in flows</h3></div></div></div><p>
					Red Hat Single Sign-On comes with a certain number of built-in flows. These flows cannot be modified, but the requirements can be modified to suit your needs.
				</p><p>
					This section does a walk-through of the built-in browser login flow. In the left drop-down list select <code class="literal">browser</code> to come to the screen shown below:
				</p><div class="formalpara"><p class="title"><strong>Browser Flow</strong></p><p>
						<span class="inlinemediaobject"><img src="images/rhsso-images/browser-flow.png" alt="browser flow"/></span>
					</p></div><p>
					If you hover over the tooltip (the tiny question mark) to the right of the flow selection list, this will describe what the flow is and does.
				</p><p>
					The <code class="literal">Auth Type</code> column is the name of authentication or action that will be executed. If an authentication is indented this means it is in a sub-flow and may or may not be executed depending on the behavior of its parent. The <code class="literal">Requirement</code> column is a set of radio buttons which define whether or not the action will execute. Let’s describe what each radio button means in this context.
				</p><section class="section" id="execution-requirements"><div class="titlepage"><div><div><h4 class="title">6.3.1.1. Execution requirements</h4></div></div></div><div class="variablelist"><dl class="variablelist"><dt><span class="term">Required</span></dt><dd>
									For a flow to be evaluated as successful, all required elements in the flow must evaluate as successful. This means that all <span class="emphasis"><em>Required</em></span> elements in the flow must be sequentially executed, from top to bottom, unless one of the elements causes the flow to fail. However, this is only true for the current flow. Any <span class="emphasis"><em>Required</em></span> element within a sub-flow is only processed if that sub-flow is entered.
								</dd><dt><span class="term">Alternative</span></dt><dd>
									When a flow contains only <span class="emphasis"><em>Alternative</em></span> elements, only a single element must evaluate as successful for the flow to evaluate as successful. Because the <span class="emphasis"><em>Required</em></span> flow elements within a flow are sufficient to mark a flow as successful, any <span class="emphasis"><em>Alternative</em></span> flow element within a flow that contains <span class="emphasis"><em>Required</em></span> flow elements will never be executed. In this case, they are functionally <span class="emphasis"><em>Disabled</em></span>.
								</dd><dt><span class="term">Disabled</span></dt><dd>
									Any <span class="emphasis"><em>Disabled</em></span> element is not evaluated and does not count to mark a flow as successful.
								</dd><dt><span class="term">Conditional</span></dt><dd>
									This requirement type can only be set on sub-flows. A <span class="emphasis"><em>Conditional</em></span> sub-flow can contain a "Condition" execution. These "Condition" executions must evaluate as logical statements. If all "Condition" executions evaluate as <span class="emphasis"><em>true</em></span> then the <span class="emphasis"><em>Conditional</em></span> sub-flow acts as <span class="emphasis"><em>Required</em></span>. If not, the <span class="emphasis"><em>Conditional</em></span> sub-flow acts as <span class="emphasis"><em>Disabled</em></span>. If no "Condition" execution is set, the <span class="emphasis"><em>Conditional</em></span> sub-flow acts as <span class="emphasis"><em>Disabled</em></span>. If a flow contains "Condition" executions and is not set to <span class="emphasis"><em>Conditional</em></span>, the "Condition" executions are not evaluated, and can be considered functionally <span class="emphasis"><em>Disabled</em></span>.
								</dd></dl></div><p>
						This is better described in an example. Let’s walk through the <code class="literal">browser</code> authentication flow.
					</p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem">
								The first authentication type is <code class="literal">Cookie</code>. When a user successfully logs in for the first time, a session cookie is set. If this cookie has already been set, then this authentication type is successful. In this case, since the cookie provider returned success and each execution at this level of the flow is <span class="emphasis"><em>alternative</em></span>, no other execution is executed and this results in a successful login.
							</li><li class="listitem">
								The second execution of the flow looks at the <code class="literal">Kerberos</code> execution. This authenticator is disabled by default and will be skipped.
							</li><li class="listitem">
								The third execution is the <code class="literal">Identity Provider Redirector</code>. It can be configured through the <code class="literal">Actions</code> &gt; <code class="literal">Config</code> link to automatically redirect to another IdP for <a class="link" href="#identity_broker" title="Chapter 12. Identity Brokering">identity brokering</a>.
							</li><li class="listitem">
								The next execution is a sub-flow called <code class="literal">Forms</code>. Since this sub-flow is marked as <span class="emphasis"><em>alternative</em></span> it will not be executed if the <code class="literal">Cookie</code> authentication type passed. This sub-flow contains additional authentication type that needs to be executed. The executions for this sub-flow are loaded and the same processing logic occurs.
							</li><li class="listitem">
								The first execution in the Forms sub-flow is the <code class="literal">Username Password Form</code>. This authentication type renders the username and password page. It is marked as <span class="emphasis"><em>required</em></span> so the user must enter in a valid username and password.
							</li><li class="listitem">
								The second execution in the Forms sub-flow is a new sub-flow: the <code class="literal">Browser - Conditional OTP</code> sub-flow. Since this sub-flow is <span class="emphasis"><em>conditional</em></span>, whether it is executed depends on the result of the evaluation of the <code class="literal">Condition - User Configured</code> execution. If it is, the executions for this sub-flow are loaded and the same processing logic occurs
							</li><li class="listitem">
								The next execution is the <code class="literal">Condition - User Configured</code>. This checks if the other executions in the flow are configured for the user. Meaning that the <code class="literal">Browser - Conditional OTP</code> sub-flow will only be executed if the user has an OTP credential configured.
							</li><li class="listitem">
								The final execution is the <code class="literal">OTP Form</code>. This is marked as <span class="emphasis"><em>required</em></span>, but because of the setup in the <span class="emphasis"><em>conditional</em></span> subflow, it will only be run if the user has an OTP credential set up. If he doesn’t, the user will not see an OTP form.
							</li></ol></div></section></section><section class="section" id="creating_flows"><div class="titlepage"><div><div><h3 class="title">6.3.2. Creating flows</h3></div></div></div><p>
					This section explains in greater depth how flows work, and how to create your own flows. Note that there are important functionality and security considerations when designing your own flow. A badly created flow could either let no one log in, let users in with less verification than you would like, or simply result in an error.
				</p><p>
					To create a flow, you can either:
				</p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem">
							Copy and then modify an existing flow. To do this select an existing flow (for example the <code class="literal">Browser</code> flow), and press the <code class="literal">Copy</code> button. This will then ask you to set a name for the new flow, before creating it.
						</li><li class="listitem">
							Create a new flow from scratch. To do this press the <code class="literal">New</code> button. Since this is the more general case, we will use this for our example.
						</li></ol></div><p>
					When creating a new flow, you will have to create a top level flow
				</p><div class="formalpara"><p class="title"><strong>Create a top level flow</strong></p><p>
						<span class="inlinemediaobject"><img src="images/rhsso-images/Create-top-level-flow.png" alt="Create top level flow"/></span>
					</p></div><p>
					With the following options:
				</p><div class="variablelist"><dl class="variablelist"><dt><span class="term">Alias</span></dt><dd>
								The name of the flow.
							</dd><dt><span class="term">Description</span></dt><dd>
								The description you can set to the flow.
							</dd><dt><span class="term">Top Level Flow Type</span></dt><dd>
								The type of flow. The type <code class="literal">client</code> is used only for the authentication of clients (applications). For all other cases choose <code class="literal">generic</code>.
							</dd></dl></div><p>
					Once the flow is created, in addition to the <code class="literal">New</code> and <code class="literal">Copy</code> buttons, you now have, <code class="literal">Delete</code>, <code class="literal">Add execution</code> and <code class="literal">Add flow</code>.
				</p><div class="formalpara"><p class="title"><strong>An empty new flow</strong></p><p>
						<span class="inlinemediaobject"><img src="images/rhsso-images/New-flow.png" alt="New flow"/></span>
					</p></div><p>
					What a flow finally does is determined by the structure of the flow and sub-flows, the executions in those flows, and the requirements set on the sub-flows and the executions.
				</p><p>
					Executions can be added with the <code class="literal">Add execution</code> button. Executions can have a wide variety of actions, from sending a reset email to validating an OTP. If you hover over the tooltip (the tiny question mark) next to <code class="literal">Provider</code>, this will describe what the execution does.
				</p><div class="formalpara"><p class="title"><strong>Adding an authentication execution</strong></p><p>
						<span class="inlinemediaobject"><img src="images/rhsso-images/Create-authentication-execution.png" alt="Create authentication execution"/></span>
					</p></div><p>
					These can be divided into <span class="emphasis"><em>automatic executions</em></span> and <span class="emphasis"><em>interactive executions</em></span>. <span class="emphasis"><em>Automatic executions</em></span> are similar to the <code class="literal">Cookie</code> execution, and will automatically perform their action when they are encountered in the flow. <span class="emphasis"><em>Interactive executions</em></span> will halt the flow, usually to get some user input. Executions that execute successfully will get the <span class="emphasis"><em>success</em></span> status. This is important, because this is part of whether a flow is successful or not. For example, an empty <code class="literal">Browser</code> flow would not allow anyone to log in. For that it would need at least one execution that successfully evaluates, for example a <code class="literal">Username Password Form</code> that is correctly filled and submitted.
				</p><p>
					Sub-flows can be added in top level flow with the <code class="literal">Add flow</code> button, which opens a <code class="literal">Create Execution Flow</code> page that is very similar to the <code class="literal">Create Top Level Form</code> page. The only difference is that the <code class="literal">Flow Type</code> can be either <code class="literal">generic</code> (like before), or <code class="literal">form</code>. The <code class="literal">form</code> type is used to construct a sub-flow that generates a single form for the user, like what is done for the built-in <code class="literal">Registration</code> flow. Sub-flows are a special type of execution that evaluate as successful depending on how the executions they contain evaluate (and this includes the evaluation of their contained sub-flows). And the logic of this evaluation depends on the Requirement of each execution and sub-flow.
				</p><p>
					Fully understanding this requires a more complete explanation of how requirements work when evaluating a flow, and this also applies to sub-flows. Refer to the <a class="link" href="#execution-requirements" title="6.3.1.1. Execution requirements">execution requirements section</a> above for more details.
				</p><p>
					Note that after adding an execution, you should check that the Requirement is set to the correct value. Even if there is only a single possible Requirement, it can happen that it is not set.
				</p><p>
					When constructing a flow, all elements added to the flow will have an <code class="literal">Actions</code> menu on the right-hand side. All elements added to the flow have a <code class="literal">Delete</code> option in this menu to remove it from the flow. Executions can contain a <code class="literal">Config</code> menu option to configure the execution, as is the case for the <code class="literal">Identity Provider Redirector</code>. Sub-flows can also have executions and sub-flows added to them, with their <code class="literal">Add execution</code> and <code class="literal">Add flow</code> menu options.
				</p><p>
					Finally, since the order of execution is important, you can move executions and sub-flows up and down within their respective flows with the up and down buttons that are set to left of their name.
				</p></section><section class="section" id="creating_a_password_less_browser_login_flow"><div class="titlepage"><div><div><h3 class="title">6.3.3. Creating a password-less browser login flow</h3></div></div></div><p>
					To illustrate the creation of flows, this section describes the creation of a more advanced browser login flow. The purpose of this flow is to allow a user to choose between logging in in a password-less manner using <a class="link" href="#webauthn" title="6.6. W3C Web Authentication (WebAuthn)">WebAuthn</a>, and a two-factor authentication with password and OTP. The flow to create is similar to the standard browser login, but diverges when reaching the username selection. Instead of copying the flow however, you’ll be creating the flow from the start:
				</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">
							Select a realm, click on Authentication link
						</li><li class="listitem">
							Select "new", and give the new flow a distinctive Alias, i.e. "Browser Password-less"
						</li><li class="listitem">
							Select "Add execution", and using the drop-down select "Cookie". After pressing "Save", set its Requirement to <span class="emphasis"><em>Alternative</em></span>.
						</li><li class="listitem">
							Select "Add execution", and using the drop-down select "Kerberos".
						</li><li class="listitem">
							Select "Add execution", and using the drop-down select "Identity Provider Redirector". After pressing "Save", set its Requirement to <span class="emphasis"><em>Alternative</em></span>.
						</li><li class="listitem">
							Select "Add flow", and choose an representative Alias, e.g. "Forms". After pressing "Save", set its Requirement to <span class="emphasis"><em>Alternative</em></span>.
						</li></ul></div><div class="formalpara"><p class="title"><strong>The common part with the browser flow</strong></p><p>
						<span class="inlinemediaobject"><img src="images/Passwordless-browser-login-common.png" alt="Passwordless browser login common"/></span>
					</p></div><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">
							Using the <code class="literal">Actions</code> menu on the right-hand side of the "Forms" subflow, select "Add execution". Using the drop-down select "Username Form". After pressing "Save", set its Requirement to <span class="emphasis"><em>Required</em></span>.
						</li></ul></div><p>
					The Username form is similar to "Browser" flow’s Username Password Form, but only asks for a username, allowing a user to perform a password-less login. However, note that this inevitably allows a user enumeration attack on your Red Hat Single Sign-On server. This is an unavoidable security risk for the convenience, so the flow should make sure that an attacker cannot just have to guess a password to be able to enter.
				</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">
							Using the <code class="literal">Actions</code> menu on the right-hand side of the "Forms" subflow, select "Add flow". Choose an representative Alias, e.g. "Authentication". After pressing "Save", set its Requirement to <span class="emphasis"><em>Required</em></span>.
						</li><li class="listitem">
							Using the <code class="literal">Actions</code> menu on the right-hand side of the "Authentication" subflow, select "Add execution". Using the drop-down select "Webauthn Passwordless Authenticator". After pressing "Save", set its Requirement to <span class="emphasis"><em>Alternative</em></span>.
						</li><li class="listitem">
							Using the <code class="literal">Actions</code> menu on the right-hand side of the "Authentication" subflow, select "Add flow". Choose an representative Alias, e.g. "Password with OTP". After pressing "Save", set its Requirement to <span class="emphasis"><em>Alternative</em></span>.
						</li><li class="listitem">
							Using the <code class="literal">Actions</code> menu on the right-hand side of the "Password with OTP" subflow, select "Add execution". Using the drop-down select "Password Form". After pressing "Save", set its Requirement to Required.
						</li><li class="listitem">
							Using the <code class="literal">Actions</code> menu on the right-hand side of the "Password with OTP" subflow, select "Add execution". Using the drop-down select "OTP Form". After pressing "Save", set its Requirement to Required.
						</li><li class="listitem">
							In the "Bindings" menu, change the browser flow from "Browser" to "Browser Password-less"
						</li></ul></div><p>
					The final flow that is produced is the following:
				</p><div class="formalpara"><p class="title"><strong>A password-less browser login</strong></p><p>
						<span class="inlinemediaobject"><img src="images/Passwordless-browser-login.png" alt="Passwordless browser login"/></span>
					</p></div><p>
					After entering the username, the way this flow works is the following:
				</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">
							If the user has any WebAuthn passwordless credentials recorded, that user will be able to use any of them to log in directly. This is the password-less login. The user can instead select "Password with OTP". The user can do this because the "WebAuthn Passwordless" execution and the "Password with OTP" flow are set to <span class="emphasis"><em>Alternative</em></span>. Were they set to <span class="emphasis"><em>Required</em></span> the user would have to enter WebAuthn, password, and OTP.
						</li><li class="listitem">
							If the user selects <code class="literal">Try another way</code> link on the screen with "WebAuthn passwordless" authentication, the user can choose between "Password" and "Security Key" (WebAuthn passwordless). When selecting the password, the user will need to continue and log in with the assigned OTP as well. If the user has no WebAuthn credentials, he will have to first enter his password, and then his OTP. If the user has no OTP credential, he will be asked to record one.
						</li></ul></div><p>
					It is important to note that since the WebAuthn Passwordless execution is set to <span class="emphasis"><em>Alternative</em></span> instead of <span class="emphasis"><em>Required</em></span>, this flow will never ask the user to register a WebAuthn credential. For a user to have a Webauthn credential, that user must have a required action added by an administrator. This is done first by making sure that the <code class="literal">Webauthn Register Passwordless</code> required action is enabled in the realm (see the <a class="link" href="#webauthn" title="6.6. W3C Web Authentication (WebAuthn)">WebAuthn</a> documentation), and then by setting the required action by using the <code class="literal">Credential Reset</code> part of a user’s <a class="link" href="#user-credentials" title="4.5. User Credentials">Credentials</a> management menu.
				</p><p>
					Creating a more advanced flow such as this one can have some subtle side effects. For example, if you were to enable the ability to reset the password for the user, then this would be accessible from the password form. In the default "Reset Credentials" flow, the user has to enter his username. Since he’s already entered his username earlier in the "Browser Password-less" flow, this would be unnecessary for Red Hat Single Sign-On, and a sub-optimal in terms of user experience. To correct this, you could:
				</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">
							Copy the "Reset Credentials" flow, setting its name to, for example "Reset Credentials for password-less"
						</li><li class="listitem">
							Use the <code class="literal">Actions</code> menu on the right-hand side of the "Choose user" execution, select "Delete"
						</li><li class="listitem">
							In the "Bindings" menu, change the reset credential flow from "Reset Credentials" to "Reset Credentials for password-less"
						</li></ul></div></section></section><section class="section" id="kerberos"><div class="titlepage"><div><div><h2 class="title">6.4. Kerberos</h2></div></div></div><p>
				Red Hat Single Sign-On supports login with a Kerberos ticket through the SPNEGO protocol. SPNEGO (Simple and Protected GSSAPI Negotiation Mechanism) is used to authenticate transparently through the web browser after the user has been authenticated when logging-in his session. For non-web cases or when ticket is not available during login, Red Hat Single Sign-On also supports login with Kerberos username/password.
			</p><p>
				A typical use case for web authentication is the following:
			</p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem">
						User logs into his desktop (Such as a Windows machine in Active Directory domain or Linux machine with Kerberos integration enabled).
					</li><li class="listitem">
						User then uses his browser (IE/Firefox/Chrome) to access a web application secured by Red Hat Single Sign-On.
					</li><li class="listitem">
						Application redirects to Red Hat Single Sign-On login.
					</li><li class="listitem">
						Red Hat Single Sign-On renders HTML login screen together with status 401 and HTTP header <code class="literal">WWW-Authenticate: Negotiate</code>
					</li><li class="listitem">
						In case that the browser has Kerberos ticket from desktop login, it transfers the desktop sign on information to the Red Hat Single Sign-On in header <code class="literal">Authorization: Negotiate 'spnego-token'</code> . Otherwise it just displays the login screen.
					</li><li class="listitem">
						Red Hat Single Sign-On validates token from the browser and authenticates the user. It provisions user data from LDAP (in case of LDAPFederationProvider with Kerberos authentication support) or let user to update his profile and prefill data (in case of KerberosFederationProvider).
					</li><li class="listitem">
						Red Hat Single Sign-On returns back to the application. Communication between Red Hat Single Sign-On and application happens through OpenID Connect or SAML messages. The fact that Red Hat Single Sign-On was authenticated through Kerberos is hidden from the application. So Red Hat Single Sign-On acts as broker to Kerberos/SPNEGO login.
					</li></ol></div><p>
				For setup there are 3 main parts:
			</p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem">
						Setup and configuration of Kerberos server (KDC)
					</li><li class="listitem">
						Setup and configuration of Red Hat Single Sign-On server
					</li><li class="listitem">
						Setup and configuration of client machines
					</li></ol></div><section class="section" id="setup_of_kerberos_server"><div class="titlepage"><div><div><h3 class="title">6.4.1. Setup of Kerberos server</h3></div></div></div><p>
					This is platform dependent. Exact steps depend on your OS and the Kerberos vendor you’re going to use. Consult Windows Active Directory, MIT Kerberos and your OS documentation for how exactly to setup and configure Kerberos server.
				</p><p>
					At least you will need to:
				</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">
							Add some user principals to your Kerberos database. You can also integrate your Kerberos with LDAP, which means that user accounts will be provisioned from LDAP server.
						</li><li class="listitem"><p class="simpara">
							Add service principal for "HTTP" service. For example if your Red Hat Single Sign-On server will be running on <code class="literal">www.mydomain.org</code> you may need to add principal <code class="literal">HTTP/www.mydomain.org@MYDOMAIN.ORG</code> assuming that MYDOMAIN.ORG will be your Kerberos realm.
						</p><p class="simpara">
							For example on MIT Kerberos you can run a "kadmin" session. If you are on the same machine where is MIT Kerberos, you can simply use the command:
						</p></li></ul></div><pre class="screen">sudo kadmin.local</pre><p>
					Then add HTTP principal and export his key to a keytab file with the commands like:
				</p><pre class="screen">addprinc -randkey HTTP/www.mydomain.org@MYDOMAIN.ORG
ktadd -k /tmp/http.keytab HTTP/www.mydomain.org@MYDOMAIN.ORG</pre><p>
					The Keytab file <code class="literal">/tmp/http.keytab</code> will need to be accessible on the host where Red Hat Single Sign-On server will be running.
				</p></section><section class="section" id="setup_and_configuration_of_red_hat_single_sign_on_server"><div class="titlepage"><div><div><h3 class="title">6.4.2. Setup and configuration of Red Hat Single Sign-On server</h3></div></div></div><p>
					You need to install a kerberos client on your machine. This is also platform dependent. If you are on Fedora, Ubuntu or RHEL, you can install the package <code class="literal">freeipa-client</code>, which contains a Kerberos client and several other utilities. Configure the kerberos client (on Linux it’s in file <code class="literal">/etc/krb5.conf</code> ). You need to put your Kerberos realm and at least configure the HTTP domains your server will be running on. For the example realm MYDOMAIN.ORG you may configure the <code class="literal">domain_realm</code> section like this:
				</p><pre class="screen">[domain_realm]
  .mydomain.org = MYDOMAIN.ORG
  mydomain.org = MYDOMAIN.ORG</pre><p>
					Next you need to export the keytab file with the HTTP principal and make sure the file is accessible to the process under which Red Hat Single Sign-On server is running. For production, it’s ideal if it’s readable just by this process and not by someone else. For the MIT Kerberos example above, we already exported keytab to <code class="literal">/tmp/http.keytab</code> . If your KDC and Red Hat Single Sign-On are running on same host, you have that file already available.
				</p><section class="section" id="enable_spnego_processing"><div class="titlepage"><div><div><h4 class="title">6.4.2.1. Enable SPNEGO Processing</h4></div></div></div><p>
						Red Hat Single Sign-On does not have the SPNEGO protocol support turned on by default. So, you have to go to the <a class="link" href="#authentication-flows" title="6.3. Authentication Flows">browser flow</a> and enable <code class="literal">Kerberos</code>.
					</p><div class="formalpara"><p class="title"><strong>Browser Flow</strong></p><p>
							<span class="inlinemediaobject"><img src="images/rhsso-images/browser-flow.png" alt="browser flow"/></span>
						</p></div><p>
						Switch the <code class="literal">Kerberos</code> requirement from <span class="emphasis"><em>disabled</em></span> to either <span class="emphasis"><em>alternative</em></span> or <span class="emphasis"><em>required</em></span>. <span class="emphasis"><em>Alternative</em></span> basically means that Kerberos is optional. If the user’s browser hasn’t been configured to work with SPNEGO/Kerberos, then Red Hat Single Sign-On will fall back to the regular login screens. If you set the requirement to <span class="emphasis"><em>required</em></span> then all users must have Kerberos enabled for their browser.
					</p></section><section class="section" id="configure_kerberos_user_storage_federation_provider"><div class="titlepage"><div><div><h4 class="title">6.4.2.2. Configure Kerberos User Storage Federation Provider</h4></div></div></div><p>
						Now that the SPNEGO protocol is turned on at the authentication server, you’ll need to configure how Red Hat Single Sign-On interprets the Kerberos ticket. This is done through <a class="link" href="#user-storage-federation" title="Chapter 14. User Storage Federation">User Storage Federation</a>. We have 2 different federation providers with Kerberos authentication support.
					</p><p>
						If you want to authenticate with Kerberos backed by an LDAP server, you have to first configure the <a class="link" href="#ldap" title="14.3. LDAP and Active Directory">LDAP Federation Provider</a>. If you look at the configuration page for your LDAP provider you’ll see a <code class="literal">Kerberos Integration</code> section.
					</p><div class="formalpara"><p class="title"><strong>LDAP Kerberos Integration</strong></p><p>
							<span class="inlinemediaobject"><img src="images/rhsso-images/ldap-kerberos.png" alt="ldap kerberos"/></span>
						</p></div><p>
						Turning on the switch <code class="literal">Allow Kerberos authentication</code> will make Red Hat Single Sign-On use the Kerberos principal to lookup information about the user so that it can be imported into the Red Hat Single Sign-On environment.
					</p><p>
						If your Kerberos solution is not backed by an LDAP server, you have to use the <code class="literal">Kerberos</code> User Storage Federation Provider. Go to the <code class="literal">User Federation</code> left menu item and select <code class="literal">Kerberos</code> from the <code class="literal">Add provider</code> select box.
					</p><div class="formalpara"><p class="title"><strong>Kerberos User Storage Provider</strong></p><p>
							<span class="inlinemediaobject"><img src="images/rhsso-images/kerberos-provider.png" alt="kerberos provider"/></span>
						</p></div><p>
						This provider parses the Kerberos ticket for simple principal information and does a small import into the local Red Hat Single Sign-On database. User profile information like first name, last name, and email are not provisioned.
					</p></section></section><section class="section" id="setup_and_configuration_of_client_machines"><div class="titlepage"><div><div><h3 class="title">6.4.3. Setup and configuration of client machines</h3></div></div></div><p>
					Clients need to install kerberos client and setup krb5.conf as described above. Additionally they need to enable SPNEGO login support in their browser. See <a class="link" href="https://access.redhat.com/documentation/en-us/red_hat_enterprise_linux/7/html/system-level_authentication_guide/configuring_applications_for_sso">configuring Firefox for Kerberos</a> if you are using that browser. URI <code class="literal">.mydomain.org</code> must be allowed in the <code class="literal">network.negotiate-auth.trusted-uris</code> config option.
				</p><p>
					In a Windows domain, clients usually don’t need to configure anything special as IE is already able to participate in SPNEGO authentication for the Windows domain.
				</p></section><section class="section" id="credential_delegation"><div class="titlepage"><div><div><h3 class="title">6.4.4. Credential Delegation</h3></div></div></div><p>
					Kerberos 5 supports the concept of credential delegation. In this scenario, your applications may want access to the Kerberos ticket so that they can re-use it to interact with other services secured by Kerberos. Since the SPNEGO protocol is processed in the Red Hat Single Sign-On server, you have to propagate the GSS credential to your application within the OpenID Connect token claim or a SAML assertion attribute that is transmitted to your application from the Red Hat Single Sign-On server. To have this claim inserted into the token or assertion, each application will need to enable the built-in protocol mapper called <code class="literal">gss delegation credential</code>. This is enabled in the <code class="literal">Mappers</code> tab of the application’s client page. See <a class="link" href="#protocol-mappers" title="8.4. OIDC Token and SAML Assertion Mappings">Protocol Mappers</a> chapter for more details.
				</p><p>
					Applications will need to deserialize the claim it receives from Red Hat Single Sign-On before it can use it to make GSS calls against other services. Once you deserialize the credential from the access token to the GSSCredential object, the GSSContext will need to be created with this credential passed to the method <code class="literal">GSSManager.createContext</code> for example like this:
				</p><pre class="programlisting language-java">// Obtain accessToken in your application.
KeycloakPrincipal keycloakPrincipal = (KeycloakPrincipal) servletReq.getUserPrincipal();
AccessToken accessToken = keycloakPrincipal.getKeycloakSecurityContext().getToken();

// Retrieve kerberos credential from accessToken and deserialize it
String serializedGssCredential = (String) accessToken.getOtherClaims().
    get(org.keycloak.common.constants.KerberosConstants.GSS_DELEGATION_CREDENTIAL);

GSSCredential deserializedGssCredential = org.keycloak.common.util.KerberosSerializationUtils.
    deserializeCredential(serializedGssCredential);

// Create GSSContext to call other kerberos-secured services
GSSContext context = gssManager.createContext(serviceName, krb5Oid,
    deserializedGssCredential, GSSContext.DEFAULT_LIFETIME);</pre><p>
					Note that you also need to configure <code class="literal">forwardable</code> kerberos tickets in <code class="literal">krb5.conf</code> file and add support for delegated credentials to your browser.
				</p><div class="admonition warning"><div class="admonition_header">Warning</div><div><p>
						Credential delegation has some security implications so only use it if you really need it. It’s highly recommended to use it together with HTTPS. See for example <a class="link" href="https://access.redhat.com/documentation/en-us/red_hat_enterprise_linux/7/html/system-level_authentication_guide/configuring_applications_for_sso">this article</a> for more details.
					</p></div></div></section><section class="section" id="cross_realm_trust"><div class="titlepage"><div><div><h3 class="title">6.4.5. Cross-realm trust</h3></div></div></div><p>
					In the Kerberos V5 protocol, the <code class="literal">realm</code> is a set of Kerberos principals defined in the Kerberos database (typically LDAP server). The Kerberos protocol has a concept of cross-realm trust. For example, if there are 2 kerberos realms A and B, the cross-realm trust will allow the users from realm A to access resources (services) of realm B. This means that realm B trusts the realm A.
				</p><div class="formalpara"><p class="title"><strong>Kerberos cross-realm trust</strong></p><p>
						<span class="inlinemediaobject"><img src="images/kerberos-trust-basic.png" alt="kerberos trust basic"/></span>
					</p></div><p>
					The Red Hat Single Sign-On server has support for cross-realm trust. There are few things which need to be done to achieve this:
				</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">
							Configure the Kerberos servers for the cross-realm trust. This step is dependent on the concrete Kerberos server implementations used. In general, it is needed to add the Kerberos principal <code class="literal">krbtgt/B@A</code> to both Kerberos databases of realm A and B. It is needed that this principal has same keys on both Kerberos realms. This is usually achieved when the principals have same password, key version number and there are same ciphers used in both realms. It is recommended to consult the Kerberos server documentation for more details.
						</li></ul></div><div class="admonition note"><div class="admonition_header">Note</div><div><p>
						The cross-realm trust is unidirectional by default. If you want bidirectional trust to have realm A also trust realm B, you must also add the principal <code class="literal">krbtgt/A@B</code> to both Kerberos databases. However, trust is transitive by default. If realm B trusts realm A and realm C trusts realm B, then realm C automatically trusts realm A without a need to have principal <code class="literal">krbtgt/C@A</code> available. Some additional configuration (for example <code class="literal">capaths</code>) may be needed to configure on Kerberos client side, so that the clients are able to find the trust path. Consult the Kerberos documentation for more details.
					</p></div></div><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p class="simpara">
							Configure Red Hat Single Sign-On server
						</p><div class="itemizedlist"><ul class="itemizedlist" type="circle"><li class="listitem">
									If you use an LDAP storage provider with Kerberos support, you need to configure the server principal for realm B as in this example: <code class="literal">HTTP/mydomain.com@B</code>. The LDAP server must be able to find the users from realm A if you want users from realm A to successfully authenticate to Red Hat Single Sign-On, as Red Hat Single Sign-On server must be able to do SPNEGO flow and then find the users. For example, kerberos principal user <code class="literal">john@A</code> must be available as a user in the LDAP under an LDAP DN such as <code class="literal">uid=john,ou=People,dc=example,dc=com</code>. If you want both users from realm A and B to authenticate, you need to ensure that LDAP is able to find users from both realms A and B. We want to improve this limitation in future versions, so you can potentially create more separate LDAP providers for separate realms and ensure that SPNEGO works for both of them.
								</li><li class="listitem">
									If you use a Kerberos user storage provider (typically the Kerberos without LDAP integration), you need to configure the server principal as <code class="literal">HTTP/mydomain.com@B</code> and users from both Kerberos realms A and B should be able to authenticate.
								</li></ul></div></li></ul></div><div class="admonition warning"><div class="admonition_header">Warning</div><div><p>
						For the Kerberos user storage provider, it is recommended that there are no conflicting users among kerberos realms. If conflicting users exist, they will be mapped to the same Red Hat Single Sign-On user. This is also something, which we want to improve in future versions and provide some more flexible mappings from Kerberos principals to Red Hat Single Sign-On usernames.
					</p></div></div></section><section class="section" id="troubleshooting"><div class="titlepage"><div><div><h3 class="title">6.4.6. Troubleshooting</h3></div></div></div><p>
					If you have issues, we recommend that you enable additional logging to debug the problem:
				</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">
							Enable <code class="literal">Debug</code> flag in admin console for Kerberos or LDAP federation providers
						</li><li class="listitem">
							Enable TRACE logging for category <code class="literal">org.keycloak</code> in logging section of <code class="literal">standalone/configuration/standalone.xml</code> to receive more info <code class="literal">standalone/log/server.log</code>
						</li><li class="listitem">
							Add system properties <code class="literal">-Dsun.security.krb5.debug=true</code> and <code class="literal">-Dsun.security.spnego.debug=true</code>
						</li></ul></div></section></section><section class="section" id="x509"><div class="titlepage"><div><div><h2 class="title">6.5. X.509 Client Certificate User Authentication</h2></div></div></div><p>
				Red Hat Single Sign-On supports login with a X.509 client certificate if the server is configured for mutual SSL authentication.
			</p><p>
				A typical workflow is as follows:
			</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">
						A client sends an authentication request over SSL/TLS channel
					</li><li class="listitem">
						During SSL/TLS handshake, the server and the client exchange their x.509/v3 certificates
					</li><li class="listitem">
						The container (JBoss EAP) validates the certificate PKIX path and the certificate expiration
					</li><li class="listitem"><p class="simpara">
						The x.509 client certificate authenticator validates the client certificate as follows:
					</p><div class="itemizedlist"><ul class="itemizedlist" type="circle"><li class="listitem">
								Optionally checks the certificate revocation status using CRL and/or CRL Distribution Points
							</li><li class="listitem">
								Optionally checks the Certificate revocation status using OCSP (Online Certificate Status Protocol)
							</li><li class="listitem">
								Optionally validates whether the key usage in the certificate matches the expected key usage
							</li><li class="listitem">
								Optionally validates whether the extended key usage in the certificate matches the expected extended key usage
							</li></ul></div></li><li class="listitem">
						If any of the above checks fails, the x.509 authentication fails
					</li><li class="listitem">
						Otherwise, the authenticator extracts the certificate identity and maps it to an existing user
					</li><li class="listitem"><p class="simpara">
						Once the certificate is mapped to an existing user, the behavior diverges depending on the authentication flow:
					</p><div class="itemizedlist"><ul class="itemizedlist" type="circle"><li class="listitem">
								In the Browser Flow, the server prompts the user to confirm identity or to ignore it and instead sign in with username/password
							</li><li class="listitem">
								In the case of the Direct Grant Flow, the server signs in the user
							</li></ul></div></li></ul></div><section class="section" id="features_2"><div class="titlepage"><div><div><h3 class="title">6.5.1. Features</h3></div></div></div><div class="variablelist"><dl class="variablelist"><dt><span class="term">Supported Certificate Identity Sources</span></dt><dd><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">
										Match SubjectDN using regular expression
									</li><li class="listitem">
										X500 Subject’s e-mail attribute
									</li><li class="listitem">
										X500 Subject’s e-mail from Subject Alternative Name Extension (RFC822Name General Name)
									</li><li class="listitem">
										X500 Subject’s other name from Subject Alternative Name Extension. This is typically UPN (User Principal Name)
									</li><li class="listitem">
										X500 Subject’s Common Name attribute
									</li><li class="listitem">
										Match IssuerDN using regular expression
									</li><li class="listitem">
										Certificate Serial Number
									</li><li class="listitem">
										Certificate Serial Number and IssuerDN
									</li><li class="listitem">
										SHA-256 Certificate thumbprint
									</li><li class="listitem">
										Full certificate in PEM format
									</li></ul></div></dd><dt><span class="term">Regular Expressions</span></dt><dd>
								The certificate identity can be extracted from either Subject DN or Issuer DN using a regular expression as a filter. For example, the regular expression below will match the e-mail attribute:
							</dd></dl></div><pre class="screen">emailAddress=(.*?)(?:,|$)</pre><p>
					The regular expression filtering is applicable only if the <code class="literal">Identity Source</code> is set to either <code class="literal">Match SubjectDN using regular expression</code> or <code class="literal">Match IssuerDN using regular expression</code>.
				</p><div class="variablelist"><dl class="variablelist"><dt><span class="term">Mapping certificate identity to an existing user</span></dt><dd>
								The certificate identity mapping can be configured to map the extracted user identity to an existing user’s username or e-mail or to a custom attribute which value matches the certificate identity. For example, setting the <code class="literal">Identity source</code> to <span class="emphasis"><em>Subject’s e-mail</em></span> and <code class="literal">User mapping method</code> to <span class="emphasis"><em>Username or email</em></span> will have the X.509 client certificate authenticator use the e-mail attribute in the certificate’s Subject DN as a search criteria to look up an existing user by username or by e-mail.
							</dd></dl></div><div class="admonition important"><div class="admonition_header">Important</div><div><p>
						Please notice that if we disable <code class="literal">Login with email</code> at realm settings, the same rules will be applied to certificate authentication. In other words, users won’t be able to log in using e-mail attribute.
					</p></div></div><div class="admonition important"><div class="admonition_header">Important</div><div><p>
						Usage of <code class="literal">Certificate Serial Number and IssuerDN</code> as an identity source requires two custom attributes - one for serial number and the other for IssuerDN.
					</p></div></div><div class="admonition important"><div class="admonition_header">Important</div><div><p>
						<code class="literal">SHA-256 Certificate thumbprint</code> is lowercase hexadecimal representation of SHA-256 certificate thumbprint.
					</p></div></div><div class="admonition important"><div class="admonition_header">Important</div><div><p>
						Usage of <code class="literal">Full certificate in PEM format</code> as an identity source is limited to custom attributes mapped to external federation sources like LDAP. You must enable <code class="literal">Always Read Value From LDAP</code> in this case, because certificates cannot be stored in Keycloak database due to a length limitation.
					</p></div></div><div class="variablelist"><dl class="variablelist"><dt><span class="term">Other Features: Extended Certificate Validation</span></dt><dd><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">
										Revocation status checking using CRL
									</li><li class="listitem">
										Revocation status checking using CRL/Distribution Point
									</li><li class="listitem">
										Revocation status checking using OCSP/Responder URI
									</li><li class="listitem">
										Certificate KeyUsage validation
									</li><li class="listitem">
										Certificate ExtendedKeyUsage validation
									</li></ul></div></dd></dl></div></section><section class="section" id="enable_x_509_client_certificate_user_authentication"><div class="titlepage"><div><div><h3 class="title">6.5.2. Enable X.509 Client Certificate User Authentication</h3></div></div></div><p>
					The following sections describe how to configure JBoss EAP/Undertow and the Red Hat Single Sign-On Server to enable X.509 client certificate authentication.
				</p><div class="variablelist" id="enable-mtls-wildfly"><dl class="variablelist"><dt><span class="term">Enable mutual SSL in JBoss EAP</span></dt><dd><p class="simpara">
								See <a class="link" href="https://docs.wildfly.org/19/Admin_Guide.html#enable-ssl">Enable SSL</a> for the instructions how to enable SSL in JBoss EAP.
							</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">
										Open RHSSO_HOME/standalone/configuration/standalone.xml and add a new realm:
									</li></ul></div></dd></dl></div><pre class="programlisting language-xml">&lt;security-realms&gt;
    &lt;security-realm name="ssl-realm"&gt;
        &lt;server-identities&gt;
            &lt;ssl&gt;
                &lt;keystore path="servercert.jks"
                          relative-to="jboss.server.config.dir"
                          keystore-password="servercert password"/&gt;
            &lt;/ssl&gt;
        &lt;/server-identities&gt;
        &lt;authentication&gt;
            &lt;truststore path="truststore.jks"
                        relative-to="jboss.server.config.dir"
                        keystore-password="truststore password"/&gt;
        &lt;/authentication&gt;
    &lt;/security-realm&gt;
&lt;/security-realms&gt;</pre><div class="variablelist"><dl class="variablelist"><dt><span class="term"><code class="literal">ssl/keystore</code></span></dt><dd>
								The <code class="literal">ssl</code> element contains the <code class="literal">keystore</code> element that defines how to load the server public key pair from a JKS keystore
							</dd><dt><span class="term"><code class="literal">ssl/keystore/path</code></span></dt><dd>
								A path to a JKS keystore
							</dd><dt><span class="term"><code class="literal">ssl/keystore/relative-to</code></span></dt><dd>
								Defines a path the keystore path is relative to
							</dd><dt><span class="term"><code class="literal">ssl/keystore/keystore-password</code></span></dt><dd>
								The password to open the keystore
							</dd><dt><span class="term"><code class="literal">ssl/keystore/alias</code> (optional)</span></dt><dd>
								The alias of the entry in the keystore. Set it if the keystore contains multiple entries
							</dd><dt><span class="term"><code class="literal">ssl/keystore/key-password</code> (optional)</span></dt><dd>
								The private key password, if different from the keystore password.
							</dd><dt><span class="term"><code class="literal">authentication/truststore</code></span></dt><dd>
								Defines how to load a trust store to verify the certificate presented by the remote side of the inbound/outgoing connection. Typically, the truststore contains a collection of trusted CA certificates.
							</dd><dt><span class="term"><code class="literal">authentication/truststore/path</code></span></dt><dd>
								A path to a JKS keystore that contains the certificates of the trusted CAs (certificate authorities)
							</dd><dt><span class="term"><code class="literal">authentication/truststore/relative-to</code></span></dt><dd>
								Defines a path the truststore path is relative to
							</dd><dt><span class="term"><code class="literal">authentication/truststore/keystore-password</code></span></dt><dd>
								The password to open the truststore
							</dd><dt><span class="term">Enable https listener</span></dt><dd><p class="simpara">
								See <a class="link" href="https://docs.wildfly.org/19/Admin_Guide.html#https-listener">HTTPS Listener</a> for the instructions how to enable HTTPS in WildFly.
							</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">
										Add the &lt;https-listener&gt; element as shown below:
									</li></ul></div></dd></dl></div><pre class="programlisting language-xml">&lt;subsystem xmlns="urn:jboss:domain:undertow:10.0"&gt;
	....
    &lt;server name="default-server"&gt;
	    &lt;https-listener name="default"
                        socket-binding="https"
                        security-realm="ssl-realm"
                        verify-client="REQUESTED"/&gt;
    &lt;/server&gt;
&lt;/subsystem&gt;</pre><div class="variablelist"><dl class="variablelist"><dt><span class="term"><code class="literal">https-listener/security-realm</code></span></dt><dd>
								The value must match the name of the realm from the previous section
							</dd><dt><span class="term"><code class="literal">https-listener/verify-client</code></span></dt><dd>
								If set to <code class="literal">REQUESTED</code>, the server will optionally ask for a client certificate. Setting the attribute to <code class="literal">REQUIRED</code> will have the server to refuse inbound connections if no client certificate has been provided.
							</dd></dl></div></section><section class="section" id="adding_x_509_client_certificate_authentication_to_a_browser_flow"><div class="titlepage"><div><div><h3 class="title">6.5.3. Adding X.509 Client Certificate Authentication to a Browser Flow</h3></div></div></div><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">
							Select a realm, click on Authentication link, select the "Browser" flow
						</li><li class="listitem">
							Make a copy of the built-in "Browser" flow. You may want to give the new flow a distinctive name, i.e. "X.509 Browser"
						</li><li class="listitem">
							Using the drop down, select the copied flow, and click on "Add execution"
						</li><li class="listitem">
							Select "X509/Validate Username Form" using the drop down and click on "Save"
						</li></ul></div><p>
					<span class="inlinemediaobject"><img src="images/x509-execution.png" alt="x509 execution"/></span>
				</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">
							Using the up/down arrows, change the order of the "X509/Validate Username Form" by moving it above the "Browser Forms" execution, and set the requirement to "ALTERNATIVE"
						</li></ul></div><p>
					<span class="inlinemediaobject"><img src="images/x509-browser-flow.png" alt="x509 browser flow"/></span>
				</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">
							Select the "Bindings" tab, find the drop down for "Browser Flow". Select the newly created X509 browser flow from the drop down and click on "Save".
						</li></ul></div><p>
					<span class="inlinemediaobject"><img src="images/x509-browser-flow-bindings.png" alt="x509 browser flow bindings"/></span>
				</p><div class="variablelist"><dl class="variablelist"><dt><span class="term">Configuring X.509 Client Certificate Authentication</span></dt><dd>
								<span class="inlinemediaobject"><img src="images/x509-configuration.png" alt="x509 configuration"/></span>
							</dd><dt><span class="term"><code class="literal">User Identity Source</code></span></dt><dd>
								Defines how to extract the user identity from a client certificate.
							</dd><dt><span class="term"><code class="literal">Canonical DN representation enabled</code> (optional)</span></dt><dd>
								Defines whether to use the canonical format to determine a distinguished name. The format is described in detail in the official <a class="link" href="https://docs.oracle.com/javase/8/docs/api/javax/security/auth/x500/X500Principal.html#getName-java.lang.String-">Java API documentation</a> . This option only affects the two User Identity Sources <span class="emphasis"><em>Match SubjectDN using regular expression</em></span> and <span class="emphasis"><em>Match IssuerDN using regular expression</em></span>. If you setup a new Red Hat Single Sign-On instance it is recommended to enable this option. Leave this option disabled to remain beckward compatible with existing Red Hat Single Sign-On instances.
							</dd><dt><span class="term"><code class="literal">Enable Serial Number hexadecimal representation</code> (optional)</span></dt><dd>
								An option to use hexadecimal representation of the Serial Number. See <a class="link" href="https://tools.ietf.org/html/rfc5280#section-4.1.2.2">RFC5280, Section-4.1.2.2</a>. Serial Number with sign bit set to 1 should be left padded with 00 octet. E.g. Serial number with decimal value <span class="emphasis"><em>161</em></span>, or <span class="emphasis"><em>a1</em></span> in hexadecimal representation according to RFC5280 must be encoded as <span class="emphasis"><em>00a1</em></span>. More details can be found: <a class="link" href="https://tools.ietf.org/html/rfc5280#appendix-B">RFC5280, appendix-B</a>.
							</dd><dt><span class="term"><code class="literal">A regular expression</code> (optional)</span></dt><dd>
								Defines a regular expression to use as a filter to extract the certificate identity. The regular expression must contain a single group.
							</dd><dt><span class="term"><code class="literal">User Mapping Method</code></span></dt><dd>
								Defines how to match the certificate identity to an existing user. <span class="emphasis"><em>Username or e-mail</em></span> will search for an existing user by username or e-mail. <span class="emphasis"><em>Custom Attribute Mapper</em></span> will search for an existing user with a custom attribute which value matches the certificate identity. The name of the custom attribute is configurable.
							</dd><dt><span class="term"><code class="literal">A name of user attribute</code> (optional)</span></dt><dd>
								A custom attribute which value will be matched against the certificate identity. Multiple custom attributes are relevant when attribute mapping is related to multiple values, e.g. 'Certificate Serial Number and IssuerDN'.
							</dd><dt><span class="term"><code class="literal">CRL Checking Enabled</code> (optional)</span></dt><dd>
								Defines whether to check the revocation status of the certificate using Certificate Revocation List.
							</dd><dt><span class="term"><code class="literal">Enable CRL Distribution Point to check certificate revocation status</code> (optional)</span></dt><dd>
								Defines whether to use CDP to check the certificate revocation status. Most PKI authorities include CDP in their certificates.
							</dd><dt><span class="term"><code class="literal">CRL file path</code> (optional)</span></dt><dd>
								Defines a path to a file that contains a CRL list. The value must be a path to a valid file if <code class="literal">CRL Checking Enabled</code> option is turned on.
							</dd><dt><span class="term"><code class="literal">OCSP Checking Enabled</code>(optional)</span></dt><dd>
								Defines whether to check the certificate revocation status using Online Certificate Status Protocol.
							</dd><dt><span class="term"><code class="literal">OCSP Responder URI</code> (optional)</span></dt><dd>
								Allows to override a value of the OCSP responder URI in the certificate.
							</dd><dt><span class="term"><code class="literal">Validate Key Usage</code> (optional)</span></dt><dd>
								Verifies whether the certificate’s KeyUsage extension bits are set. For example, "digitalSignature,KeyEncipherment" will verify if bits 0 and 2 in the KeyUsage extension are asserted. Leave the parameter empty to disable the Key Usage validation. See <a class="link" href="https://tools.ietf.org/html/rfc5280#section-4.2.1.3">RFC5280, Section-4.2.1.3</a>. The server will raise an error only when flagged as critical by the issuing CA and there is a key usage extension mismatch.
							</dd><dt><span class="term"><code class="literal">Validate Extended Key Usage</code> (optional)</span></dt><dd>
								Verifies one or more purposes as defined in the Extended Key Usage extension. See <a class="link" href="https://tools.ietf.org/html/rfc5280#section-4.2.1.12">RFC5280, Section-4.2.1.12</a>. Leave the parameter empty to disable the Extended Key Usage validation. The server will raise an error only when flagged as critical by the issuing CA and there is a key usage extension mismatch.
							</dd><dt><span class="term"><code class="literal">Bypass identity confirmation</code></span></dt><dd>
								If set, X.509 client certificate authentication will not prompt the user to confirm the certificate identity and will automatically sign in the user upon successful authentication.
							</dd></dl></div></section><section class="section" id="adding_x_509_client_certificate_authentication_to_a_direct_grant_flow"><div class="titlepage"><div><div><h3 class="title">6.5.4. Adding X.509 Client Certificate Authentication to a Direct Grant Flow</h3></div></div></div><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">
							Using Red Hat Single Sign-On admin console, click on "Authentication" and select the "Direct Grant" flow,
						</li><li class="listitem">
							Make a copy of the build-in "Direct Grant" flow. You may want to give the new flow a distinctive name, i.e. "X509 Direct Grant",
						</li><li class="listitem">
							Delete "Username Validation" and "Password" authenticators,
						</li><li class="listitem">
							Click on "Add execution" and add "X509/Validate Username" and click on "Save" to add the execution step to the parent flow.
						</li></ul></div><p>
					<span class="inlinemediaobject"><img src="images/x509-directgrant-execution.png" alt="x509 directgrant execution"/></span>
				</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">
							Change the <code class="literal">Requirement</code> to <span class="emphasis"><em>REQUIRED</em></span>.
						</li></ul></div><p>
					<span class="inlinemediaobject"><img src="images/x509-directgrant-flow.png" alt="x509 directgrant flow"/></span>
				</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">
							Set up the x509 authentication configuration by following the steps described earlier in the x.509 Browser Flow section.
						</li><li class="listitem">
							Select the "Bindings" tab, find the drop down for "Direct Grant Flow". Select the newly created X509 direct grant flow from the drop down and click on "Save".
						</li></ul></div><p>
					<span class="inlinemediaobject"><img src="images/x509-directgrant-flow-bindings.png" alt="x509 directgrant flow bindings"/></span>
				</p></section><section class="section" id="client_certificate_lookup"><div class="titlepage"><div><div><h3 class="title">6.5.5. Client certificate lookup</h3></div></div></div><p>
					When an HTTP request is sent directly to Red Hat Single Sign-On server, the JBoss EAP undertow subsystem will establish an SSL handshake and extract the client certificate. The client certificate will be then saved to the attribute <code class="literal">javax.servlet.request.X509Certificate</code> of the HTTP request, as specified in the servlet specification. The Red Hat Single Sign-On X509 authenticator will be then able to lookup the certificate from this attribute.
				</p><p>
					However, when the Red Hat Single Sign-On server listens to HTTP requests behind a load balancer or reverse proxy, it may be the proxy server which extracts the client certificate and establishes the mutual SSL connection. A reverse proxy usually puts the authenticated client certificate in the HTTP header of the underlying request and forwards it to the back end Red Hat Single Sign-On server. In this case, Red Hat Single Sign-On must be able to look up the X.509 certificate chain from the HTTP headers instead of from the attribute of HTTP request, as is done for Undertow.
				</p><p>
					If Red Hat Single Sign-On is behind a reverse proxy, you usually need to configure alternative provider of the <code class="literal">x509cert-lookup</code> SPI in RHSSO_HOME/standalone/configuration/standalone.xml. Along with the <code class="literal">default</code> provider, which looks up the certificate from the HTTP header, we also have two additional built-in providers: <code class="literal">haproxy</code> and <code class="literal">apache</code>, which are described next.
				</p><section class="section" id="haproxy_certificate_lookup_provider"><div class="titlepage"><div><div><h4 class="title">6.5.5.1. HAProxy certificate lookup provider</h4></div></div></div><p>
						You can use this provider when your Red Hat Single Sign-On server is behind an HAProxy reverse proxy. Configure the server like this:
					</p><pre class="programlisting language-xml">&lt;spi name="x509cert-lookup"&gt;
    &lt;default-provider&gt;haproxy&lt;/default-provider&gt;
    &lt;provider name="haproxy" enabled="true"&gt;
        &lt;properties&gt;
            &lt;property name="sslClientCert" value="SSL_CLIENT_CERT"/&gt;
            &lt;property name="sslCertChainPrefix" value="CERT_CHAIN"/&gt;
            &lt;property name="certificateChainLength" value="10"/&gt;
        &lt;/properties&gt;
    &lt;/provider&gt;
&lt;/spi&gt;</pre><p>
						In this example configuration, the client certificate will be looked up from the HTTP header, <code class="literal">SSL_CLIENT_CERT</code>, and the other certificates from its chain will be looked up from HTTP headers like <code class="literal">CERT_CHAIN_0</code> , <code class="literal">CERT_CHAIN_1</code>, …​, <code class="literal">CERT_CHAIN_9</code> . The attribute <code class="literal">certificateChainLength</code> is the maximum length of the chain, so the last one tried attribute would be <code class="literal">CERT_CHAIN_9</code> .
					</p><p>
						Consult the <a class="link" href="http://www.haproxy.org/#docs">HAProxy documentation</a> for the details of how the HTTP Headers for the client certificate and client certificate chain can be configured and their proper names.
					</p></section><section class="section" id="apache_certificate_lookup_provider"><div class="titlepage"><div><div><h4 class="title">6.5.5.2. Apache certificate lookup provider</h4></div></div></div><p>
						You can use this provider when your Red Hat Single Sign-On server is behind an Apache reverse proxy. Configure the server like this:
					</p><pre class="programlisting language-xml">&lt;spi name="x509cert-lookup"&gt;
    &lt;default-provider&gt;apache&lt;/default-provider&gt;
    &lt;provider name="apache" enabled="true"&gt;
        &lt;properties&gt;
            &lt;property name="sslClientCert" value="SSL_CLIENT_CERT"/&gt;
            &lt;property name="sslCertChainPrefix" value="CERT_CHAIN"/&gt;
            &lt;property name="certificateChainLength" value="10"/&gt;
        &lt;/properties&gt;
    &lt;/provider&gt;
&lt;/spi&gt;</pre><p>
						The configuration is same as for the <code class="literal">haproxy</code> provider. Consult the Apache documentation on <a class="link" href="https://httpd.apache.org/docs/current/mod/mod_ssl.html">mod_ssl</a> and <a class="link" href="https://httpd.apache.org/docs/current/mod/mod_headers.html">mod_headers</a> for the details of how the HTTP Headers for the client certificate and client certificate chain can be configured and their proper names.
					</p></section><section class="section" id="nginx_certificate_lookup_provider"><div class="titlepage"><div><div><h4 class="title">6.5.5.3. Nginx certificate lookup provider</h4></div></div></div><p>
						You can use this provider when your Red Hat Single Sign-On server is behind an Nginx reverse proxy. Configure the server like this:
					</p><pre class="programlisting language-xml">&lt;spi name="x509cert-lookup"&gt;
    &lt;default-provider&gt;nginx&lt;/default-provider&gt;
    &lt;provider name="nginx" enabled="true"&gt;
        &lt;properties&gt;
            &lt;property name="sslClientCert" value="ssl-client-cert"/&gt;
            &lt;property name="sslCertChainPrefix" value="USELESS"/&gt;
            &lt;property name="certificateChainLength" value="2"/&gt;
        &lt;/properties&gt;
    &lt;/provider&gt;
&lt;/spi&gt;</pre><div class="admonition note"><div class="admonition_header">Note</div><div><p>
							NGINX <a class="link" href="http://nginx.org/en/docs/http/ngx_http_ssl_module.html#variables">SSL/TLS module</a> does not expose the client certificate chain, so Keycloak NGINX certificate lookup provider is rebuilding it using the <a class="link" href="https://access.redhat.com/documentation/en-us/red_hat_single_sign-on/7.4/html-single/server_installation_and_configuration_guide/#_truststore">Keycloak truststore</a>. Please populate Keycloak truststore using keytool CLI with all root and intermediate CA’s needed for rebuilding client certificate chain.
						</p></div></div><p>
						Consult the NGINX documentation for the details of how the HTTP Headers for the client certificate can be configured. Example of NGINX configuration file :
					</p><pre class="programlisting language-txt"> ...
 server {
    ...
    ssl_client_certificate                  trusted-ca-list-for-client-auth.pem;
    ssl_verify_client                       optional_no_ca;
    ssl_verify_depth                        2;
    ...
    location / {
      ...
      proxy_set_header ssl-client-cert        $ssl_client_escaped_cert;
      ...
    }
    ...
}</pre><div class="admonition note"><div class="admonition_header">Note</div><div><p>
							all certificates in trusted-ca-list-for-client-auth.pem must be added to <a class="link" href="https://access.redhat.com/documentation/en-us/red_hat_single_sign-on/7.4/html-single/server_installation_and_configuration_guide/#_truststore">Keycloak truststore</a>.
						</p></div></div></section><section class="section" id="other_reverse_proxy_implementations"><div class="titlepage"><div><div><h4 class="title">6.5.5.4. Other reverse proxy implementations</h4></div></div></div><p>
						We do not have built-in support for other reverse proxy implementations. However, it is possible that other reverse proxies can be made to behave in a similar way to <code class="literal">apache</code> or <code class="literal">haproxy</code> and that some of those providers can be used. If none of those works, you may need to create your own implementation of the <code class="literal">org.keycloak.services.x509.X509ClientCertificateLookupFactory</code> and <code class="literal">org.keycloak.services.x509.X509ClientCertificateLookup</code> provider. See the <a class="link" href="https://access.redhat.com/documentation/en-us/red_hat_single_sign-on/7.4/html-single/server_developer_guide/">Server Developer Guide</a> for the details on how to add your own provider.
					</p></section></section><section class="section" id="troubleshooting_2"><div class="titlepage"><div><div><h3 class="title">6.5.6. Troubleshooting</h3></div></div></div><div class="variablelist"><dl class="variablelist"><dt><span class="term">Dumping HTTP headers</span></dt><dd>
								If you want to view what the reverse proxy is sending to Keycloak, enable the <code class="literal">RequestDumpingHandler</code> Undertow filter and consult <code class="literal">server.log</code> file.
							</dd><dt><span class="term">Enable TRACE logging under the logging subsystem</span></dt><dd/></dl></div><pre class="programlisting language-xml">...
    &lt;profile&gt;
        &lt;subsystem xmlns="urn:jboss:domain:logging:3.0"&gt;
...
            &lt;logger category="org.keycloak.authentication.authenticators.x509"&gt;
                &lt;level name="TRACE"/&gt;
            &lt;/logger&gt;
            &lt;logger category="org.keycloak.services.x509"&gt;
                &lt;level name="TRACE"/&gt;
            &lt;/logger&gt;</pre><pre class="literallayout">WARNING: Don't use RequestDumpingHandler or TRACE logging in production.</pre><div class="variablelist"><dl class="variablelist"><dt><span class="term">Direct Grant authentication with X.509</span></dt><dd>
								The following template can be used to request a token using the Resource Owner Password Credentials Grant:
							</dd></dl></div><pre class="screen">$ curl https://[host][:port]/auth/realms/master/protocol/openid-connect/token \
       --insecure \
       --data "grant_type=password&amp;scope=openid profile&amp;username=&amp;password=&amp;client_id=CLIENT_ID&amp;client_secret=CLIENT_SECRET" \
       -E /path/to/client_cert.crt \
       --key /path/to/client_cert.key</pre><div class="variablelist"><dl class="variablelist"><dt><span class="term"><code class="literal">[host][:port]</code></span></dt><dd>
								The host and the port number of a remote Red Hat Single Sign-On server that has been configured to allow users authenticate with x.509 client certificates using the Direct Grant Flow.
							</dd><dt><span class="term"><code class="literal">CLIENT_ID</code></span></dt><dd>
								A client id.
							</dd><dt><span class="term"><code class="literal">CLIENT_SECRET</code></span></dt><dd>
								For confidential clients, a client secret; otherwise, leave it empty.
							</dd><dt><span class="term"><code class="literal">client_cert.crt</code></span></dt><dd>
								A public key certificate that will be used to verify the identity of the client in mutual SSL authentication. The certificate should be in PEM format.
							</dd><dt><span class="term"><code class="literal">client_cert.key</code></span></dt><dd>
								A private key in the public key pair. Also expected in PEM format.
							</dd></dl></div></section></section><section class="section" id="webauthn"><div class="titlepage"><div><div><h2 class="title">6.6. W3C Web Authentication (WebAuthn)</h2></div></div></div><p>
				Red Hat Single Sign-On provides the limited support for <a class="link" href="https://www.w3.org/TR/webauthn/">W3C Web Authentication (WebAuthn)</a>. Red Hat Single Sign-On works as a WebAuthn’s <a class="link" href="https://www.w3.org/TR/webauthn/#rp-operations">Relying Party (RP)</a>.
			</p><div class="admonition note"><div class="admonition_header">Note</div><div><p>
					WebAuthn is <span class="strong strong"><strong>Technology Preview</strong></span> and is not fully supported. This feature is disabled by default.
				</p><p>
					To enable start the server with <code class="literal">-Dkeycloak.profile=preview</code> or <code class="literal">-Dkeycloak.profile.feature.web_authn=enabled</code> . For more details see <a class="link" href="https://access.redhat.com/documentation/en-us/red_hat_single_sign-on/7.4/html-single/server_installation_and_configuration_guide/#profiles">Profiles</a>.
				</p></div></div><div class="admonition note"><div class="admonition_header">Note</div><div><p>
					Whether WebAuthn’s operations succeed depends on a user’s WebAuthn supporting authenticator, browser and platform. If you use this WebAuthn support, please clarify to what extent those entities support the WebAuthn specification.
				</p></div></div><section class="section" id="setup"><div class="titlepage"><div><div><h3 class="title">6.6.1. Setup</h3></div></div></div><p>
					The setup procedure of WebAuthn support for 2FA is the following :
				</p><section class="section" id="webauthn-register"><div class="titlepage"><div><div><h4 class="title">6.6.1.1. Enable Webauthn Authenticator Registration</h4></div></div></div><p>
						An administrator carries out the following operations on the <code class="literal">Admin Console</code> :
					</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">
								Open the <code class="literal">Authentication → Required Actions</code> tab.
							</li><li class="listitem">
								Click <code class="literal">Register</code>.
							</li><li class="listitem">
								Select <code class="literal">Webauthn Register</code> as <code class="literal">Required Action</code>.
							</li><li class="listitem">
								Mark <code class="literal">Enabled</code> checkbox. Optionally mark <code class="literal">Default Action</code> checkbox if you want all new created users to be required to register WebAuthn credential.
							</li></ul></div></section><section class="section" id="webauthn-authenticator-setup"><div class="titlepage"><div><div><h4 class="title">6.6.1.2. Adding WebAuthn Authentication to a Browser Flow</h4></div></div></div><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">
								Select a realm, click on <code class="literal">Authentication</code> link, select the <code class="literal">Browser</code> flow
							</li><li class="listitem">
								Make a copy of the built-in "Browser" flow. You may want to give the new flow a distinctive name, for example "WebAuthn Browser"
							</li><li class="listitem">
								Using the drop down, select the copied flow
							</li><li class="listitem">
								Delete the <code class="literal">WebAuthn Browser Browser - Conditional OTP</code> sub-flow using its <code class="literal">Actions</code> menu
							</li></ul></div><p>
						If you want to have WebAuthn required for all users:
					</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">
								Using the <code class="literal">Actions</code> menu of the <code class="literal">WebAuthn Browser Forms</code>, click on <code class="literal">Add execution</code>
							</li><li class="listitem">
								Select <code class="literal">WebAuthn Authenticator</code> using the drop down and click on <code class="literal">Save</code>
							</li><li class="listitem">
								Set its Requirement to <span class="emphasis"><em>Required</em></span>.
							</li></ul></div><p>
						<span class="inlinemediaobject"><img src="images/webauthn-browser-flow-required.png" alt="webauthn browser flow required"/></span>
					</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">
								In the <code class="literal">Bindings</code> menu, change the browser flow to <code class="literal">WebAuthn Browser</code>
							</li></ul></div><p>
						Note that in this scenario, if a user doesn’t have a WebAuthn credential, a required action will be set that forces that user to register one.
					</p><p>
						Alternatively, you can have users log in with WebAuthn only if they have a WebAuthn credential registered, so instead of adding the <code class="literal">WebAuthn Authenticator</code> execution:
					</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">
								Using the <code class="literal">Actions</code> menu of the <code class="literal">WebAuthn Browser Forms</code>, click on <code class="literal">Add flow</code>
							</li><li class="listitem">
								Set the alias to "Conditional 2FA" and click on <code class="literal">Save</code>
							</li><li class="listitem">
								Set the Requirement of <code class="literal">Conditional 2FA</code> to <span class="emphasis"><em>Conditional</em></span>
							</li><li class="listitem">
								Using the <code class="literal">Actions</code> menu of the <code class="literal">Conditional 2FA</code>, click on <code class="literal">Add execution</code>
							</li><li class="listitem">
								Select <code class="literal">Condition - User Configured</code> using the drop down and click on <code class="literal">Save</code>
							</li><li class="listitem">
								Set the Requirement of <code class="literal">Condition - User Configured</code> execution to <span class="emphasis"><em>Required</em></span>
							</li><li class="listitem">
								Using the <code class="literal">Actions</code> menu of the <code class="literal">Conditional 2FA</code>, click on <code class="literal">Add execution</code>
							</li><li class="listitem">
								Select <code class="literal">WebAuthn Authenticator</code> using the drop down and click on <code class="literal">Save</code>
							</li><li class="listitem">
								Set its Requirement to <span class="emphasis"><em>Alternative</em></span>.
							</li></ul></div><p>
						<span class="inlinemediaobject"><img src="images/webauthn-browser-flow-conditional.png" alt="webauthn browser flow conditional"/></span>
					</p><p>
						You can also allow the user to choose between using WebAuthn and OTP for his second factor:
					</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">
								Using the <code class="literal">Actions</code> menu of the <code class="literal">Conditional 2FA</code>, click on <code class="literal">Add execution</code>
							</li><li class="listitem">
								Select <code class="literal">OTP Form</code> using the drop down and click on <code class="literal">Save</code>
							</li><li class="listitem">
								Set its Requirement to <span class="emphasis"><em>Alternative</em></span>.
							</li></ul></div><p>
						<span class="inlinemediaobject"><img src="images/webauthn-browser-flow-conditional-with-OTP.png" alt="webauthn browser flow conditional with OTP"/></span>
					</p></section></section><section class="section" id="authenticate_with_webauthn_authenticator"><div class="titlepage"><div><div><h3 class="title">6.6.2. Authenticate with WebAuthn Authenticator</h3></div></div></div><p>
					After registering a WebAuthn authenticator, the user carries out the following operations assuming that authentication flow configuration above with the conditional subflow using <code class="literal">WebAuthn Authenticator</code> was used:
				</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">
							Open the login form. The user must authenticate with a username and password.
						</li><li class="listitem">
							The user’s browser asks the user to authenticate by their WebAuthn authenticator.
						</li></ul></div></section><section class="section" id="managing_webauthn_as_an_administrator"><div class="titlepage"><div><div><h3 class="title">6.6.3. Managing WebAuthn as an administrator</h3></div></div></div><section class="section" id="managing_credentials"><div class="titlepage"><div><div><h4 class="title">6.6.3.1. Managing Credentials</h4></div></div></div><p>
						WebAuthn credentials are managed in a similar manner as other credentials, such as OTP, from the <a class="link" href="#user-credentials" title="4.5. User Credentials">User credential management</a>:
					</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">
								Users can be assigned a required action to create a WebAuthn credential from the <code class="literal">Reset Actions</code> list, and selecting <code class="literal">Webauthn Register</code>
							</li><li class="listitem">
								The administrator can delete a WebAuthn credential by pressing <code class="literal">Delete</code>.
							</li><li class="listitem">
								The administrator can view the credential’s data such as the AAGUID by selecting <code class="literal">Show data…​</code>.
							</li><li class="listitem">
								The administrator can set a label for the credential by setting a value in the <code class="literal">User Label</code> field and saving the data.
							</li></ul></div></section><section class="section" id="webauthn-policy"><div class="titlepage"><div><div><h4 class="title">6.6.3.2. Managing Policy</h4></div></div></div><p>
						An administrator can configure WebAuthn related operations as <code class="literal">WebAuthn Policy</code> per realm.
					</p><p>
						An administrator carries out the following operations on the <code class="literal">Admin Console</code> :
					</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">
								Open the <code class="literal">Authentication → WebAuthn Policy</code> tab.
							</li><li class="listitem">
								Configure items and click <code class="literal">Save</code>.
							</li></ul></div><p>
						The configurable items and their description follow.
					</p><div class="informaltable"><table class="lt-4-cols lt-7-rows"><colgroup><col style="width: 50%; " class="col_1"/><col style="width: 50%; " class="col_2"/></colgroup><thead><tr><th align="left" valign="top" id="idm140464626831984" scope="col">Configuration</th><th align="left" valign="top" id="idm140464626830896" scope="col">Description</th></tr></thead><tbody><tr><td align="left" valign="top" headers="idm140464626831984">
									<p>
										Relying Party Entity Name
									</p>
									</td><td align="left" valign="top" headers="idm140464626830896">
									<p>
										Human-readable server name as a WebAuthn Relying Party. This is a mandatory configuration, which is applied to the operation of registering the WebAuthn authenticator. The default setting is "keycloak". For more details, see <a class="link" href="https://www.w3.org/TR/webauthn/#dictionary-pkcredentialentity">WebAuthn Specification</a>.
									</p>
									</td></tr><tr><td align="left" valign="top" headers="idm140464626831984">
									<p>
										Signature Algorithms
									</p>
									</td><td align="left" valign="top" headers="idm140464626830896">
									<p>
										It tells the WebAuthn authenticator which signature algorithms to use for the <a class="link" href="https://www.w3.org/TR/webauthn/#public-key-credential">Public Key Credential</a> that can be used for signing and verifying the <a class="link" href="https://www.w3.org/TR/webauthn/#authentication-assertion">Authentication Assertion</a>. Multiple algorithms can be specified. If no algorithm is specified, <a class="link" href="https://tools.ietf.org/html/rfc8152#section-8.1">ES256</a> is adapted. The default setting is ES256. This is an optional configuration item that is applied to the operation of registering a WebAuthn authenticator. For more details, see <a class="link" href="https://www.w3.org/TR/webauthn/#dictdef-publickeycredentialparameters">WebAuthn Specification</a>.
									</p>
									</td></tr><tr><td align="left" valign="top" headers="idm140464626831984">
									<p>
										Relying Party ID
									</p>
									</td><td align="left" valign="top" headers="idm140464626830896">
									<p>
										This is the ID as a WebAuthn Relying Party and determines the scope of Public Key Credentials. It must be origin’s effective domain. This is an optional configuration item that is applied to the operation of registering a WebAuthn authenticator. If no entry is entered, the host part of the base URL of Red Hat Single Sign-On’s server is adapted. For more details, see <a class="link" href="https://www.w3.org/TR/webauthn/#rp-id">WebAuthn Specification</a>.
									</p>
									</td></tr><tr><td align="left" valign="top" headers="idm140464626831984">
									<p>
										Attestation Conveyance Preference
									</p>
									</td><td align="left" valign="top" headers="idm140464626830896">
									<p>
										It tells the WebAuthn API implementation on the browser (<a class="link" href="https://www.w3.org/TR/webauthn/#webauthn-client">WebAuthn Client</a>) the preference of how to generate an Attestation Statement. This is an optional configuration item that is applied to the operation of registering a WebAuthn authenticator. If no option is selected, its behavior is the same as selecting "none". For more details, see <a class="link" href="https://www.w3.org/TR/webauthn/#attestation-convey">WebAuthn Specification</a>.
									</p>
									</td></tr><tr><td align="left" valign="top" headers="idm140464626831984">
									<p>
										Authenticator Attachment
									</p>
									</td><td align="left" valign="top" headers="idm140464626830896">
									<p>
										It tells the WebAuthn Client an acceptable attachment pattern of a WebAuthn authenticator. This is an optional configuration item that is applied to the operation of registering a WebAuthn authenticator. If no option is selected, the WebAuthn Client does not consider the attachment pattern. For more details, see <a class="link" href="https://www.w3.org/TR/webauthn/#enumdef-authenticatorattachment">WebAuthn Specification</a>.
									</p>
									</td></tr><tr><td align="left" valign="top" headers="idm140464626831984">
									<p>
										Require Resident Key
									</p>
									</td><td align="left" valign="top" headers="idm140464626830896">
									<p>
										It tells the WebAuthn authenticator to generate the Public Key Credential as <a class="link" href="https://www.w3.org/TR/webauthn/#client-side-resident-public-key-credential-source">Client-side-resident Public Key Credential Source</a>. This is an optional configuration item that is applied to the operation of registering a WebAuthn authenticator. If no option is selected, its behavior is the same as selecting "No". For more details, see <a class="link" href="https://www.w3.org/TR/webauthn/#dom-authenticatorselectioncriteria-requireresidentkey">WebAuthn Specification</a>.
									</p>
									</td></tr><tr><td align="left" valign="top" headers="idm140464626831984">
									<p>
										User Verification Requirement
									</p>
									</td><td align="left" valign="top" headers="idm140464626830896">
									<p>
										It tells the WebAuthn authenticator to confirm actually verifying a user. This is an optional configuration item that is applied to the operation of registering a WebAuthn authenticator and authenticating the user by a WebAuthn authenticator. If no option is selected, its behavior is the same as selecting "preferred". For more details, see <a class="link" href="https://www.w3.org/TR/webauthn/#dom-authenticatorselectioncriteria-userverification">WebAuthn Specification for registering a WebAuthn authenticator</a> and <a class="link" href="https://www.w3.org/TR/webauthn/#dom-publickeycredentialrequestoptions-userverification">WebAuthn Specification for authenticating the user by a WebAuthn authenticator</a>.
									</p>
									</td></tr><tr><td align="left" valign="top" headers="idm140464626831984">
									<p>
										Timeout
									</p>
									</td><td align="left" valign="top" headers="idm140464626830896">
									<p>
										It specifies the timeout value in seconds for registering a WebAuthn authenticator and authenticating the user by a WebAuthn authenticator. If set to 0, its behavior depends on the WebAuthn authenticator’s implementation. The default value is 0. For more details, see <a class="link" href="https://www.w3.org/TR/webauthn/#dom-publickeycredentialcreationoptions-timeout">WebAuthn Specification for registering a WebAuthn authenticator</a> and <a class="link" href="https://www.w3.org/TR/webauthn/#dom-publickeycredentialrequestoptions-timeout">WebAuthn Specification for authenticating the user by a WebAuthn authenticator</a>.
									</p>
									</td></tr><tr><td align="left" valign="top" headers="idm140464626831984">
									<p>
										Avoid Same Authenticator Registration
									</p>
									</td><td align="left" valign="top" headers="idm140464626830896">
									<p>
										If set to "ON", the WebAuthn authenticator that has already been registered can not be newly registered. This is applied to the operation of registering a WebAuthn authenticator. The default setting is "OFF".
									</p>
									</td></tr><tr><td align="left" valign="top" headers="idm140464626831984">
									<p>
										Acceptable AAGUIDs
									</p>
									</td><td align="left" valign="top" headers="idm140464626830896">
									<p>
										The white list of AAGUID of which a WebAuthn authenticator can be registered. This is applied to the operation of registering a WebAuthn authenticator. If no entry is set on this list, any WebAuthn authenticator can be registered.
									</p>
									</td></tr></tbody></table></div></section></section><section class="section" id="attestation_statement_verification"><div class="titlepage"><div><div><h3 class="title">6.6.4. Attestation Statement Verification</h3></div></div></div><p>
					When registering a WebAuthn authenticator, Red Hat Single Sign-On verifies an attestation statement generated by this WebAuthn authenticator. On this verification process, Red Hat Single Sign-On validates this attestation statement’s trustworthiness. It requires trust anchor’s certificates. Red Hat Single Sign-On uses the <a class="link" href="https://access.redhat.com/documentation/en-us/red_hat_single_sign-on/7.4/html-single/server_installation_and_configuration_guide/#_truststore">Keycloak truststore</a> so that you need to import these certificates onto it in advance.
				</p><p>
					If you want to omit this attestation statement trustworthiness validation, please disable this truststore or set the WebAuthn policy’s configuration item "Attestation Conveyance Preference" to "none".
				</p></section><section class="section" id="managing_webauthn_credentials_as_a_user"><div class="titlepage"><div><div><h3 class="title">6.6.5. Managing WebAuthn credentials as a user</h3></div></div></div><section class="section" id="register_webauthn_authenticator"><div class="titlepage"><div><div><h4 class="title">6.6.5.1. Register WebAuthn Authenticator</h4></div></div></div><p>
						The appropriate method to register a WebAuthn authenticator depends on if the user has or has not already registered an account on Red Hat Single Sign-On.
					</p><div class="variablelist"><dl class="variablelist"><dt><span class="term">New user</span></dt><dd><p class="simpara">
									If the <code class="literal">WebAuthn Register</code> required action is set as <code class="literal">Default Action</code> in a realm, new users are required to set up the WebAuthn security key after the first successful login. A new user carries out the following operations :
								</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">
											Open the login form.
										</li><li class="listitem">
											Click the <code class="literal">Register</code> link.
										</li><li class="listitem">
											Fill in items on the register form and click <code class="literal">Register</code>.
										</li><li class="listitem">
											The user’s browser asks the user to register their WebAuthn authenticator.
										</li><li class="listitem">
											After successful registration, the user’s browser asks the user to enter the text as their just registered WebAuthn authenticator’s label.
										</li></ul></div></dd><dt><span class="term">Existing user</span></dt><dd><p class="simpara">
									If <code class="literal">WebAuthn Authenticator</code> is set up as required as shown in the first example, then when existing users try to log in, they are required to register their WebAuthn authenticator automatically :
								</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">
											Open the login form.
										</li><li class="listitem">
											Fill in items, click <code class="literal">Save</code> and click <code class="literal">Login</code>.
										</li><li class="listitem">
											When the users log in, they are required to register their WebAuthn authenticator.
										</li><li class="listitem">
											After successful registration, the user’s browser asks the user to enter the text as their just registered WebAuthn authenticator’s label.
										</li></ul></div></dd></dl></div></section></section><section class="section" id="passwordless_webauthn_together_with_two_factor"><div class="titlepage"><div><div><h3 class="title">6.6.6. Passwordless WebAuthn together with Two-Factor</h3></div></div></div><p>
					WebAuthn is often used for two-factor authentication, however it can be desired to use it also as first factor authentication. In this case, a user with <code class="literal">passwordless</code> WebAuthn credential will be able to authenticate to Red Hat Single Sign-On without a password. Red Hat Single Sign-On allows to use WebAuthn as both the passwordless and two-factor authentication mechanism in the context of a single realm and even in the context of a single authentication flow.
				</p><p>
					Administrator may typically require that Security Keys registered by users for the WebAuthn passwordless authentication must meet different (usually stronger) requirements. For example, those security keys may require users to authenticate to that security key using a PIN, or the security key should be attested with stronger certificate authority.
				</p><p>
					Because of this situation, Red Hat Single Sign-On allows administrator to configure separate <code class="literal">WebAuthn Passwordless Policy</code>. There is a separate required action of type <code class="literal">Webauthn Register Passwordless</code> and separate authenticator of type <code class="literal">WebAuthn Passwordless Authenticator</code>.
				</p><section class="section" id="setup_2"><div class="titlepage"><div><div><h4 class="title">6.6.6.1. Setup</h4></div></div></div><p>
						The setup procedure of WebAuthn passwordless support is the following :
					</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">
								Register new required action for WebAuthn passwordless support. Use the same steps as described <a class="link" href="#webauthn-register" title="6.6.1.1. Enable Webauthn Authenticator Registration">above</a> with the only difference, that you need to register the action called <code class="literal">Webauthn Register Passwordless</code>.
							</li><li class="listitem">
								Configure the policy. You can use same steps and configuration options as described <a class="link" href="#webauthn-policy" title="6.6.3.2. Managing Policy">above</a>, however you need to configure them in the admin console in the tab <code class="literal">WebAuthn Passwordless Policy</code>. You can configure this policy as you want, however typically the requirements for the security key will be stronger than for the two-factor policy. For example the <code class="literal">User Verification Requirement</code> can be set to <code class="literal">Required</code> when you configure the passwordless policy.
							</li><li class="listitem"><p class="simpara">
								Finally configure the authentication flow. Let’s assume that we will use same flow called <code class="literal">WebAuthn Browser</code> as described <a class="link" href="#webauthn-authenticator-setup" title="6.6.1.2. Adding WebAuthn Authentication to a Browser Flow">above</a>, but we will configure it as follows:
							</p><div class="itemizedlist"><ul class="itemizedlist" type="circle"><li class="listitem">
										The <code class="literal">WebAuthn Browser Forms</code> subflow will contain <code class="literal">Username Form</code> as the first authenticator. Delete the default <code class="literal">Username Password Form</code> authenticator and add the <code class="literal">Username Form</code> authenticator instead. This setting means that the user will provide just his or her username as the first step.
									</li><li class="listitem">
										There will be a required subflow, which can be named for example <code class="literal">Passwordless Or Two-factor</code> . This setting indicates that user can authenticate either with Passwordless WebAuthn credential or with Two-factor authentication.
									</li><li class="listitem">
										Flow will contain <code class="literal">WebAuthn Passwordless Authenticator</code> as the first alternative.
									</li><li class="listitem">
										The second alternative will be a subflow named for example <code class="literal">Password And Two-factor Webauthn</code>. This subflow will contain a <code class="literal">Password Form</code> and a <code class="literal">WebAuthn Authenticator</code>.
									</li></ul></div></li></ul></div><p>
						The final configuration of the flow will look like the following:
					</p><p>
						<span class="inlinemediaobject"><img src="images/webauthn-passwordless-flow.png" alt="webauthn passwordless flow"/></span>
					</p><p>
						You can now add <code class="literal">WebAuthn Register Passwordless</code> as the required action to some user, already known to Red Hat Single Sign-On, to test this. During the first authentication, the user will be still required to use the password and second-factor WebAuthn credential. However, once the user registers the credentials, that user will be able to choose during future authentications. If he uses his or her WebAuthn Passwordless credential, he won’t need to provide the password and second-factor WebAuthn credential at all.
					</p></section></section></section></section><section class="chapter" id="sso_protocols"><div class="titlepage"><div><div><h1 class="title">Chapter 7. SSO Protocols</h1></div></div></div><p>
			The chapter gives a brief overview of the authentication protocols and how the Red Hat Single Sign-On authentication server and the applications it secures interact with these protocols.
		</p><section class="section" id="oidc"><div class="titlepage"><div><div><h2 class="title">7.1. OpenID Connect</h2></div></div></div><p>
				<a class="link" href="https://openid.net/connect/">OpenID Connect</a> (OIDC) is an authentication protocol that is an extension of <a class="link" href="https://tools.ietf.org/html/rfc6749">OAuth 2.0</a>. While OAuth 2.0 is only a framework for building authorization protocols and is mainly incomplete, OIDC is a full-fledged authentication and authorization protocol. OIDC also makes heavy use of the <a class="link" href="https://jwt.io">Json Web Token</a> (JWT) set of standards. These standards define an identity token JSON format and ways to digitally sign and encrypt that data in a compact and web-friendly way.
			</p><p>
				There are really two types of use cases when using OIDC. The first is an application that asks the Red Hat Single Sign-On server to authenticate a user for them. After a successful login, the application will receive an <span class="emphasis"><em>identity token</em></span> and an <span class="emphasis"><em>access token</em></span>. The <span class="emphasis"><em>identity token</em></span> contains information about the user such as username, email, and other profile information. The <span class="emphasis"><em>access token</em></span> is digitally signed by the realm and contains access information (like user role mappings) that the application can use to determine what resources the user is allowed to access on the application.
			</p><p>
				The second type of use cases is that of a client that wants to gain access to remote services. In this case, the client asks Red Hat Single Sign-On to obtain an <span class="emphasis"><em>access token</em></span> it can use to invoke on other remote services on behalf of the user. Red Hat Single Sign-On authenticates the user then asks the user for consent to grant access to the client requesting it. The client then receives the <span class="emphasis"><em>access token</em></span>. This <span class="emphasis"><em>access token</em></span> is digitally signed by the realm. The client can make REST invocations on remote services using this <span class="emphasis"><em>access token</em></span>. The REST service extracts the <span class="emphasis"><em>access token</em></span>, verifies the signature of the token, then decides based on access information within the token whether or not to process the request.
			</p><section class="section" id="oidc-auth-flows"><div class="titlepage"><div><div><h3 class="title">7.1.1. OIDC Auth Flows</h3></div></div></div><p>
					OIDC has different ways for a client or application to authenticate a user and receive an <span class="emphasis"><em>identity</em></span> and <span class="emphasis"><em>access</em></span> token. Which path you use depends greatly on the type of application or client requesting access. All of these flows are described in the OIDC and OAuth 2.0 specifications so only a brief overview will be provided here.
				</p><section class="section" id="authorization_code_flow"><div class="titlepage"><div><div><h4 class="title">7.1.1.1. Authorization Code Flow</h4></div></div></div><p>
						This is a browser-based protocol and it is what we recommend you use to authenticate and authorize browser-based applications. It makes heavy use of browser redirects to obtain an <span class="emphasis"><em>identity</em></span> and <span class="emphasis"><em>access</em></span> token. Here’s a brief summary:
					</p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem">
								Browser visits application. The application notices the user is not logged in, so it redirects the browser to Red Hat Single Sign-On to be authenticated. The application passes along a callback URL (a redirect URL) as a query parameter in this browser redirect that Red Hat Single Sign-On will use when it finishes authentication.
							</li><li class="listitem">
								Red Hat Single Sign-On authenticates the user and creates a one-time, very short lived, temporary code. Red Hat Single Sign-On redirects back to the application using the callback URL provided earlier and additionally adds the temporary code as a query parameter in the callback URL.
							</li><li class="listitem">
								The application extracts the temporary code and makes a background out of band REST invocation to Red Hat Single Sign-On to exchange the code for an <span class="emphasis"><em>identity</em></span>, <span class="emphasis"><em>access</em></span> and <span class="emphasis"><em>refresh</em></span> token. Once this temporary code has been used once to obtain the tokens, it can never be used again. This prevents potential replay attacks.
							</li></ol></div><p>
						It is important to note that <span class="emphasis"><em>access</em></span> tokens are usually short lived and often expired after only minutes. The additional <span class="emphasis"><em>refresh</em></span> token that was transmitted by the login protocol allows the application to obtain a new access token after it expires. This refresh protocol is important in the situation of a compromised system. If access tokens are short lived, the whole system is only vulnerable to a stolen token for the lifetime of the access token. Future refresh token requests will fail if an admin has revoked access. This makes things more secure and more scalable.
					</p><p id="confidential-clients">
						Another important aspect of this flow is the concept of a <span class="emphasis"><em>public</em></span> vs. a <span class="emphasis"><em>confidential</em></span> client. <span class="emphasis"><em>Confidential</em></span> clients are required to provide a client secret when they exchange the temporary codes for tokens. <span class="emphasis"><em>Public</em></span> clients are not required to provide this client secret. <span class="emphasis"><em>Public</em></span> clients are perfectly fine so long as HTTPS is strictly enforced and you are very strict about what redirect URIs are registered for the client. HTML5/JavaScript clients always have to be <span class="emphasis"><em>public</em></span> clients because there is no way to transmit the client secret to them in a secure manner. Again, this is ok so long as you use HTTPS and strictly enforce redirect URI registration. This guide goes more detail into this in the <a class="link" href="#clients" title="Chapter 8. Managing Clients">Managing Clients</a> chapter.
					</p><p>
						Red Hat Single Sign-On also supports the optional <a class="link" href="https://tools.ietf.org/html/rfc7636">Proof Key for Code Exchange</a> specification.
					</p></section><section class="section" id="implicit_flow"><div class="titlepage"><div><div><h4 class="title">7.1.1.2. Implicit Flow</h4></div></div></div><p>
						This is a browser-based protocol that is similar to Authorization Code Flow except there are fewer requests and no refresh tokens involved. We do not recommend this flow as there remains the possibility of <span class="emphasis"><em>access</em></span> tokens being leaked in the browser history as tokens are transmitted via redirect URIs (see below). Also, since this flow doesn’t provide the client with a refresh token, access tokens would either have to be long-lived or users would have to re-authenticate when they expired. This flow is supported because it is in the OIDC and OAuth 2.0 specification. Here’s a brief summary of the protocol:
					</p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem">
								Browser visits application. The application notices the user is not logged in, so it redirects the browser to Red Hat Single Sign-On to be authenticated. The application passes along a callback URL (a redirect URL) as a query parameter in this browser redirect that Red Hat Single Sign-On will use when it finishes authentication.
							</li><li class="listitem">
								Red Hat Single Sign-On authenticates the user and creates an <span class="emphasis"><em>identity</em></span> and <span class="emphasis"><em>access</em></span> token. Red Hat Single Sign-On redirects back to the application using the callback URL provided earlier and additionally adding the <span class="emphasis"><em>identity</em></span> and <span class="emphasis"><em>access</em></span> tokens as query parameters in the callback URL.
							</li><li class="listitem">
								The application extracts the <span class="emphasis"><em>identity</em></span> and <span class="emphasis"><em>access</em></span> tokens from the callback URL.
							</li></ol></div></section><section class="section" id="resource_owner_password_credentials_grant_direct_access_grants"><div class="titlepage"><div><div><h4 class="title">7.1.1.3. Resource Owner Password Credentials Grant (Direct Access Grants)</h4></div></div></div><p>
						This is referred to in the Admin Console as <span class="emphasis"><em>Direct Access Grants</em></span>. This is used by REST clients that want to obtain a token on behalf of a user. It is one HTTP POST request that contains the credentials of the user as well as the id of the client and the client’s secret (if it is a confidential client). The user’s credentials are sent within form parameters. The HTTP response contains <span class="emphasis"><em>identity</em></span>, <span class="emphasis"><em>access</em></span>, and <span class="emphasis"><em>refresh</em></span> tokens.
					</p></section><section class="section" id="client_credentials_grant"><div class="titlepage"><div><div><h4 class="title">7.1.1.4. Client Credentials Grant</h4></div></div></div><p>
						This is also used by REST clients, but instead of obtaining a token that works on behalf of an external user, a token is created based on the metadata and permissions of a service account that is associated with the client. More info together with example is in <a class="link" href="#service_accounts" title="8.1.3. Service Accounts">Service Accounts</a> chapter.
					</p></section></section><section class="section" id="red_hat_single_sign_on_server_oidc_uri_endpoints"><div class="titlepage"><div><div><h3 class="title">7.1.2. Red Hat Single Sign-On Server OIDC URI Endpoints</h3></div></div></div><p>
					Here’s a list of OIDC endpoints that the Red Hat Single Sign-On publishes. These URLs are useful if you are using a non-Red Hat Single Sign-On client adapter to talk OIDC with the auth server. These are all relative URLs and the root of the URL being the HTTP(S) protocol, hostname, and usually path prefixed with <span class="emphasis"><em>/auth</em></span>: i.e. https://localhost:8080/auth
				</p><div class="variablelist"><dl class="variablelist"><dt><span class="term">/realms/{realm-name}/protocol/openid-connect/auth</span></dt><dd>
								This is the URL endpoint for obtaining a temporary code in the Authorization Code Flow or for obtaining tokens via the Implicit Flow, Direct Grants, or Client Grants.
							</dd><dt><span class="term">/realms/{realm-name}/protocol/openid-connect/token</span></dt><dd>
								This is the URL endpoint for the Authorization Code Flow to turn a temporary code into a token.
							</dd><dt><span class="term">/realms/{realm-name}/protocol/openid-connect/logout</span></dt><dd>
								This is the URL endpoint for performing logouts.
							</dd><dt><span class="term">/realms/{realm-name}/protocol/openid-connect/userinfo</span></dt><dd>
								This is the URL endpoint for the User Info service described in the OIDC specification.
							</dd><dt><span class="term">/realms/{realm-name}/protocol/openid-connect/revoke</span></dt><dd>
								This is the URL endpoint for OAuth 2.0 Token Revocation described in <a class="link" href="https://tools.ietf.org/html/rfc7009">RFC7009</a>.
							</dd></dl></div><p>
					In all of these replace <span class="emphasis"><em>{realm-name}</em></span> with the name of the realm.
				</p></section></section><section class="section" id="saml"><div class="titlepage"><div><div><h2 class="title">7.2. SAML</h2></div></div></div><p>
				<a class="link" href="http://saml.xml.org/saml-specifications">SAML 2.0</a> is a similar specification to OIDC but a lot older and more mature. It has its roots in SOAP and the plethora of WS-* specifications so it tends to be a bit more verbose than OIDC. SAML 2.0 is primarily an authentication protocol that works by exchanging XML documents between the authentication server and the application. XML signatures and encryption is used to verify requests and responses.
			</p><p>
				There are really two types of use cases when using SAML. The first is an application that asks the Red Hat Single Sign-On server to authenticate a user for them. After a successful login, the application will receive an XML document that contains something called a SAML assertion that specify various attributes about the user. This XML document is digitally signed by the realm and contains access information (like user role mappings) that the application can use to determine what resources the user is allowed to access on the application.
			</p><p>
				The second type of use cases is that of a client that wants to gain access to remote services. In this case, the client asks Red Hat Single Sign-On to obtain an SAML assertion it can use to invoke on other remote services on behalf of the user.
			</p><section class="section" id="saml_bindings"><div class="titlepage"><div><div><h3 class="title">7.2.1. SAML Bindings</h3></div></div></div><p>
					SAML defines a few different ways to exchange XML documents when executing the authentication protocol. The <span class="emphasis"><em>Redirect</em></span> and <span class="emphasis"><em>Post</em></span> bindings cover browser based applications. The <span class="emphasis"><em>ECP</em></span> binding covers REST invocations. There are other binding types but Red Hat Single Sign-On only supports those three.
				</p><section class="section" id="redirect_binding"><div class="titlepage"><div><div><h4 class="title">7.2.1.1. Redirect Binding</h4></div></div></div><p>
						The <span class="emphasis"><em>Redirect</em></span> Binding uses a series of browser redirect URIs to exchange information. This is a rough overview of how it works.
					</p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem">
								The user visits the application and the application finds the user is not authenticated. It generates an XML authentication request document and encodes it as a query param in a URI that is used to redirect to the Red Hat Single Sign-On server. Depending on your settings, the application may also digitally sign this XML document and also stuff this signature as a query param in the redirect URI to Red Hat Single Sign-On. This signature is used to validate the client that sent this request.
							</li><li class="listitem">
								The browser is redirected to Red Hat Single Sign-On. The server extracts the XML auth request document and verifies the digital signature if required. The user then has to enter in their credentials to be authenticated.
							</li><li class="listitem">
								After authentication, the server generates an XML authentication response document. This document contains a SAML assertion that holds metadata about the user like name, address, email, and any role mappings the user might have. This document is almost always digitally signed using XML signatures, and may also be encrypted.
							</li><li class="listitem">
								The XML auth response document is then encoded as a query param in a redirect URI that brings the browser back to the application. The digital signature is also included as a query param.
							</li><li class="listitem">
								The application receives the redirect URI and extracts the XML document and verifies the realm’s signature to make sure it is receiving a valid auth response. The information inside the SAML assertion is then used to make access decisions or display user data.
							</li></ol></div></section><section class="section" id="post_binding"><div class="titlepage"><div><div><h4 class="title">7.2.1.2. POST Binding</h4></div></div></div><p>
						The SAML <span class="emphasis"><em>POST</em></span> binding works almost the exact same way as the <span class="emphasis"><em>Redirect</em></span> binding, but instead of GET requests, XML documents are exchanged by POST requests. The <span class="emphasis"><em>POST</em></span> Binding uses JavaScript to trick the browser into making a POST request to the Red Hat Single Sign-On server or application when exchanging documents. Basically HTTP responses contain an HTML document that contains an HTML form with embedded JavaScript. When the page is loaded, the JavaScript automatically invokes the form. You really don’t need to know about this stuff, but it is a pretty clever trick.
					</p><p>
						<span class="emphasis"><em>POST</em></span> binding is usually recommended because of security and size restrictions. When using <span class="emphasis"><em>REDIRECT</em></span> the SAML response is part of the URL (it is a query parameter as it was explained before), so it can be captured in logs and it is considered less secure. Regarding size, if the assertion contains a lot or large attributes sending the document inside the HTTP payload is always better than in the more limited URL.
					</p></section><section class="section" id="ecp"><div class="titlepage"><div><div><h4 class="title">7.2.1.3. ECP</h4></div></div></div><p>
						ECP stands for "Enhanced Client or Proxy", a SAML v.2.0 profile which allows for the exchange of SAML attributes outside the context of a web browser. This is used most often for REST or SOAP-based clients.
					</p></section></section><section class="section" id="red_hat_single_sign_on_server_saml_uri_endpoints"><div class="titlepage"><div><div><h3 class="title">7.2.2. Red Hat Single Sign-On Server SAML URI Endpoints</h3></div></div></div><p>
					Red Hat Single Sign-On really only has one endpoint for all SAML requests.
				</p><p>
					<code class="literal">http(s)://authserver.host/auth/realms/{realm-name}/protocol/saml</code>
				</p><p>
					All bindings use this endpoint.
				</p></section></section><section class="section" id="openid_connect_vs_saml"><div class="titlepage"><div><div><h2 class="title">7.3. OpenID Connect vs. SAML</h2></div></div></div><p>
				Choosing between OpenID Connect and SAML is not just a matter of using a newer protocol (OIDC) instead of the older more mature protocol (SAML).
			</p><p>
				In most cases Red Hat Single Sign-On recommends using OIDC.
			</p><p>
				SAML tends to be a bit more verbose than OIDC.
			</p><p>
				Beyond verbosity of exchanged data, if you compare the specifications you’ll find that OIDC was designed to work with the web while SAML was retrofitted to work on top of the web. For example, OIDC is also more suited for HTML5/JavaScript applications because it is easier to implement on the client side than SAML. As tokens are in the JSON format, they are easier to consume by JavaScript. You will also find several nice features that make implementing security in your web applications easier. For example, check out the <a class="link" href="https://openid.net/specs/openid-connect-session-1_0.html#ChangeNotification">iframe trick</a> that the specification uses to easily determine if a user is still logged in or not.
			</p><p>
				SAML has its uses though. As you see the OIDC specifications evolve you see they implement more and more features that SAML has had for years. What we often see is that people pick SAML over OIDC because of the perception that it is more mature and also because they already have existing applications that are secured with it.
			</p></section><section class="section" id="docker"><div class="titlepage"><div><div><h2 class="title">7.4. Docker Registry v2 Authentication</h2></div></div></div><div class="admonition note"><div class="admonition_header">Note</div><div><p>
					Docker authentication is disabled by default. To enable see <a class="link" href="https://access.redhat.com/documentation/en-us/red_hat_single_sign-on/7.4/html-single/server_installation_and_configuration_guide/#profiles">Profiles</a>.
				</p></div></div><p>
				<a class="link" href="https://docs.docker.com/registry/spec/auth/">Docker Registry V2 Authentication</a> is an OIDC-Like protocol used to authenticate users against a Docker registry. Red Hat Single Sign-On’s implementation of this protocol allows for a Red Hat Single Sign-On authentication server to be used by a Docker client to authenticate against a registry. While this protocol uses fairly standard token and signature mechanisms, it has a few wrinkles that prevent it from being treated as a true OIDC implementation. The largest deviations include a very specific JSON format for requests and responses as well as the ability to understand how to map repository names and permissions to the OAuth scope mechanism.
			</p><section class="section" id="docker_auth_flow"><div class="titlepage"><div><div><h3 class="title">7.4.1. Docker Auth Flow</h3></div></div></div><p>
					The <a class="link" href="https://docs.docker.com/registry/spec/auth/token/">Docker API documentation</a> best describes and illustrates this process, however a brief summary will be given below from the perspective of the Red Hat Single Sign-On authentication server.
				</p><div class="admonition note"><div class="admonition_header">Note</div><div><p>
						This flow assumes that a <code class="literal">docker login</code> command has already been performed
					</p></div></div><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">
							The flow begins when the Docker client requests a resource from the Docker registry. If the resource is protected and no auth token is present in the request, the Docker registry server will respond to the client with a 401 + some information on required permissions and where to find the authorization server.
						</li><li class="listitem">
							The Docker client will construct an authentication request based on the 401 response from the Docker registry. The client will then use the locally cached credentials (from a previously run <code class="literal">docker login</code> command) as part of a <a class="link" href="https://tools.ietf.org/html/rfc2617">HTTP Basic Authentication</a> request to the Red Hat Single Sign-On authentication server.
						</li><li class="listitem">
							The Red Hat Single Sign-On authentication server will attempt to authenticate the user and return a JSON body containing an OAuth-style Bearer token.
						</li><li class="listitem">
							The Docker client will get the bearer token from the JSON response and use it in the Authorization header to request the protected resource.
						</li><li class="listitem">
							When the Docker registry receives the new request for the protected resource with the token from the Red Hat Single Sign-On server, the registry validates the token and grants access to the requested resource (if appropriate).
						</li></ul></div></section><section class="section" id="red_hat_single_sign_on_docker_registry_v2_authentication_server_uri_endpoints"><div class="titlepage"><div><div><h3 class="title">7.4.2. Red Hat Single Sign-On Docker Registry v2 Authentication Server URI Endpoints</h3></div></div></div><p>
					Red Hat Single Sign-On really only has one endpoint for all Docker auth v2 requests.
				</p><p>
					<code class="literal">http(s)://authserver.host/auth/realms/{realm-name}/protocol/docker-v2</code>
				</p></section></section></section><section class="chapter" id="clients"><div class="titlepage"><div><div><h1 class="title">Chapter 8. Managing Clients</h1></div></div></div><p>
			Clients are entities that can request authentication of a user. Clients come in two forms. The first type of client is an application that wants to participate in single-sign-on. These clients just want Red Hat Single Sign-On to provide security for them. The other type of client is one that is requesting an access token so that it can invoke other services on behalf of the authenticated user. This section discusses various aspects around configuring clients and various ways to do it.
		</p><section class="section" id="oidc_clients"><div class="titlepage"><div><div><h2 class="title">8.1. OIDC Clients</h2></div></div></div><p>
				<a class="link" href="#oidc" title="7.1. OpenID Connect">OpenID Connect</a> is the preferred protocol to secure applications. It was designed from the ground up to be web friendly and work best with HTML5/JavaScript applications.
			</p><p>
				To create an OIDC client go to the <code class="literal">Clients</code> left menu item. On this page you’ll see a <code class="literal">Create</code> button on the right.
			</p><div class="formalpara"><p class="title"><strong>Clients</strong></p><p>
					<span class="inlinemediaobject"><img src="images/rhsso-images/clients.png" alt="clients"/></span>
				</p></div><p>
				This will bring you to the <code class="literal">Add Client</code> page.
			</p><div class="formalpara"><p class="title"><strong>Add Client</strong></p><p>
					<span class="inlinemediaobject"><img src="images/rhsso-images/add-client-oidc.png" alt="add client oidc"/></span>
				</p></div><p>
				Enter in the <code class="literal">Client ID</code> of the client. This should be a simple alpha-numeric string that will be used in requests and in the Red Hat Single Sign-On database to identify the client. Next select <code class="literal">openid-connect</code> in the <code class="literal">Client Protocol</code> drop down box. Finally enter in the base URL of your application in the <code class="literal">Root URL</code> field and click <code class="literal">Save</code>. This will create the client and bring you to the client <code class="literal">Settings</code> tab.
			</p><div class="formalpara"><p class="title"><strong>Client Settings</strong></p><p>
					<span class="inlinemediaobject"><img src="images/rhsso-images/client-settings-oidc.png" alt="client settings oidc"/></span>
				</p></div><p>
				Let’s walk through each configuration item on this page.
			</p><p>
				<span class="strong strong"><strong>Client ID</strong></span>
			</p><p>
				This specifies an alpha-numeric string that will be used as the client identifier for OIDC requests.
			</p><p>
				<span class="strong strong"><strong>Name</strong></span>
			</p><p>
				This is the display name for the client whenever it is displayed in a Red Hat Single Sign-On UI screen. You can localize the value of this field by setting up a replacement string value i.e. ${myapp}. See the <a class="link" href="https://access.redhat.com/documentation/en-us/red_hat_single_sign-on/7.4/html-single/server_developer_guide/">Server Developer Guide</a> for more information.
			</p><p>
				<span class="strong strong"><strong>Description</strong></span>
			</p><p>
				This specifies the description of the client. This can also be localized.
			</p><p>
				<span class="strong strong"><strong>Enabled</strong></span>
			</p><p>
				If this is turned off, the client will not be allowed to request authentication.
			</p><p>
				<span class="strong strong"><strong>Consent Required</strong></span>
			</p><p>
				If this is on, then users will get a consent page which asks the user if they grant access to that application. It will also display the metadata that the client is interested in so that the user knows exactly what information the client is getting access to. If you’ve ever done a social login to Google, you’ll often see a similar page. Red Hat Single Sign-On provides the same functionality.
			</p><p id="access-type">
				<span class="strong strong"><strong>Access Type</strong></span>
			</p><p>
				This defines the type of the OIDC client.
			</p><div class="variablelist"><dl class="variablelist"><dt><span class="term"><span class="emphasis"><em>confidential</em></span></span></dt><dd>
							Confidential access type is for server-side clients that need to perform a browser login and require a client secret when they turn an access code into an access token, (see <a class="link" href="https://tools.ietf.org/html/rfc6749#section-4.1.3">Access Token Request</a> in the OAuth 2.0 spec for more details). This type should be used for server-side applications.
						</dd><dt><span class="term"><span class="emphasis"><em>public</em></span></span></dt><dd>
							Public access type is for client-side clients that need to perform a browser login. With a client-side application there is no way to keep a secret safe. Instead it is very important to restrict access by configuring correct redirect URIs for the client.
						</dd><dt><span class="term"><span class="emphasis"><em>bearer-only</em></span></span></dt><dd>
							Bearer-only access type means that the application only allows bearer token requests. If this is turned on, this application cannot participate in browser logins.
						</dd></dl></div><p>
				<span class="strong strong"><strong>Standard Flow Enabled</strong></span>
			</p><p>
				If this is on, clients are allowed to use the OIDC <a class="link" href="#oidc-auth-flows" title="7.1.1. OIDC Auth Flows">Authorization Code Flow</a>.
			</p><p>
				<span class="strong strong"><strong>Implicit Flow Enabled</strong></span>
			</p><p>
				If this is on, clients are allowed to use the OIDC <a class="link" href="#oidc-auth-flows" title="7.1.1. OIDC Auth Flows">Implicit Flow</a>.
			</p><p>
				<span class="strong strong"><strong>Direct Access Grants Enabled</strong></span>
			</p><p>
				If this is on, clients are allowed to use the OIDC <a class="link" href="#oidc-auth-flows" title="7.1.1. OIDC Auth Flows">Direct Access Grants</a>.
			</p><p>
				<span class="strong strong"><strong>Root URL</strong></span>
			</p><p>
				If Red Hat Single Sign-On uses any configured relative URLs, this value is prepended to them.
			</p><p>
				<span class="strong strong"><strong>Valid Redirect URIs</strong></span>
			</p><p>
				This is a required field. Enter in a URL pattern and click the + sign to add. Click the - sign next to URLs you want to remove. Remember that you still have to click the <code class="literal">Save</code> button! Wildcards (*) are only allowed at the end of a URI, i.e. http://host.com/*
			</p><p>
				You should take extra precautions when registering valid redirect URI patterns. If you make them too general you are vulnerable to attacks. See <a class="link" href="#unspecific-redirect-uris" title="19.7. Unspecific Redirect URIs">Threat Model Mitigation</a> chapter for more information.
			</p><p>
				<span class="strong strong"><strong>Base URL</strong></span>
			</p><p>
				If Red Hat Single Sign-On needs to link to the client, this URL is used.
			</p><p>
				<span class="strong strong"><strong>Admin URL</strong></span>
			</p><p>
				For Red Hat Single Sign-On specific client adapters, this is the callback endpoint for the client. The Red Hat Single Sign-On server will use this URI to make callbacks like pushing revocation policies, performing backchannel logout, and other administrative operations. For Red Hat Single Sign-On servlet adapters, this can be the root URL of the servlet application. For more information see <a class="link" href="https://access.redhat.com/documentation/en-us/red_hat_single_sign-on/7.4/html-single/securing_applications_and_services_guide/">Securing Applications and Services Guide</a>.
			</p><p>
				<span class="strong strong"><strong>Web Origins</strong></span>
			</p><p>
				This option centers around <a class="link" href="http://www.w3.org/TR/cors/">CORS</a> which stands for Cross-Origin Resource Sharing. If browser JavaScript tries to make an AJAX HTTP request to a server whose domain is different from the one the JavaScript code came from, then the request must use CORS. The server must handle CORS requests in a special way, otherwise the browser will not display or allow the request to be processed. This protocol exists to protect against XSS, CSRF and other JavaScript-based attacks.
			</p><p>
				Red Hat Single Sign-On has support for validated CORS requests. The way it works is that the domains listed in the <code class="literal">Web Origins</code> setting for the client are embedded within the access token sent to the client application. The client application can then use this information to decide whether or not to allow a CORS request to be invoked on it. This is an extension to the OIDC protocol so only Red Hat Single Sign-On client adapters support this feature. See <a class="link" href="https://access.redhat.com/documentation/en-us/red_hat_single_sign-on/7.4/html-single/securing_applications_and_services_guide/">Securing Applications and Services Guide</a> for more information.
			</p><p>
				To fill in the <code class="literal">Web Origins</code> data, enter in a base URL and click the + sign to add. Click the - sign next to URLs you want to remove. Remember that you still have to click the <code class="literal">Save</code> button!
			</p><section class="section" id="advanced_settings"><div class="titlepage"><div><div><h3 class="title">8.1.1. Advanced Settings</h3></div></div></div><p id="mtls-client-certificate-bound-tokens">
					<span class="strong strong"><strong>OAuth 2.0 Mutual TLS Certificate Bound Access Tokens Enabled</strong></span>
				</p><p>
					Mutual TLS binds an access token and a refresh token with a client certificate exchanged during TLS handshake. This prevents an attacker who finds a way to steal these tokens from exercising the tokens. This type of token is called a holder-of-key token. Unlike bearer tokens, the recipient of a holder-of-key token can verify whether the sender of the token is legitimate.
				</p><p>
					If the following conditions are satisfied on a token request, Red Hat Single Sign-On will bind an access token and a refresh token with a client certificate and issue them as holder-of-key tokens. If all conditions are not met, Red Hat Single Sign-On rejects the token request.
				</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">
							The feature is turned on
						</li><li class="listitem">
							A token request is sent to the token endpoint in an authorization code flow or a hybrid flow
						</li><li class="listitem">
							On TLS handshake, Red Hat Single Sign-On requests a client certificate and a client send its client certificate
						</li><li class="listitem">
							On TLS handshake, Red Hat Single Sign-On successfully verifies the client certificate
						</li></ul></div><p>
					To enable mutual TLS in Red Hat Single Sign-On, see <a class="link" href="#enable-mtls-wildfly">Enable mutual SSL in WildFly</a>.
				</p><p>
					In the following cases, Red Hat Single Sign-On will verify the client sending the access token or the refresh token; if verification fails, Red Hat Single Sign-On rejects the token.
				</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">
							A token refresh request is sent to the token endpoint with a holder-of-key refresh token
						</li><li class="listitem">
							A UserInfo request is sent to UserInfo endpoint with a holder-of-key access token
						</li><li class="listitem">
							A logout request is sent to Logout endpoint with a holder-of-key refresh token
						</li></ul></div><p>
					Please see <a class="link" href="https://tools.ietf.org/html/draft-ietf-oauth-mtls-08#section-3">Mutual TLS Client Certificate Bound Access Tokens</a> in the OAuth 2.0 Mutual TLS Client Authentication and Certificate Bound Access Tokens for more details.
				</p><div class="admonition warning"><div class="admonition_header">Warning</div><div><p>
						None of the keycloak client adapters currently support holder-of-key token verification. Instead, keycloak adapters currently treat access and refresh tokens as bearer tokens.
					</p></div></div><p id="proof-key-for-code-exchange">
					<span class="strong strong"><strong>Proof Key for Code Exchange (PKCE)</strong></span>
				</p><p>
					When an attacker steals an authorization code that was issued to a legitimate client, PKCE prevents the attacker from receiving the tokens that apply to that code.
				</p><p>
					The administrator can select the following three options:
				</p><p>
					<span class="strong strong"><strong>Proof Key for Code Exchange Code Challenge Method</strong></span>
				</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">
							(blank) : Red Hat Single Sign-On does not apply PKCE unless the client sends PKCE’s parameters appropriately to Red Hat Single Sign-On’s authorization endpoint. It is the default setting.
						</li><li class="listitem">
							S256 : Red Hat Single Sign-On applies to the client PKCE whose code challenge method is S256.
						</li><li class="listitem">
							plain : Red Hat Single Sign-On applies to the client PKCE whose code challenge method is plain.
						</li></ul></div><p>
					Please see <a class="link" href="https://tools.ietf.org/html/rfc7636">RFC 7636 Proof Key for Code Exchange by OAuth Public Clients</a> for more details.
				</p><p id="jwe-id-token-encryption">
					<span class="strong strong"><strong>Signed and Encrypted ID Token Support</strong></span>
				</p><p>
					Red Hat Single Sign-On can encrypt ID token according to the <a class="link" href="https://tools.ietf.org/html/rfc7516">Json Web Encryption (JWE)</a> specification. The administrator can determine whether encrypting ID token or not per client. This feature is disabled as default.
				</p><p>
					The key for encrypting ID token is called Content Encryption Key (CEK). Red Hat Single Sign-On and a client need to negotiate which CEK is used and how to deliver it. The way to do so is called Key Management Mode.
				</p><p>
					JWE specification determines 5 types of Key Management Mode. Red Hat Single Sign-On supports Key Encryption among them.
				</p><p>
					In Key Encryption, the client generates a key pair of asymmetric cryptography. The public key is used to encrypt CEK. Red Hat Single Sign-On generates CEK per ID token, encrypts the ID token by this generated CEK and encrypts this CEK by this client’s public key. The client decrypts this encrypted CEK by their private key, and decrypt the ID token by decrypted CEK. Therefore, any party other than the client is not able to decrypt ID token.
				</p><p>
					The client needs to pass their public key for encrypting CEK onto Red Hat Single Sign-On. Red Hat Single Sign-On supports downloading public keys from the URL the client provides. The client needs to provide their public keys according to <a class="link" href="https://tools.ietf.org/html/rfc7517">Json Web Keys (JWK)</a> specification. The way to do so is defined in <code class="literal">Signed JWT</code> of <a class="link" href="#client-credentials" title="8.1.2. Confidential Client Credentials">Confidential Client Credentials</a>. The detailed procedure is as follows:
				</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">
							open the client’s <code class="literal">Credentials</code> tab
						</li><li class="listitem">
							select <code class="literal">Signed Jwt</code> from <code class="literal">Client Authenticator</code> pulldown menu
						</li><li class="listitem">
							set ON to <code class="literal">JWKS URL</code> switch
						</li><li class="listitem">
							input the client’s public key providing URL on <code class="literal">JWKS URL</code> textbox
						</li></ul></div><p>
					Key Encryption’s algorithms are defined in the <a class="link" href="https://tools.ietf.org/html/rfc7518#section-4.1">Json Web Algorithm (JWA)</a> specification. Red Hat Single Sign-On supports RSAES-PKCS1-v1_5(RSA1_5) and RSAES OAEP using default parameters (RSA-OAEP). The detailed procedure to select this algorithm is as follows:
				</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">
							open the client’s <code class="literal">Settings</code> tab
						</li><li class="listitem">
							open <code class="literal">Advanced Settings</code>
						</li><li class="listitem">
							select <code class="literal">RSA1_5</code> or <code class="literal">RSA-OAEP</code> from <code class="literal">ID Token Encryption Key Management Algorithm</code> pulldown menu
						</li></ul></div><p>
					ID token encryption algorithms by CEK are also defined in the <a class="link" href="https://tools.ietf.org/html/rfc7518#section-5.1">JWA</a> specification. Red Hat Single Sign-On supports AES_CBC_HMAC_SHA2 algorithms and AES GCM algorithms. The detailed procedure to select this algorithm is as follows:
				</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">
							open the client’s <code class="literal">Settings</code> tab
						</li><li class="listitem">
							open <code class="literal">Advanced Settings</code>
						</li><li class="listitem">
							select the algorithm from <code class="literal">ID Token Encryption Content Encryption Algorithm</code> pulldown menu
						</li></ul></div></section><section class="section" id="client-credentials"><div class="titlepage"><div><div><h3 class="title">8.1.2. Confidential Client Credentials</h3></div></div></div><p>
					If you’ve set the client’s <a class="link" href="#access-type">access type</a> to <code class="literal">confidential</code> in the client’s <code class="literal">Settings</code> tab, a new <code class="literal">Credentials</code> tab will show up. As part of dealing with this type of client you have to configure the client’s credentials.
				</p><div class="formalpara"><p class="title"><strong>Credentials Tab</strong></p><p>
						<span class="inlinemediaobject"><img src="images/rhsso-images/client-credentials.png" alt="client credentials"/></span>
					</p></div><p>
					The <code class="literal">Client Authenticator</code> list box specifies the type of credential you are going to use for your confidential client. It defaults to client ID and secret. The secret is automatically generated for you and the <code class="literal">Regenerate Secret</code> button allows you to recreate this secret if you want or need to.
				</p><p>
					Alternatively, you can opt to use a signed Json Web Token (JWT) or x509 certificate validation (also called Mutual TLS) instead of a secret.
				</p><div class="formalpara"><p class="title"><strong>Signed JWT</strong></p><p>
						<span class="inlinemediaobject"><img src="images/rhsso-images/client-credentials-jwt.png" alt="client credentials jwt"/></span>
					</p></div><p>
					When choosing this credential type you will have to also generate a private key and certificate for the client. The private key will be used to sign the JWT, while the certificate is used by the server to verify the signature. Click on the <code class="literal">Generate new keys and certificate</code> button to start this process.
				</p><div class="formalpara"><p class="title"><strong>Generate Keys</strong></p><p>
						<span class="inlinemediaobject"><img src="images/rhsso-images/generate-client-keys.png" alt="generate client keys"/></span>
					</p></div><p>
					When you generate these keys, Red Hat Single Sign-On will store the certificate, and you’ll need to download the private key and certificate for your client to use. Pick the archive format you want and specify the password for the private key and store.
				</p><p>
					You can also opt to generate these via an external tool and just import the client’s certificate.
				</p><div class="formalpara"><p class="title"><strong>Import Certificate</strong></p><p>
						<span class="inlinemediaobject"><img src="images/rhsso-images/import-client-cert.png" alt="import client cert"/></span>
					</p></div><p>
					There are multiple formats you can import from, just choose the archive format you have the certificate stored in, select the file, and click the <code class="literal">Import</code> button.
				</p><p>
					Finally note that you don’t even need to import certificate if you choose to <code class="literal">Use JWKS URL</code> . In that case, you can provide the URL where client publishes its public key in <a class="link" href="https://self-issued.info/docs/draft-ietf-jose-json-web-key.html">JWK</a> format. This is flexible because when client changes its keys, Red Hat Single Sign-On will automatically download them without need to re-import anything on Red Hat Single Sign-On side.
				</p><p>
					If you use client secured by Red Hat Single Sign-On adapter, you can configure the JWKS URL like <a class="link" href="https://myhost.com/myapp/k_jwks">https://myhost.com/myapp/k_jwks</a> assuming that <a class="link" href="https://myhost.com/myapp">https://myhost.com/myapp</a> is the root URL of your client application. See <a class="link" href="https://access.redhat.com/documentation/en-us/red_hat_single_sign-on/7.4/html-single/server_developer_guide/">Server Developer Guide</a> for additional details.
				</p><div class="admonition warning"><div class="admonition_header">Warning</div><div><p>
						For the performance purposes, Red Hat Single Sign-On caches the public keys of the OIDC clients. If you think that private key of your client was compromised, it is obviously good to update your keys, but it’s also good to clear the keys cache. See <a class="link" href="#clear-cache" title="3.4. Clearing Server Caches">Clearing the cache</a> section for more details.
					</p></div></div><div class="formalpara"><p class="title"><strong>Signed JWT with Client Secret</strong></p><p>
						If you select this option in the <code class="literal">Client Authenticator</code> list box, you can use a JWT signed by client secret instead of the private key.
					</p></div><p>
					This client secret will be used to sign the JWT by the client.
				</p><div class="formalpara"><p class="title"><strong>X509 Certificate</strong></p><p>
						By enabling this option Red Hat Single Sign-On will validate if the client uses proper X509 certificate during the TLS Handshake.
					</p></div><div class="admonition note"><div class="admonition_header">Note</div><div><p>
						This option requires mutual TLS in Red Hat Single Sign-On, see <a class="link" href="#enable-mtls-wildfly">Enable mutual SSL in WildFly</a>.
					</p></div></div><div class="formalpara"><p class="title"><strong>X509 Certificate</strong></p><p>
						<span class="inlinemediaobject"><img src="images/rhsso-images/x509-client-auth.png" alt="x509 client auth"/></span>
					</p></div><p>
					The validator checks also the certificate’s Subject DN field with configured regexp validation expression. For some use cases, it is sufficient to accept all certificates. In that case, you can use <code class="literal">(.*?)(?:$)</code> expression.
				</p><p>
					There are two ways for Red Hat Single Sign-On to obtain the Client ID from the request. The first option is the <code class="literal">client_id</code> parameter in the query (described in Section 2.2 of the <a class="link" href="https://tools.ietf.org/html/rfc6749">OAuth 2.0 Specification</a>). The second option is to supply <code class="literal">client_id</code> as a form parameter.
				</p></section><section class="section" id="service_accounts"><div class="titlepage"><div><div><h3 class="title">8.1.3. Service Accounts</h3></div></div></div><p>
					Each OIDC client has a built-in <span class="emphasis"><em>service account</em></span> which allows it to obtain an access token. This is covered in the OAuth 2.0 specifiation under <a class="link" href="#client_credentials_grant" title="7.1.1.4. Client Credentials Grant">Client Credentials Grant</a>. To use this feature you must set the <a class="link" href="#access-type">Access Type</a> of your client to <code class="literal">confidential</code>. When you do this, the <code class="literal">Service Accounts Enabled</code> switch will appear. You need to turn on this switch. Also make sure that you have configured your <a class="link" href="#client-credentials" title="8.1.2. Confidential Client Credentials">client credentials</a>.
				</p><p>
					To use it you must have registered a valid <code class="literal">confidential</code> Client and you need to check the switch <code class="literal">Service Accounts Enabled</code> in Red Hat Single Sign-On admin console for this client. In tab <code class="literal">Service Account Roles</code> you can configure the roles available to the service account retrieved on behalf of this client. Remember that you must have the roles available in Role Scope Mappings (tab <code class="literal">Scope</code>) of this client as well, unless you have <code class="literal">Full Scope Allowed</code> on. As in a normal login, roles from access token are the intersection of:
				</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">
							Role scope mappings of particular client combined with the role scope mappings inherited from linked client scopes
						</li><li class="listitem">
							Service account roles
						</li></ul></div><p>
					The REST URL to invoke on is <code class="literal">/auth/realms/{realm-name}/protocol/openid-connect/token</code>. Invoking on this URL is a POST request and requires you to post the client credentials. By default, client credentials are represented by clientId and clientSecret of the client in <code class="literal">Authorization: Basic</code> header, but you can also authenticate the client with a signed JWT assertion or any other custom mechanism for client authentication. You also need to use the parameter <code class="literal">grant_type=client_credentials</code> as per the OAuth2 specification.
				</p><p>
					For example the POST invocation to retrieve a service account can look like this:
				</p><pre class="screen">    POST /auth/realms/demo/protocol/openid-connect/token
    Authorization: Basic cHJvZHVjdC1zYS1jbGllbnQ6cGFzc3dvcmQ=
    Content-Type: application/x-www-form-urlencoded

    grant_type=client_credentials</pre><p>
					The response would be this <a class="link" href="https://tools.ietf.org/html/rfc6749#section-4.4.3">standard JSON document</a> from the OAuth 2.0 specification.
				</p><pre class="screen">HTTP/1.1 200 OK
Content-Type: application/json;charset=UTF-8
Cache-Control: no-store
Pragma: no-cache

{
    "access_token":"2YotnFZFEjr1zCsicMWpAA",
    "token_type":"bearer",
    "expires_in":60,
    "refresh_token":"tGzv3JOkF0XG5Qx2TlKWIA",
    "refresh_expires_in":600,
    "id_token":"tGzv3JOkF0XG5Qx2TlKWIA",
    "not-before-policy":0,
    "session_state":"234234-234234-234234"
}</pre><p>
					The retrieved access token can be refreshed or logged out by an out-of-bound request.
				</p></section><section class="section" id="audience"><div class="titlepage"><div><div><h3 class="title">8.1.4. Audience Support</h3></div></div></div><p>
					The typical environment where the Red Hat Single Sign-On is deployed generally consists of a set of <span class="emphasis"><em>confidential</em></span> or <span class="emphasis"><em>public</em></span> client applications (frontend client applications) which use Red Hat Single Sign-On for authentication.
				</p><p>
					There are also <span class="emphasis"><em>services</em></span> (called <span class="emphasis"><em>Resource Servers</em></span> in the OAuth 2 specification), which serve requests from frontend client applications and provide resources. These services typically require an <span class="emphasis"><em>Access token</em></span> (Bearer token) to be sent to them to authenticate for a particular request. This token was previously obtained by the frontend application when it tries to log in against Red Hat Single Sign-On.
				</p><p>
					In the environment where the trust among services is low, you may encounter this scenario:
				</p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem">
							A frontend client called <code class="literal">my-app</code> is required to be authenticated against Red Hat Single Sign-On.
						</li><li class="listitem">
							A user is authenticated in Red Hat Single Sign-On. Red Hat Single Sign-On then issued tokens to the <code class="literal">my-app</code> application.
						</li><li class="listitem">
							The application <code class="literal">my-app</code> used the token to invoke the service <code class="literal">evil-service</code>. The application needs to invoke <code class="literal">evil-service</code> as the service is able to serve some very useful data.
						</li><li class="listitem">
							The <code class="literal">evil-service</code> application returned the response to <code class="literal">my-app</code>. However, at the same time, it kept the token previously sent to it.
						</li><li class="listitem">
							The <code class="literal">evil-service</code> application then invoked another service called <code class="literal">good-service</code> with the previously kept token. The invocation was successful and <code class="literal">good-service</code> returned the data. This results in broken security as the <code class="literal">evil-service</code> misused the token to access other services on behalf of the client <code class="literal">my-app</code>.
						</li></ol></div><p>
					This flow may not be an issue in many environments with the high level of trust among services. However in other environments, where the trust among services is lower, this can be problematic.
				</p><div class="admonition note"><div class="admonition_header">Note</div><div><p>
						In some environments, this example work flow may be even requested behavior as the <code class="literal">evil-service</code> may need to retrieve additional data from <code class="literal">good-service</code> to be able to properly return the requested data to the original caller (my-app client). You may notice similarities with the Kerberos Credential Delegation. As with the Kerberos Credential Delegation, an unlimited audience is a mixed blessing as it is only useful when a high level of trust exists among services. Otherwise, it is recommended to limit audience as described next. You can limit audience and at the same time allow the <code class="literal">evil-service</code> to retrieve required data from the <code class="literal">good-service</code>. In this case, you need to ensure that both the <code class="literal">evil-service</code> and <code class="literal">good-service</code> are added as audiences to the token.
					</p></div></div><p>
					To prevent any misuse of the access token as in the example above, it is recommended to limit <span class="emphasis"><em>Audience</em></span> on the token and configure your services to verify the audience on the token. If this is done, the flow above will change, like this:
				</p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem">
							A frontend client called <code class="literal">my-app</code> is required to be authenticated against Red Hat Single Sign-On.
						</li><li class="listitem">
							A user is authenticated in Red Hat Single Sign-On. Red Hat Single Sign-On then issued tokens to the <code class="literal">my-app</code> application. The client application already knows that it will need to invoke service <code class="literal">evil-service</code>, so it used <code class="literal">scope=evil-service</code> in the authentication request sent to the Red Hat Single Sign-On server. See <a class="link" href="#client_scopes" title="8.6. Client Scopes">Client Scopes section</a> for more details about the <span class="emphasis"><em>scope</em></span> parameter. The token issued to the <code class="literal">my-app</code> client contains the audience, as in <code class="literal">"audience": [ "evil-service" ]</code>, which declares that the client wants to use this access token to invoke just the service <code class="literal">evil-service</code>.
						</li><li class="listitem">
							The <code class="literal">evil-service</code> application served the request to the <code class="literal">my-app</code>. At the same time, it kept the token previously sent to it.
						</li><li class="listitem">
							The <code class="literal">evil-service</code> application then invoked the <code class="literal">good-service</code> with the previously kept token. Invocation was not successful because <code class="literal">good-service</code> checks the audience on the token and it sees that audience is only <code class="literal">evil-service</code>. This is expected behavior and security is not broken.
						</li></ol></div><p>
					If the client wants to invoke the <code class="literal">good-service</code> later, it will need to obtain another token by issuing the SSO login with the <code class="literal">scope=good-service</code>. The returned token will then contain <code class="literal">good-service</code> as an audience:
				</p><pre class="programlisting language-json">"audience": [ "good-service" ]</pre><p>
					and can be used to invoke <code class="literal">good-service</code>.
				</p><section class="section" id="setup_3"><div class="titlepage"><div><div><h4 class="title">8.1.4.1. Setup</h4></div></div></div><p>
						To properly set up audience checking:
					</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">
								Ensure that services are configured to check audience on the access token sent to them by adding the flag <span class="emphasis"><em>verify-token-audience</em></span> in the adapter configuration. See <a class="link" href="https://access.redhat.com/documentation/en-us/red_hat_single_sign-on/7.4/html-single/securing_applications_and_services_guide/#_java_adapter_config">Adapter configuration</a> for details.
							</li><li class="listitem">
								Ensure that when an access token is issued by Red Hat Single Sign-On, it contains all requested audiences and does not contain any audiences that are not needed. The audience can be either automatically added due the client roles as described in the <a class="link" href="#audience_resolve" title="8.1.4.2. Automatically add audience">next section</a> or it can be hardcoded as described <a class="link" href="#audience_hardcoded" title="8.1.4.3. Hardcoded audience">below</a>.
							</li></ul></div></section><section class="section" id="audience_resolve"><div class="titlepage"><div><div><h4 class="title">8.1.4.2. Automatically add audience</h4></div></div></div><p>
						In the default client scope <span class="emphasis"><em>roles</em></span>, there is an <span class="emphasis"><em>Audience Resolve</em></span> protocol mapper defined. This protocol mapper will check all the clients for which current token has at least one client role available. Then the client ID of each of those clients will be added as an audience automatically. This is especially useful if your service (usually bearer-only) clients rely on client roles.
					</p><p>
						As an example, let us assume that you have a bearer-only client <code class="literal">good-service</code> and the confidential client <code class="literal">my-app</code>, which you want to authenticate and then use the access token issued for the <code class="literal">my-app</code> to invoke the <code class="literal">good-service</code> REST service. If the following are true:
					</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">
								The <code class="literal">good-service</code> client has any client roles defined on itself
							</li><li class="listitem">
								Target user has at least one of those client roles assigned
							</li><li class="listitem">
								Client <code class="literal">my-app</code> has the role scope mappings for the assigned role
							</li></ul></div><p>
						then the <code class="literal">good-service</code> will be automatically added as an audience to the access token issued for the <code class="literal">my-app</code>.
					</p><div class="admonition note"><div class="admonition_header">Note</div><div><p>
							If you want to ensure that audience is not added automatically, do not configure role scope mappings directly on the <code class="literal">my-app</code> client, but instead create a dedicated client scope, for example called <code class="literal">good-service</code>, which will contain the role scope mappings for the client roles of the <code class="literal">good-service</code> client. Assuming that this client scope will be added as an optional client scope to the <code class="literal">my-app</code> client, the client roles and audience will be added to the token just if explicitly requested by the <code class="literal">scope=good-service</code> parameter.
						</p></div></div><div class="admonition note"><div class="admonition_header">Note</div><div><p>
							The frontend client itself is not automatically added to the access token audience. This allows for easy differentiation between the access token and the ID token, because the access token will not contain the client for which the token was issued as an audience. So in the example above, the <code class="literal">my-app</code> won’t be added as an audience. If you need the client itself as an audience, see the <a class="link" href="#audience_hardcoded" title="8.1.4.3. Hardcoded audience">hardcoded audience</a> option. However, using the same client as both frontend and REST service is not recommended.
						</p></div></div></section><section class="section" id="audience_hardcoded"><div class="titlepage"><div><div><h4 class="title">8.1.4.3. Hardcoded audience</h4></div></div></div><p>
						For the case when your service relies on realm roles or does not rely on the roles in the token at all, it can be useful to use hardcoded audience. This is a protocol mapper, which will add client ID of the specified service client as an audience to the token. You can even use any custom value, for example some URL, if you want different audience than client ID.
					</p><p>
						You can add protocol mapper directly to the frontend client, however than the audience will be always added. If you want more fine-grain control, you can create protocol mapper on the dedicated client scope, which will be called for example <code class="literal">good-service</code>.
					</p><div class="formalpara"><p class="title"><strong>Audience Protocol Mapper</strong></p><p>
							<span class="inlinemediaobject"><img src="images/rhsso-images/audience_mapper.png" alt="audience mapper"/></span>
						</p></div><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">
								From the <a class="link" href="#client_installation" title="8.5. Generating Client Adapter Config">Installation tab</a> of the <code class="literal">good-service</code> client, you can generate the adapter configuration and you can confirm that <span class="emphasis"><em>verify-token-audience</em></span> option will be set to true. This indicates that the adapter will require verifying the audience if you use this generated configuration.
							</li><li class="listitem">
								Finally, you need to ensure that the <code class="literal">my-app</code> frontend client is able to request <code class="literal">good-service</code> as an audience in its tokens. On the <code class="literal">my-app</code> client, click the <span class="emphasis"><em>Client Scopes</em></span> tab. Then assign <code class="literal">good-service</code> as an optional (or default) client scope. See <a class="link" href="#client_scopes_linking" title="8.6.3. Link Client Scope with the Client">Client Scopes Linking section</a> for more details.
							</li><li class="listitem">
								You can optionally <a class="link" href="#client_scopes_evaluate" title="8.6.4. Evaluating Client Scopes">Evaluate Client Scopes</a> and generate an example access token. If you do, notice that <code class="literal">good-service</code> will be added to the audience of the generated access token only if <code class="literal">good-service</code> is included in the <span class="emphasis"><em>scope</em></span> parameter in the case you assigned it as an optional client scope.
							</li><li class="listitem">
								In your <code class="literal">my-app</code> application, you must ensure that <span class="emphasis"><em>scope</em></span> parameter is used with the value <code class="literal">good-service</code> always included when you want to issue the token for accessing the <code class="literal">good-service</code>. See the <a class="link" href="https://access.redhat.com/documentation/en-us/red_hat_single_sign-on/7.4/html-single/securing_applications_and_services_guide/#_params_forwarding">parameters forwarding section</a>, if your application uses the servlet adapter, or the <a class="link" href="https://access.redhat.com/documentation/en-us/red_hat_single_sign-on/7.4/html-single/securing_applications_and_services_guide/#_javascript_adapter">javascript adapter section</a>, if your application uses the javascript adapter.
							</li></ul></div><div class="admonition note"><div class="admonition_header">Note</div><div><p>
							If you are unsure what the correct audience and roles in the token will be, it is always a good idea to <a class="link" href="#client_scopes_evaluate" title="8.6.4. Evaluating Client Scopes">Evaluate Client Scopes</a> in the admin console and do some testing around it.
						</p></div></div><div class="admonition note"><div class="admonition_header">Note</div><div><p>
							Both the <span class="emphasis"><em>Audience</em></span> and <span class="emphasis"><em>Audience Resolve</em></span> protocol mappers add the audiences just to the access token by default. The ID Token typically contains only single audience, which is the client ID of the client for which the token was issued. This is a requirement of the OpenID Connect specification. On the other hand, the access token does not necessarily have the client ID of the client, which was the token issued for, unless any of the audience mappers added it.
						</p></div></div></section></section></section><section class="section" id="saml_clients"><div class="titlepage"><div><div><h2 class="title">8.2. SAML Clients</h2></div></div></div><p>
				Red Hat Single Sign-On supports <a class="link" href="#saml" title="7.2. SAML">SAML 2.0</a> for registered applications. Both POST and Redirect bindings are supported. You can choose to require client signature validation and can have the server sign and/or encrypt responses as well.
			</p><p>
				To create a SAML client go to the <code class="literal">Clients</code> left menu item. On this page you’ll see a <code class="literal">Create</code> button on the right.
			</p><div class="formalpara"><p class="title"><strong>Clients</strong></p><p>
					<span class="inlinemediaobject"><img src="images/rhsso-images/clients.png" alt="clients"/></span>
				</p></div><p>
				This will bring you to the <code class="literal">Add Client</code> page.
			</p><div class="formalpara"><p class="title"><strong>Add Client</strong></p><p>
					<span class="inlinemediaobject"><img src="images/rhsso-images/add-client-saml.png" alt="add client saml"/></span>
				</p></div><p>
				Enter in the <code class="literal">Client ID</code> of the client. This is often a URL and will be the expected <code class="literal">issuer</code> value in SAML requests sent by the application. Next select <code class="literal">saml</code> in the <code class="literal">Client Protocol</code> drop down box. Finally enter in the <code class="literal">Client SAML Endpoint</code> URL. Enter the URL you want the Red Hat Single Sign-On server to send SAML requests and responses to. Usually applications have only one URL for processing SAML requests. If your application has different URLs for its bindings, don’t worry, you can fix this in the <code class="literal">Settings</code> tab of the client. Click <code class="literal">Save</code>. This will create the client and bring you to the client <code class="literal">Settings</code> tab.
			</p><div class="formalpara"><p class="title"><strong>Client Settings</strong></p><p>
					<span class="inlinemediaobject"><img src="images/rhsso-images/client-settings-saml.png" alt="client settings saml"/></span>
				</p></div><div class="variablelist"><dl class="variablelist"><dt><span class="term">Client ID</span></dt><dd>
							This value must match the issuer value sent with AuthNRequests. Red Hat Single Sign-On will pull the issuer from the Authn SAML request and match it to a client by this value.
						</dd><dt><span class="term">Name</span></dt><dd>
							This is the display name for the client whenever it is displayed in a Red Hat Single Sign-On UI screen. You can localize the value of this field by setting up a replacement string value i.e. ${myapp}. See the <a class="link" href="https://access.redhat.com/documentation/en-us/red_hat_single_sign-on/7.4/html-single/server_developer_guide/">Server Developer Guide</a> for more information.
						</dd><dt><span class="term">Description</span></dt><dd>
							This specifies the description of the client. This can also be localized.
						</dd><dt><span class="term">Enabled</span></dt><dd>
							If this is turned off, the client will not be allowed to request authentication.
						</dd><dt><span class="term">Consent Required</span></dt><dd>
							If this is on, then users will get a consent page which asks the user if they grant access to that application. It will also display the metadata that the client is interested in so that the user knows exactly what information the client is getting access to. If you’ve ever done a social login to Google, you’ll often see a similar page. Red Hat Single Sign-On provides the same functionality.
						</dd><dt><span class="term">Include AuthnStatement</span></dt><dd>
							SAML login responses may specify the authentication method used (password, etc.) as well as timestamps of the login and the session expiration. This is enabled by default, which means that <code class="literal">AuthStatement</code> element will be included in login responses. Note that setting this to off would prevent the client from determining the maximum session length which could result into never expiring client session.
						</dd><dt><span class="term">Sign Documents</span></dt><dd>
							When turned on, Red Hat Single Sign-On will sign the document using the realm’s private key.
						</dd><dt><span class="term">Optimize REDIRECT signing key lookup</span></dt><dd>
							When turned on, the SAML protocol messages will include Red Hat Single Sign-On native extension that contains a hint with signing key ID. When the SP understands this extension, it can use it for signature validation instead of attempting to validate signature with all known keys. This option only applies to REDIRECT bindings where the signature is transferred in query parameters where there is no place with this information in the signature information (contrary to POST binding messages where key ID is always included in document signature). Currently this is relevant to situations where both IDP and SP are provided by Red Hat Single Sign-On server and adapter. This option is only relevant when <code class="literal">Sign Documents</code> is switched on.
						</dd><dt><span class="term">Sign Assertions</span></dt><dd>
							The <code class="literal">Sign Documents</code> switch signs the whole document. With this setting the assertion is also signed and embedded within the SAML XML Auth response.
						</dd><dt><span class="term">Signature Algorithm</span></dt><dd>
							Choose between a variety of algorithms for signing SAML documents.
						</dd><dt><span class="term">SAML Signature Key Name</span></dt><dd>
							Signed SAML documents sent via POST binding contain identification of signing key in <code class="literal">KeyName</code> element. This by default contains Red Hat Single Sign-On key ID. However various vendors might expect a different key name or no key name at all. This switch controls whether <code class="literal">KeyName</code> contains key ID (option <code class="literal">KEY_ID</code>), subject from certificate corresponding to the realm key (option <code class="literal">CERT_SUBJECT</code> - expected for instance by Microsoft Active Directory Federation Services), or that the key name hint is completely omitted from the SAML message (option <code class="literal">NONE</code>).
						</dd><dt><span class="term">Canonicalization Method</span></dt><dd>
							Canonicalization method for XML signatures.
						</dd><dt><span class="term">Encrypt Assertions</span></dt><dd>
							Encrypt assertions in SAML documents with the realm’s private key. The AES algorithm is used with a key size of 128 bits.
						</dd><dt><span class="term">Client Signature Required</span></dt><dd>
							Expect that documents coming from a client are signed. Red Hat Single Sign-On will validate this signature using the client public key or cert set up in the <code class="literal">SAML Keys</code> tab.
						</dd><dt><span class="term">Force POST Binding</span></dt><dd>
							By default, Red Hat Single Sign-On will respond using the initial SAML binding of the original request. By turning on this switch, you will force Red Hat Single Sign-On to always respond using the SAML POST Binding even if the original request was the Redirect binding.
						</dd><dt><span class="term">Front Channel Logout</span></dt><dd>
							If true, this application requires a browser redirect to be able to perform a logout. For example, the application may require a cookie to be reset which could only be done via a redirect. If this switch is false, then Red Hat Single Sign-On will invoke a background SAML request to logout the application.
						</dd><dt><span class="term">Force Name ID Format</span></dt><dd>
							If the request has a name ID policy, ignore it and used the value configured in the admin console under Name ID Format
						</dd><dt><span class="term">Name ID Format</span></dt><dd>
							Name ID Format for the subject. If no name ID policy is specified in the request or if the Force Name ID Format attribute is true, this value is used. Properties used for each of the respective formats are defined below.
						</dd><dt><span class="term">Root URL</span></dt><dd>
							If Red Hat Single Sign-On uses any configured relative URLs, this value is prepended to them.
						</dd><dt><span class="term">Valid Redirect URIs</span></dt><dd>
							This is an optional field. Enter in a URL pattern and click the + sign to add. Click the - sign next to URLs you want to remove. Remember that you still have to click the <code class="literal">Save</code> button! Wildcards (*) are only allowed at the end of a URI, i.e. http://host.com/*. This field is used when the exact SAML endpoints are not registered and Red Hat Single Sign-On is pulling the Assertion Consumer URL from the request.
						</dd><dt><span class="term">Base URL</span></dt><dd>
							If Red Hat Single Sign-On needs to link to the client, this URL would be used.
						</dd><dt><span class="term">Master SAML Processing URL</span></dt><dd>
							This URL will be used for all SAML requests and the response will be directed to the SP. It will be used as the Assertion Consumer Service URL and the Single Logout Service URL. If a login request contains the Assertion Consumer Service URL, that will take precedence, but this URL must be validated by a registered Valid Redirect URI pattern
						</dd><dt><span class="term">Assertion Consumer Service POST Binding URL</span></dt><dd>
							POST Binding URL for the Assertion Consumer Service.
						</dd><dt><span class="term">Assertion Consumer Service Redirect Binding URL</span></dt><dd>
							Redirect Binding URL for the Assertion Consumer Service.
						</dd><dt><span class="term">Logout Service POST Binding URL</span></dt><dd>
							POST Binding URL for the Logout Service.
						</dd><dt><span class="term">Logout Service Redirect Binding URL</span></dt><dd>
							Redirect Binding URL for the Logout Service.
						</dd></dl></div><section class="section" id="idp_initiated_login"><div class="titlepage"><div><div><h3 class="title">8.2.1. IDP Initiated Login</h3></div></div></div><p>
					IDP Initiated Login is a feature that allows you to set up an endpoint on the Red Hat Single Sign-On server that will log you into a specific application/client. In the <code class="literal">Settings</code> tab for your client, you need to specify the <code class="literal">IDP Initiated SSO URL Name</code>. This is a simple string with no whitespace in it. After this you can reference your client at the following URL: <code class="literal">root/auth/realms/{realm}/protocol/saml/clients/{url-name}</code>
				</p><p>
					The IDP initiated login implementation prefers <span class="emphasis"><em>POST</em></span> over <span class="emphasis"><em>REDIRECT</em></span> binding (check <a class="link" href="#saml" title="7.2. SAML">saml bindings</a> for more information). Therefore the final binding and SP URL are selected in the following way:
				</p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem">
							If the specific <code class="literal">Assertion Consumer Service POST Binding URL</code> is defined (inside <code class="literal">Fine Grain SAML Endpoint Configuration</code> section of the client settings) <span class="emphasis"><em>POST</em></span> binding is used through that URL.
						</li><li class="listitem">
							If the general <code class="literal">Master SAML Processing URL</code> is specified then <span class="emphasis"><em>POST</em></span> binding is used again throught this general URL.
						</li><li class="listitem">
							As the last resort, if the <code class="literal">Assertion Consumer Service Redirect Binding URL</code> is configured (inside <code class="literal">Fine Grain SAML Endpoint Configuration</code>) <span class="emphasis"><em>REDIRECT</em></span> binding is used with this URL.
						</li></ol></div><p>
					If your client requires a special relay state, you can also configure this on the <code class="literal">Settings</code> tab in the <code class="literal">IDP Initiated SSO Relay State</code> field. Alternatively, browsers can specify the relay state in a <code class="literal">RelayState</code> query parameter, i.e. <code class="literal">root/auth/realms/{realm}/protocol/saml/clients/{url-name}?RelayState=thestate</code>.
				</p><p>
					When using <a class="link" href="#identity_broker" title="Chapter 12. Identity Brokering">identity brokering</a>, it is possible to set up an IDP Initiated Login for a client from an external IDP. The actual client is set up for IDP Initiated Login at broker IDP as described above. The external IDP has to set up the client for application IDP Initiated Login that will point to a special URL pointing to the broker and representing IDP Initiated Login endpoint for a selected client at the brokering IDP. This means that in client settings at the external IDP:
				</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">
							<code class="literal">IDP Initiated SSO URL Name</code> is set to a name that will be published as IDP Initiated Login initial point,
						</li><li class="listitem"><p class="simpara">
							<code class="literal">Assertion Consumer Service POST Binding URL</code> in the <code class="literal">Fine Grain SAML Endpoint Configuration</code> section has to be set to the following URL: <code class="literal">broker-root/auth/realms/{broker-realm}/broker/{idp-name}/endpoint/clients/{client-id}</code>, where:
						</p><div class="itemizedlist"><ul class="itemizedlist" type="circle"><li class="listitem">
									<span class="emphasis"><em>broker-root</em></span> is base broker URL
								</li><li class="listitem">
									<span class="emphasis"><em>broker-realm</em></span> is name of the realm at broker where external IDP is declared
								</li><li class="listitem">
									<span class="emphasis"><em>idp-name</em></span> is name of the external IDP at broker
								</li><li class="listitem">
									<span class="emphasis"><em>client-id</em></span> is the value of <code class="literal">IDP Initiated SSO URL Name</code> attribute of the SAML client defined at broker. It is this client, which will be made available for IDP Initiated Login from the external IDP.
								</li></ul></div></li></ul></div><p>
					Please note that you can import basic client settings from the brokering IDP into client settings of the external IDP - just use <a class="link" href="#identity_broker_saml_sp_descriptor" title="12.6.1. SP Descriptor">SP Descriptor</a> available from the settings of the identity provider in the brokering IDP, and add <code class="literal">clients/<span class="emphasis"><em>client-id</em></span></code> to the endpoint URL.
				</p></section><section class="section" id="saml_entity_descriptors"><div class="titlepage"><div><div><h3 class="title">8.2.2. SAML Entity Descriptors</h3></div></div></div><p>
					Instead of manually registering a SAML 2.0 client, you can import it via a standard SAML Entity Descriptor XML file. There is an <code class="literal">Import</code> option on the Add Client page.
				</p><div class="formalpara"><p class="title"><strong>Add Client</strong></p><p>
						<span class="inlinemediaobject"><img src="images/rhsso-images/add-client-saml.png" alt="add client saml"/></span>
					</p></div><p>
					Click the <code class="literal">Select File</code> button and load your entity descriptor file. You should review all the information there to make sure everything is set up correctly.
				</p><p>
					Some SAML client adapters like <span class="emphasis"><em>mod-auth-mellon</em></span> need the XML Entity Descriptor for the IDP. You can obtain this by going to this public URL: <code class="literal">root/auth/realms/{realm}/protocol/saml/descriptor</code>
				</p></section></section><section class="section" id="client_links"><div class="titlepage"><div><div><h2 class="title">8.3. Client Links</h2></div></div></div><p>
				For scenarios where one wants to link from one client to another, Red Hat Single Sign-On provides a special redirect endpoint: <code class="literal">/realms/realm_name/clients/{client-id}/redirect</code>.
			</p><p>
				If a client accesses this endpoint via an <code class="literal">HTTP GET</code> request, Red Hat Single Sign-On returns the configured base URL for the provided Client and Realm in the form of an <code class="literal">HTTP 307</code> (Temporary Redirect) via the response’s <code class="literal">Location</code> header.
			</p><p>
				Thus, a client only needs to know the Realm name and the Client ID in order to link to them. This indirection helps avoid hard-coding client base URLs.
			</p><p>
				As an example, given the realm <code class="literal">master</code> and the client-id <code class="literal">account</code>:
			</p><pre class="screen">http://host:port/auth/realms/master/clients/account/redirect</pre><p>
				Would temporarily redirect to: <a class="link" href="http://host:port/auth/realms/master/account">http://host:port/auth/realms/master/account</a>
			</p></section><section class="section" id="protocol-mappers"><div class="titlepage"><div><div><h2 class="title">8.4. OIDC Token and SAML Assertion Mappings</h2></div></div></div><p>
				Applications that receive ID Tokens, Access Tokens, or SAML assertions may need or want different user metadata and roles. Red Hat Single Sign-On allows you to define what exactly is transferred. You can hardcode roles, claims and custom attributes. You can pull user metadata into a token or assertion. You can rename roles. Basically you have a lot of control of what exactly goes back to the client.
			</p><p>
				Within the Admin Console, if you go to an application you’ve registered, you’ll see a <code class="literal">Mappers</code> tab. Here’s one for an OIDC based client.
			</p><div class="formalpara"><p class="title"><strong>Mappers Tab</strong></p><p>
					<span class="inlinemediaobject"><img src="images/rhsso-images/mappers-oidc.png" alt="mappers oidc"/></span>
				</p></div><p>
				The new client does not have any built-in mappers, however it usually inherits some mappers from the client scopes as described in the <a class="link" href="#client_scopes" title="8.6. Client Scopes">client scopes section</a>. Protocol mappers map things like, for example, email address to a specific claim in the identity and access token. Their function should each be self explanatory from their name. There are additional pre-configured mappers that are not attached to the client that you can add by clicking the <code class="literal">Add Builtin</code> button.
			</p><p>
				Each mapper has common settings as well as additional ones depending on which type of mapper you are adding. Click the <code class="literal">Edit</code> button next to one of the mappers in the list to get to the config screen.
			</p><div class="formalpara"><p class="title"><strong>Mapper Config</strong></p><p>
					<span class="inlinemediaobject"><img src="images/rhsso-images/mapper-config.png" alt="mapper config"/></span>
				</p></div><p>
				The best way to learn about a config option is to hover over its tooltip.
			</p><p>
				Most OIDC mappers also allow you to control where the claim gets put. You can opt to include or exclude the claim from both the <span class="emphasis"><em>id</em></span> and <span class="emphasis"><em>access</em></span> tokens by fiddling with the <code class="literal">Add to ID token</code> and <code class="literal">Add to access token</code> switches.
			</p><p>
				Finally, you can also add other mapper types. If you go back to the <code class="literal">Mappers</code> tab, click the <code class="literal">Create</code> button.
			</p><div class="formalpara"><p class="title"><strong>Add Mapper</strong></p><p>
					<span class="inlinemediaobject"><img src="images/rhsso-images/add-mapper.png" alt="add mapper"/></span>
				</p></div><p>
				Pick a <code class="literal">Mapper Type</code> from the list box. If you hover over the tooltip, you’ll see a description of what that mapper type does. Different config parameters will appear for different mapper types.
			</p><section class="section" id="priority_order"><div class="titlepage"><div><div><h3 class="title">8.4.1. Priority order</h3></div></div></div><p>
					Mapper implementations have <span class="emphasis"><em>priority order</em></span>. This priority order is not the configuration property of the mapper; rather, it is the property of the concrete implementation of the mapper.
				</p><p>
					Mappers are sorted in the admin console by the order in the list of mappers and the changes in the token or assertion will be applied using that order with the lowest being applied first. This means that implementations which are dependent on other implementations are processed in the needed order.
				</p><p>
					For example, when we first want to compute the roles which will be included with a token, we first resolve audiences based on those roles. Then, we process a JavaScript script that uses the roles and audiences already available in the token.
				</p></section><section class="section" id="protocol-mappers_oidc-user-session-note-mappers"><div class="titlepage"><div><div><h3 class="title">8.4.2. OIDC User Session Note Mappers</h3></div></div></div><p>
					User session details are via mappers and depend on various criteria. User session details are automatically included when you use or enable a feature on a client. You can also click the <code class="literal">Add builtin</code> button to include session details.
				</p><p>
					Impersonated user sessions provide the following details:
				</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">
							<code class="literal">IMPERSONATOR_ID</code>: The ID of an impersonating user
						</li><li class="listitem">
							<code class="literal">IMPERSONATOR_USERNAME</code>: The username of an impersonating user
						</li></ul></div><p>
					Service account sessions provide the following details:
				</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">
							<code class="literal">clientId</code>: The client ID of the service account
						</li><li class="listitem">
							<code class="literal">clientAddress</code>: The remote host IP of the service account authenticated device
						</li><li class="listitem">
							<code class="literal">clientHost</code>: The remote host name of the service account authenticated device
						</li></ul></div></section><section class="section" id="script_mapper"><div class="titlepage"><div><div><h3 class="title">8.4.3. Script Mapper</h3></div></div></div><p>
					The <code class="literal">Script Mapper</code> allows you to map claims to tokens by running a user-defined JavaScript code. For more details about how to deploy scripts to the server, please take a look at <a class="link" href="https://access.redhat.com/documentation/en-us/red_hat_single_sign-on/7.4/html-single/server_developer_guide/#_script_providers">JavaScript Providers</a>.
				</p><p>
					Once you have your scripts deployed, you should be able to select the scripts you deployed from the list of available mappers.
				</p></section></section><section class="section" id="client_installation"><div class="titlepage"><div><div><h2 class="title">8.5. Generating Client Adapter Config</h2></div></div></div><p>
				The Red Hat Single Sign-On can pre-generate configuration files that you can use to install a client adapter for in your application’s deployment environment. A number of adapter types are supported for both OIDC and SAML. Go to the <code class="literal">Installation</code> tab of the client you want to generate configuration for.
			</p><p>
				<span class="inlinemediaobject"><img src="images/rhsso-images/client-installation.png" alt="client installation"/></span>
			</p><p>
				Select the <code class="literal">Format Option</code> you want configuration generated for. All Red Hat Single Sign-On client adapters for OIDC and SAML are supported. The mod-auth-mellon Apache HTTPD adapter for SAML is supported as well as standard SAML entity descriptor files.
			</p></section><section class="section" id="client_scopes"><div class="titlepage"><div><div><h2 class="title">8.6. Client Scopes</h2></div></div></div><p>
				If you have many applications you need to secure and register within your organization, it can become tedious to configure the <a class="link" href="#protocol-mappers" title="8.4. OIDC Token and SAML Assertion Mappings">protocol mappers</a> and <a class="link" href="#role_scope_mappings" title="9.5. Role Scope Mappings">role scope mappings</a> for each of these clients. Red Hat Single Sign-On allows you to define a shared client configuration in an entity called a <span class="emphasis"><em>client scope</em></span>.
			</p><p>
				Client scopes also provide support for the OAuth 2 <code class="literal">scope</code> parameter, which allows a client application to request more or fewer claims or roles in the access token, according to the application needs.
			</p><p>
				To create a client scope, follow these steps:
			</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">
						Go to the <code class="literal">Client Scopes</code> left menu item. This initial screen shows you a list of currently defined client scopes.
					</li></ul></div><div class="formalpara"><p class="title"><strong>Client Scopes List</strong></p><p>
					<span class="inlinemediaobject"><img src="images/rhsso-images/client-scopes-list.png" alt="client scopes list"/></span>
				</p></div><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">
						Click the <code class="literal">Create</code> button. Name the client scope and save. A <span class="emphasis"><em>client scope</em></span> will have similar tabs to a regular clients. You can define <a class="link" href="#protocol-mappers" title="8.4. OIDC Token and SAML Assertion Mappings">protocol mappers</a> and <a class="link" href="#role_scope_mappings" title="9.5. Role Scope Mappings">role scope mappings</a>, which can be inherited by other clients, and which are configured to inherit from this client scope.
					</li></ul></div><section class="section" id="protocol"><div class="titlepage"><div><div><h3 class="title">8.6.1. Protocol</h3></div></div></div><p>
					When you are creating the client scope, you must choose the <code class="literal">Protocol</code>. Only the clients which use same protocol can then be linked with this client scope.
				</p><p>
					Once you have created new realm, you can see that there is a list of pre-defined (builtin) client scopes in the menu.
				</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">
							For the SAML protocol, there is one builtin client scope, <code class="literal">roles_list</code>, which contains one protocol mapper for showing the roles list in the SAML assertion.
						</li><li class="listitem">
							For the OpenID Connect protocol, there are client scopes <code class="literal">profile</code>, <code class="literal">email</code>, <code class="literal">address</code>, <code class="literal">phone</code>, <code class="literal">offline_access</code>, <code class="literal">roles</code>, <code class="literal">web-origins</code> and <code class="literal">microprofile-jwt</code>.
						</li></ul></div><p>
					The client scope, <code class="literal">offline_access</code>, is useful when client wants to obtain offline tokens. Learn about offline tokens in the <a class="link" href="#offline-access" title="13.4. Offline Access">Offline Access section</a> or in the <a class="link" href="https://openid.net/specs/openid-connect-core-1_0.html#OfflineAccess">OpenID Connect specification</a>, where scope parameter is defined with the value <code class="literal">offline_access</code>.
				</p><p>
					The client scopes <code class="literal">profile</code>, <code class="literal">email</code>, <code class="literal">address</code> and <code class="literal">phone</code> are also defined in the <a class="link" href="https://openid.net/specs/openid-connect-core-1_0.html#ScopeClaims">OpenID Connect specification</a>. These client scopes do not have any role scope mappings defined, but they have some protocol mappers defined, and these mappers correspond to the claims defined in the OpenID Connect specification.
				</p><p>
					For example, when you click to open the <code class="literal">phone</code> client scope and open the <code class="literal">Mappers</code> tab, you will see the protocol mappers, which correspond to the claims defined in the specification for the scope <code class="literal">phone</code>.
				</p><div class="formalpara"><p class="title"><strong>Client Scope Mappers</strong></p><p>
						<span class="inlinemediaobject"><img src="images/rhsso-images/client-scopes-phone.png" alt="client scopes phone"/></span>
					</p></div><p>
					When the <code class="literal">phone</code> client scope is linked to a client, that client automatically inherits all the protocol mappers defined in the <code class="literal">phone</code> client scope. Access tokens issued for this client will contain the phone number information about the user, assuming that the user has a defined phone number.
				</p><p>
					Builtin client scopes contain exactly the protocol mappers as defined per the specification, however you are free to edit client scopes and create/update/remove any protocol mappers (or role scope mappings).
				</p><p>
					The client scope <code class="literal">roles</code> is not defined in the OpenID Connect specification and it is also not added automatically to the <code class="literal">scope</code> claim in the access token. This client scope has some mappers, which are used to add roles of the user to the access token and possibly add some audiences for the clients with at least one client role as described in the <a class="link" href="#audience_resolve" title="8.1.4.2. Automatically add audience">Audience section</a>.
				</p><p>
					The client scope <code class="literal">web-origins</code> is also not defined in the OpenID Connect specification and not added to the <code class="literal">scope</code> claim. This is used to add allowed web origins to the access token <code class="literal">allowed-origins</code> claim.
				</p><p>
					The client scope <code class="literal">microprofile-jwt</code> was created to handle the claims defined in the <a class="link" href="https://wiki.eclipse.org/MicroProfile/JWT_Auth">MicroProfile/JWT Auth Specification</a>. This client scope defines a user property mapper for the <code class="literal">upn</code> claim and also a realm role mapper for the <code class="literal">groups</code> claim. These mappers can be changed as needed so that different properties can be used to create the MicroProfile/JWT specific claims.
				</p></section><section class="section" id="consent_related_settings"><div class="titlepage"><div><div><h3 class="title">8.6.2. Consent related settings</h3></div></div></div><p>
					Client scope contains options related to the consent screen. Those options are useful only if the linked client is configured to require consent (if the <code class="literal">Consent Required</code> switch is enabled on the client).
				</p><div class="variablelist"><dl class="variablelist"><dt><span class="term">Display On Consent Screen</span></dt><dd>
								If on, and if this client scope is added to a client with consent required, then the text specified by <code class="literal">Consent Screen Text</code> will be displayed on the consent screen, which is shown once the user is authenticated and right before he is redirected from Red Hat Single Sign-On to the client. If the switch is off, then this client scope will not be displayed on the consent screen.
							</dd><dt><span class="term">Consent Screen Text</span></dt><dd>
								The text shown on the consent screen when this client scope is added to some client with consent required defaults to the name of client scope. The value for this text is localizable by specifying a substitution variable with <code class="literal">${var-name}</code> strings. The localized value is then configured within property files in your theme. See the <a class="link" href="https://access.redhat.com/documentation/en-us/red_hat_single_sign-on/7.4/html-single/server_developer_guide/">Server Developer Guide</a> for more information on localization.
							</dd></dl></div></section><section class="section" id="client_scopes_linking"><div class="titlepage"><div><div><h3 class="title">8.6.3. Link Client Scope with the Client</h3></div></div></div><p>
					Linking between client scope and client is configured in the <code class="literal">Client Scopes</code> tab of the particular client. There are 2 ways of linking between client scope and client.
				</p><div class="variablelist"><dl class="variablelist"><dt><span class="term">Default Client Scopes</span></dt><dd>
								This is applicable for both OpenID Connect and SAML clients. Default client scopes are always applied when issuing OpenID Connect tokens or SAML assertions for this client. The client will inherit Protocol mappers and Role Scope Mappings defined on the client scope. For the OpenID Connect Protocol, the Mappers and Role Scope Mappings are always applied, regardless of the value used for the scope parameter in the OpenID Connect authorization request.
							</dd><dt><span class="term">Optional Client Scopes</span></dt><dd>
								This is applicable only for OpenID Connect clients. Optional client scopes are applied when issuing tokens for this client, but only when they are requested by the <code class="literal">scope</code> parameter in the OpenID Connect authorization request.
							</dd></dl></div><section class="section" id="example"><div class="titlepage"><div><div><h4 class="title">8.6.3.1. Example</h4></div></div></div><p>
						For this example, we assume that the client has <code class="literal">profile</code> and <code class="literal">email</code> linked as default client scopes, and <code class="literal">phone</code> and <code class="literal">address</code> are linked as optional client scopes. The client will use the value of the scope parameter when sending a request to the OpenID Connect authorization endpoint:
					</p><pre class="screen">scope=openid phone</pre><p>
						The scope parameter contains the string, with the scope values divided by space (which is also the reason why a client scope name cannot contain a space character in it). The value <code class="literal">openid</code> is the meta-value used for all OpenID Connect requests, so we will ignore it for this example. The token will contain mappers and role scope mappings from the client scopes <code class="literal">profile</code>, <code class="literal">email</code> (which are default scopes) and <code class="literal">phone</code> (an optional client scope requested by the scope parameter).
					</p></section></section><section class="section" id="client_scopes_evaluate"><div class="titlepage"><div><div><h3 class="title">8.6.4. Evaluating Client Scopes</h3></div></div></div><p>
					The tabs <code class="literal">Mappers</code> and <code class="literal">Scope</code> of the client contain the protocol mappers and role scope mappings declared solely for this client. They do not contain the mappers and scope mappings inherited from client scopes. However, it may be useful to see what the effective protocol mappers will be (protocol mappers defined on the client itself as well as inherited from the linked client scopes) and the effective role scope mappings used when you generate the token for the particular client.
				</p><p>
					You can see all of these when you click the <code class="literal">Client Scopes</code> tab for the client and then open the sub-tab <code class="literal">Evaluate</code>. From here you can select the optional client scopes that you want to apply. This will also show you the value of the <code class="literal">scope</code> parameter, which needs to be sent from the application to the Red Hat Single Sign-On OpenID Connect authorization endpoint.
				</p><div class="formalpara"><p class="title"><strong>Evaluating Client Scopes</strong></p><p>
						<span class="inlinemediaobject"><img src="images/rhsso-images/client-scopes-evaluate.png" alt="client scopes evaluate"/></span>
					</p></div><div class="admonition note"><div class="admonition_header">Note</div><div><p>
						If you want to see how you can send a custom value for a <code class="literal">scope</code> parameter from your application, see the <a class="link" href="https://access.redhat.com/documentation/en-us/red_hat_single_sign-on/7.4/html-single/securing_applications_and_services_guide/#_params_forwarding">parameters forwarding section</a>, if your application uses the servlet adapter, or the <a class="link" href="https://access.redhat.com/documentation/en-us/red_hat_single_sign-on/7.4/html-single/securing_applications_and_services_guide/#_javascript_adapter">javascript adapter section</a>, if your application uses the javascript adapter.
					</p></div></div><section class="section" id="generating_example_tokens"><div class="titlepage"><div><div><h4 class="title">8.6.4.1. Generating Example Tokens</h4></div></div></div><p>
						To see an example of a real access token, generated for the particular user and issued for the particular client, with the specified value of <code class="literal">scope</code> parameter, select the user from the <code class="literal">Evaluate</code> screen. This will generate an example token that includes all of the claims and role mappings used.
					</p></section></section><section class="section" id="client_scopes_permissions"><div class="titlepage"><div><div><h3 class="title">8.6.5. Client Scopes Permissions</h3></div></div></div><p>
					When issuing tokens for a particular user, the client scope is applied only if the user is permitted to use it. In the case that a client scope does not have any role scope mappings defined on itself, then each user is automatically permitted to use this client scope. However, when a client scope has any role scope mappings defined on itself, then the user must be a member of at least one of the roles. In other words, there must be an intersection between the user roles and the roles of the client scope. Composite roles are taken into account when evaluating this intersection.
				</p><p>
					If a user is not permitted to use the client scope, then no protocol mappers or role scope mappings will be used when generating tokens and the client scope will not appear in the <span class="emphasis"><em>scope</em></span> value in the token.
				</p></section><section class="section" id="realm_default_client_scopes"><div class="titlepage"><div><div><h3 class="title">8.6.6. Realm Default Client Scopes</h3></div></div></div><p>
					The <code class="literal">Realm Default Client Scopes</code> allow you to define set of client scopes, which will be automatically linked to newly created clients.
				</p><p>
					Open the left menu item <code class="literal">Client Scopes</code> and then select <code class="literal">Default Client Scopes</code>.
				</p><p>
					From here, select the client scopes that you want to add as <code class="literal">Default Client Scopes</code> to newly created clients and <code class="literal">Optional Client Scopes</code> to newly created clients.
				</p><div class="formalpara"><p class="title"><strong>Default Client Scopes</strong></p><p>
						<span class="inlinemediaobject"><img src="images/rhsso-images/client-scopes-default.png" alt="client scopes default"/></span>
					</p></div><p>
					Once the client is created, you can unlink the default client scopes, if needed. This is similar to how you remove <a class="link" href="#default_roles" title="9.4.1. Default Roles">Default Roles</a>.
				</p></section><section class="section" id="scopes_explained"><div class="titlepage"><div><div><h3 class="title">8.6.7. Scopes explained</h3></div></div></div><p>
					The term <code class="literal">scope</code> is used in Red Hat Single Sign-On on few places. Various occurrences of scopes are related to each other, but may have a different context and meaning. To clarify, here we explain the various <code class="literal">scopes</code> used in Red Hat Single Sign-On.
				</p><div class="variablelist"><dl class="variablelist"><dt><span class="term">Client scope</span></dt><dd>
								Referenced in this chapter. Client scopes are entities in Red Hat Single Sign-On, which are configured at the realm level and they can be linked to clients. The client scopes are referenced by their name when a request is sent to the Red Hat Single Sign-On authorization endpoint with a corresponding value of the <code class="literal">scope</code> parameter. The details are described in the <a class="link" href="#client_scopes_linking" title="8.6.3. Link Client Scope with the Client">section about client scopes linking</a>.
							</dd><dt><span class="term">Role scope mapping</span></dt><dd>
								This can be seen when you open tab <code class="literal">Scope</code> of a client or client scope. Role scope mapping allows you to limit the roles which can be used in the access tokens. The details are described in the <a class="link" href="#role_scope_mappings" title="9.5. Role Scope Mappings">Role Scope Mappings section</a>.
							</dd></dl></div></section></section></section><section class="chapter" id="roles"><div class="titlepage"><div><div><h1 class="title">Chapter 9. Roles</h1></div></div></div><p>
			Roles identify a type or category of user. <code class="literal">Admin</code>, <code class="literal">user</code>, <code class="literal">manager</code>, and <code class="literal">employee</code> are all typical roles that may exist in an organization. Applications often assign access and permissions to specific roles rather than individual users as dealing with users can be too fine grained and hard to manage. For example, the Admin Console has specific roles which give permission to users to access parts of the Admin Console UI and perform certain actions. There is a global namespace for roles and each client also has its own dedicated namespace where roles can be defined.
		</p><section class="section" id="realm_roles"><div class="titlepage"><div><div><h2 class="title">9.1. Realm Roles</h2></div></div></div><p>
				Realm-level roles are a global namespace to define your roles. You can see the list of built-in and created roles by clicking the <code class="literal">Roles</code> left menu item.
			</p><p>
				<span class="inlinemediaobject"><img src="images/rhsso-images/roles.png" alt="roles"/></span>
			</p><p>
				To create a role, click <span class="strong strong"><strong>Add Role</strong></span> on this page, enter in the name and description of the role, and click <span class="strong strong"><strong>Save</strong></span>.
			</p><div class="formalpara"><p class="title"><strong>Add Role</strong></p><p>
					<span class="inlinemediaobject"><img src="images/rhsso-images/role.png" alt="role"/></span>
				</p></div><p>
				The value for the <code class="literal">description</code> field is localizable by specifying a substitution variable with <code class="literal">${var-name}</code> strings. The localized value is then configured within property files in your theme. See the <a class="link" href="https://access.redhat.com/documentation/en-us/red_hat_single_sign-on/7.4/html-single/server_developer_guide/">Server Developer Guide</a> for more information on localization.
			</p></section><section class="section" id="client_roles"><div class="titlepage"><div><div><h2 class="title">9.2. Client Roles</h2></div></div></div><p>
				Client roles are basically a namespace dedicated to a client. Each client gets its own namespace. Client roles are managed under the <code class="literal">Roles</code> tab under each individual client. You interact with this UI the same way you do for realm-level roles.
			</p></section><section class="section" id="composite-roles"><div class="titlepage"><div><div><h2 class="title">9.3. Composite Roles</h2></div></div></div><p>
				Any realm or client level role can be turned into a <span class="emphasis"><em>composite role</em></span>. A <span class="emphasis"><em>composite role</em></span> is a role that has one or more additional roles associated with it. When a composite role is mapped to the user, the user also gains the roles associated with that composite. This inheritance is recursive so any composite of composites also gets inherited.
			</p><p>
				To turn a regular role into a composite role, go to the role detail page and flip the <code class="literal">Composite Role</code> switch on.
			</p><div class="formalpara"><p class="title"><strong>Composite Role</strong></p><p>
					<span class="inlinemediaobject"><img src="images/rhsso-images/composite-role.png" alt="composite role"/></span>
				</p></div><p>
				Once you flip this switch the role selection UI will be displayed lower on the page and you’ll be able to associate realm level and client level roles to the composite you are creating. In this example, the <code class="literal">employee</code> realm-level role was associated with the <code class="literal">developer</code> composite role. Any user with the <code class="literal">developer</code> role will now also inherit the <code class="literal">employee</code> role too.
			</p><div class="admonition note"><div class="admonition_header">Note</div><div><p>
					When tokens and SAML assertions are created, any composite will also have its associated roles added to the claims and assertions of the authentication response sent back to the client.
				</p></div></div></section><section class="section" id="user_role_mappings"><div class="titlepage"><div><div><h2 class="title">9.4. User Role Mappings</h2></div></div></div><p>
				User role mappings can be assigned individually to each user through the <code class="literal">Role Mappings</code> tab for that single user.
			</p><div class="formalpara"><p class="title"><strong>Role Mappings</strong></p><p>
					<span class="inlinemediaobject"><img src="images/rhsso-images/user-role-mappings.png" alt="user role mappings"/></span>
				</p></div><p>
				In the above example, we are about to assign the composite role <code class="literal">developer</code> that was created in the <a class="link" href="#composite-roles" title="9.3. Composite Roles">Composite Roles</a> chapter.
			</p><div class="formalpara"><p class="title"><strong>Effective Role Mappings</strong></p><p>
					<span class="inlinemediaobject"><img src="images/rhsso-images/effective-role-mappings.png" alt="effective role mappings"/></span>
				</p></div><p>
				Once the <code class="literal">developer</code> role is assigned, you see that the <code class="literal">employee</code> role that is associated with the <code class="literal">developer</code> composite shows up in the <code class="literal">Effective Roles</code>. <code class="literal">Effective Roles</code> are all roles that are explicitly assigned to the user as well as any roles that are inherited from composites.
			</p><section class="section" id="default_roles"><div class="titlepage"><div><div><h3 class="title">9.4.1. Default Roles</h3></div></div></div><p>
					Default roles allow you to automatically assign user role mappings when any user is newly created or imported through <a class="link" href="#identity_broker" title="Chapter 12. Identity Brokering">Identity Brokering</a>. To specify default roles go to the <code class="literal">Roles</code> left menu item, and click the <code class="literal">Default Roles</code> tab.
				</p><div class="formalpara"><p class="title"><strong>Default Roles</strong></p><p>
						<span class="inlinemediaobject"><img src="images/rhsso-images/default-roles.png" alt="default roles"/></span>
					</p></div><p>
					As you can see from the screenshot, there are already a number of <span class="emphasis"><em>default roles</em></span> set up by default.
				</p></section></section><section class="section" id="role_scope_mappings"><div class="titlepage"><div><div><h2 class="title">9.5. Role Scope Mappings</h2></div></div></div><p>
				When an OIDC access token or SAML assertion is created, all the user role mappings of the user are, by default, added as claims within the token or assertion. Applications use this information to make access decisions on the resources controlled by that application. In Red Hat Single Sign-On, access tokens are digitally signed and can actually be re-used by the application to invoke on other remotely secured REST services. This means that if an application gets compromised or there is a rogue client registered with the realm, attackers can get access tokens that have a broad range of permissions and your whole network is compromised. This is where <span class="emphasis"><em>role scope mappings</em></span> becomes important.
			</p><p>
				<span class="emphasis"><em>Role Scope Mappings</em></span> is a way to limit the roles that get declared inside an access token. When a client requests that a user be authenticated, the access token they receive back will only contain the role mappings you’ve explicitly specified for the client’s scope. This allows you to limit the permissions each individual access token has rather than giving the client access to all of the user’s permissions. By default, each client gets all the role mappings of the user. You can view this in the <code class="literal">Scope</code> tab of each client.
			</p><div class="formalpara"><p class="title"><strong>Full Scope</strong></p><p>
					<span class="inlinemediaobject"><img src="images/rhsso-images/full-client-scope.png" alt="full client scope"/></span>
				</p></div><p>
				You can see from the picture that the effective roles of the scope are every declared role in the realm. To change this default behavior, you must explicitly turn off the <code class="literal">Full Scope Allowed</code> switch and declare the specific roles you want in each individual client. Alternatively, you can also use <a class="link" href="#client_scopes" title="8.6. Client Scopes">client scopes</a> to define the same role scope mappings for a whole set of clients.
			</p><div class="formalpara"><p class="title"><strong>Partial Scope</strong></p><p>
					<span class="inlinemediaobject"><img src="images/rhsso-images/client-scope.png" alt="client scope"/></span>
				</p></div></section></section><section class="chapter" id="groups"><div class="titlepage"><div><div><h1 class="title">Chapter 10. Groups</h1></div></div></div><p>
			Groups in Red Hat Single Sign-On allow you to manage a common set of attributes and role mappings for a set of users. Users can be members of zero or more groups. Users inherit the attributes and role mappings assigned to each group. To manage groups go to the <code class="literal">Groups</code> left menu item.
		</p><div class="formalpara"><p class="title"><strong>Groups</strong></p><p>
				<span class="inlinemediaobject"><img src="images/rhsso-images/groups.png" alt="groups"/></span>
			</p></div><p>
			Groups are hierarchical. A group can have many subgroups, but a group can only have one parent. Subgroups inherit the attributes and role mappings from the parent. This applies to the user as well. So, if you have a parent group and a child group and a user that only belongs to the child group, the user inherits the attributes and role mappings of both the parent and child. In this example, we have a top level <code class="literal">Sales</code> group and a child <code class="literal">North America</code> subgroup. To add a group, click on the parent you want to add a new child to and click <code class="literal">New</code> button. Select the <code class="literal">Groups</code> icon in the tree to make a top-level group. Entering in a group name in the <code class="literal">Create Group</code> screen and hitting <code class="literal">Save</code> will bring you to the individual group management page.
		</p><div class="formalpara"><p class="title"><strong>Group</strong></p><p>
				<span class="inlinemediaobject"><img src="images/rhsso-images/group.png" alt="group"/></span>
			</p></div><p>
			The <code class="literal">Attributes</code> and <code class="literal">Role Mappings</code> tab work exactly as the tabs with similar names under a user. Any attributes and role mappings you define will be inherited by the groups and users that are members of this group.
		</p><p>
			To add a user to a group you need to go all the way back to the user detail page and click on the <code class="literal">Groups</code> tab there.
		</p><div class="formalpara"><p class="title"><strong>User Groups</strong></p><p>
				<span class="inlinemediaobject"><img src="images/rhsso-images/user-groups.png" alt="user groups"/></span>
			</p></div><p>
			Select a group from the <code class="literal">Available Groups</code> tree and hit the <code class="literal">join</code> button to add the user to a group. Vice versa to remove a group. Here we’ve added the user <span class="emphasis"><em>Jim</em></span> to the <span class="emphasis"><em>North America</em></span> sales group. If you go back to the detail page for that group and select the <code class="literal">Membership</code> tab, <span class="emphasis"><em>Jim</em></span> is now displayed there.
		</p><div class="formalpara"><p class="title"><strong>Group Membership</strong></p><p>
				<span class="inlinemediaobject"><img src="images/rhsso-images/group-membership.png" alt="group membership"/></span>
			</p></div><section class="section" id="groups_vs_roles"><div class="titlepage"><div><div><h2 class="title">10.1. Groups vs. Roles</h2></div></div></div><p>
				In the IT world the concepts of Group and Role are often blurred and interchangeable. In Red Hat Single Sign-On, Groups are just a collection of users that you can apply roles and attributes to in one place. Roles define a type of user and applications assign permission and access control to roles.
			</p><p>
				Aren’t <a class="link" href="#composite-roles" title="9.3. Composite Roles">Composite Roles</a> also similar to Groups? Logically they provide the same exact functionality, but the difference is conceptual. Composite roles should be used to apply the permission model to your set of services and applications. Groups should focus on collections of users and their roles in your organization. Use groups to manage users. Use composite roles to manage applications and services.
			</p></section><section class="section" id="default_groups"><div class="titlepage"><div><div><h2 class="title">10.2. Default Groups</h2></div></div></div><p>
				Default groups allow you to automatically assign group membership whenever any new user is created or imported through <a class="link" href="#identity_broker" title="Chapter 12. Identity Brokering">Identity Brokering</a>. To specify default groups go to the <code class="literal">Groups</code> left menu item, and click the <code class="literal">Default Groups</code> tab.
			</p><div class="formalpara"><p class="title"><strong>Default Groups</strong></p><p>
					<span class="inlinemediaobject"><img src="images/rhsso-images/default-groups.png" alt="default groups"/></span>
				</p></div></section></section><section class="chapter" id="admin_permissions"><div class="titlepage"><div><div><h1 class="title">Chapter 11. Admin Console Access Control and Permissions</h1></div></div></div><p>
			Each realm created on the Red Hat Single Sign-On has a dedicated Admin Console from which that realm can be managed. The <code class="literal">master</code> realm is a special realm that allows admins to manage more than one realm on the system. You can also define fine-grained access to users in different realms to manage the server. This chapter goes over all the scenarios for this.
		</p><section class="section" id="master_realm_access_control"><div class="titlepage"><div><div><h2 class="title">11.1. Master Realm Access Control</h2></div></div></div><p>
				The <code class="literal">master</code> realm in Red Hat Single Sign-On is a special realm and treated differently than other realms. Users in the Red Hat Single Sign-On <code class="literal">master</code> realm can be granted permission to manage zero or more realms that are deployed on the Red Hat Single Sign-On server. When a realm is created, Red Hat Single Sign-On automatically creates various roles that grant fine-grain permissions to access that new realm. Access to The Admin Console and Admin REST endpoints can be controlled by mapping these roles to users in the <code class="literal">master</code> realm. It’s possible to create multiple super users, as well as users that can only manage specific realms.
			</p><section class="section" id="global_roles"><div class="titlepage"><div><div><h3 class="title">11.1.1. Global Roles</h3></div></div></div><p>
					There are two realm-level roles in the <code class="literal">master</code> realm. These are:
				</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">
							admin
						</li><li class="listitem">
							create-realm
						</li></ul></div><p>
					Users with the <code class="literal">admin</code> role are super users and have full access to manage any realm on the server. Users with the <code class="literal">create-realm</code> role are allowed to create new realms. They will be granted full access to any new realm they create.
				</p></section><section class="section" id="realm_specific_roles"><div class="titlepage"><div><div><h3 class="title">11.1.2. Realm Specific Roles</h3></div></div></div><p>
					Admin users within the <code class="literal">master</code> realm can be granted management privileges to one or more other realms in the system. Each realm in Red Hat Single Sign-On is represented by a client in the <code class="literal">master</code> realm. The name of the client is <code class="literal">&lt;realm name&gt;-realm</code>. These clients each have client-level roles defined which define varying level of access to manage an individual realm.
				</p><p>
					The roles available are:
				</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">
							view-realm
						</li><li class="listitem">
							view-users
						</li><li class="listitem">
							view-clients
						</li><li class="listitem">
							view-events
						</li><li class="listitem">
							manage-realm
						</li><li class="listitem">
							manage-users
						</li><li class="listitem">
							create-client
						</li><li class="listitem">
							manage-clients
						</li><li class="listitem">
							manage-events
						</li><li class="listitem">
							view-identity-providers
						</li><li class="listitem">
							manage-identity-providers
						</li><li class="listitem">
							impersonation
						</li></ul></div><p>
					Assign the roles you want to your users and they will only be able to use that specific part of the administration console.
				</p><div class="admonition important"><div class="admonition_header">Important</div><div><p>
						Admins with the <code class="literal">manage-users</code> role will only be able to assign admin roles to users that they themselves have. So, if an admin has the <code class="literal">manage-users</code> role but doesn’t have the <code class="literal">manage-realm</code> role, they will not be able to assign this role.
					</p></div></div></section></section><section class="section" id="per_realm_admin_permissions"><div class="titlepage"><div><div><h2 class="title">11.2. Dedicated Realm Admin Consoles</h2></div></div></div><p>
				Each realm has a dedicated Admin Console that can be accessed by going to the url <code class="literal">/auth/admin/{realm-name}/console</code>. Users within that realm can be granted realm management permissions by assigning specific user role mappings.
			</p><p>
				Each realm has a built-in client called <code class="literal">realm-management</code>. You can view this client by going to the <code class="literal">Clients</code> left menu item of your realm. This client defines client-level roles that specify permissions that can be granted to manage the realm.
			</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">
						view-realm
					</li><li class="listitem">
						view-users
					</li><li class="listitem">
						view-clients
					</li><li class="listitem">
						view-events
					</li><li class="listitem">
						manage-realm
					</li><li class="listitem">
						manage-users
					</li><li class="listitem">
						create-client
					</li><li class="listitem">
						manage-clients
					</li><li class="listitem">
						manage-events
					</li><li class="listitem">
						view-identity-providers
					</li><li class="listitem">
						manage-identity-providers
					</li><li class="listitem">
						impersonation
					</li></ul></div><p>
				Assign the roles you want to your users and they will only be able to use that specific part of the administration console.
			</p></section><section class="section" id="fine_grain_permissions"><div class="titlepage"><div><div><h2 class="title">11.3. Fine Grain Admin Permissions</h2></div></div></div><div class="admonition note"><div class="admonition_header">Note</div><div><p>
					Fine Grain Admin Permissions is <span class="strong strong"><strong>Technology Preview</strong></span> and is not fully supported. This feature is disabled by default.
				</p><p>
					To enable start the server with <code class="literal">-Dkeycloak.profile=preview</code> or <code class="literal">-Dkeycloak.profile.feature.admin_fine_grained_authz=enabled</code> . For more details see <a class="link" href="https://access.redhat.com/documentation/en-us/red_hat_single_sign-on/7.4/html-single/server_installation_and_configuration_guide/#profiles">Profiles</a>.
				</p></div></div><p>
				Sometimes roles like <code class="literal">manage-realm</code> or <code class="literal">manage-users</code> are too coarse grain and you want to create restricted admin accounts that have more fine grain permissions. Red Hat Single Sign-On allows you to define and assign restricted access policies for managing a realm. Things like:
			</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">
						Managing one specific client
					</li><li class="listitem">
						Managing users that belong to a specific group
					</li><li class="listitem">
						Managing membership of a group
					</li><li class="listitem">
						Limited user management.
					</li><li class="listitem">
						Fine grain impersonization control
					</li><li class="listitem">
						Being able to assign a specific restricted set of roles to users.
					</li><li class="listitem">
						Being able to assign a specific restricted set of roles to a composite role.
					</li><li class="listitem">
						Being able to assign a specific restricted set of roles to a client’s scope.
					</li><li class="listitem">
						New general policies for viewing and managing users, groups, roles, and clients.
					</li></ul></div><p>
				There’s some important things to note about fine grain admin permissions:
			</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">
						Fine grain admin permissions were implemented on top of <a class="link" href="https://access.redhat.com/documentation/en-us/red_hat_single_sign-on/7.4/html-single/authorization_services_guide/">Authorization Services</a>. It is highly recommended that you read up on those features before diving into fine grain permissions.
					</li><li class="listitem">
						Fine grain permissions are only available within <a class="link" href="#per_realm_admin_permissions" title="11.2. Dedicated Realm Admin Consoles">dedicated admin consoles</a> and admins defined within those realms. You cannot define cross-realm fine grain permissions.
					</li><li class="listitem">
						Fine grain permissions are used to grant additional permissions. You cannot override the default behavior of the built in admin roles.
					</li></ul></div><section class="section" id="managing_one_specific_client"><div class="titlepage"><div><div><h3 class="title">11.3.1. Managing One Specific Client</h3></div></div></div><p>
					Let’s look first at allowing an admin to manage one client and one client only. In our example we have a realm called <code class="literal">test</code> and a client called <code class="literal">sales-application</code>. In realm <code class="literal">test</code> we will give a user in that realm permission to only manage that application.
				</p><div class="admonition important"><div class="admonition_header">Important</div><div><p>
						You cannot do cross realm fine grain permissions. Admins in the <code class="literal">master</code> realm are limited to the predefined admin roles defined in previous chapters.
					</p></div></div><section class="section" id="permission_setup"><div class="titlepage"><div><div><h4 class="title">11.3.1.1. Permission Setup</h4></div></div></div><p>
						The first thing we must do is login to the Admin Console so we can set up permissions for that client. We navigate to the management section of the client we want to define fine-grain permissions for.
					</p><div class="formalpara"><p class="title"><strong>Client Management</strong></p><p>
							<span class="inlinemediaobject"><img src="images/rhsso-images/fine-grain-client.png" alt="fine grain client"/></span>
						</p></div><p>
						You should see a tab menu item called <code class="literal">Permissions</code>. Click on that tab.
					</p><div class="formalpara"><p class="title"><strong>Client Permissions Tab</strong></p><p>
							<span class="inlinemediaobject"><img src="images/rhsso-images/fine-grain-client-permissions-tab-off.png" alt="fine grain client permissions tab off"/></span>
						</p></div><p>
						By default, each client is not enabled to do fine grain permissions. So turn the <code class="literal">Permissions Enabled</code> switch to on to initialize permissions.
					</p><div class="admonition important"><div class="admonition_header">Important</div><div><p>
							If you turn the <code class="literal">Permissions Enabled</code> switch to off, it will delete any and all permissions you have defined for this client.
						</p></div></div><div class="formalpara"><p class="title"><strong>Client Permissions Tab</strong></p><p>
							<span class="inlinemediaobject"><img src="images/rhsso-images/fine-grain-client-permissions-tab-on.png" alt="fine grain client permissions tab on"/></span>
						</p></div><p>
						When you switch <code class="literal">Permissions Enabled</code> to on, it initializes various permission objects behind the scenes using <a class="link" href="https://access.redhat.com/documentation/en-us/red_hat_single_sign-on/7.4/html-single/authorization_services_guide/">Authorization Services</a>. For this example, we’re interested in the <code class="literal">manage</code> permission for the client. Clicking on that will redirect you to the permission that handles the <code class="literal">manage</code> permission for the client. All authorization objects are contained in the <code class="literal">realm-management</code> client’s <code class="literal">Authorization</code> tab.
					</p><div class="formalpara"><p class="title"><strong>Client Manage Permission</strong></p><p>
							<span class="inlinemediaobject"><img src="images/rhsso-images/fine-grain-client-manage-permissions.png" alt="fine grain client manage permissions"/></span>
						</p></div><p>
						When first initialized the <code class="literal">manage</code> permission does not have any policies associated with it. You will need to create one by going to the policy tab. To get there fast, click on the <code class="literal">Authorization</code> link shown in the above image. Then click on the policies tab.
					</p><p>
						There’s a pull down menu on this page called <code class="literal">Create policy</code>. There’s a multitude of policies you can define. You can define a policy that is associated with a role or a group or even define rules in JavaScript. For this simple example, we’re going to create a <code class="literal">User Policy</code>.
					</p><div class="formalpara"><p class="title"><strong>User Policy</strong></p><p>
							<span class="inlinemediaobject"><img src="images/rhsso-images/fine-grain-client-user-policy.png" alt="fine grain client user policy"/></span>
						</p></div><p>
						This policy will match a hard-coded user in the user database. In this case it is the <code class="literal">sales-admin</code> user. We must then go back to the <code class="literal">sales-application</code> client’s <code class="literal">manage</code> permission page and assign the policy to the permission object.
					</p><div class="formalpara"><p class="title"><strong>Assign User Policy</strong></p><p>
							<span class="inlinemediaobject"><img src="images/rhsso-images/fine-grain-client-assign-user-policy.png" alt="fine grain client assign user policy"/></span>
						</p></div><p>
						The <code class="literal">sales-admin</code> user can now has permission to manage the <code class="literal">sales-application</code> client.
					</p><p>
						There’s one more thing we have to do. Go to the <code class="literal">Role Mappings</code> tab and assign the <code class="literal">query-clients</code> role to the <code class="literal">sales-admin</code>.
					</p><div class="formalpara"><p class="title"><strong>Assign query-clients</strong></p><p>
							<span class="inlinemediaobject"><img src="images/rhsso-images/fine-grain-assign-query-clients.png" alt="fine grain assign query clients"/></span>
						</p></div><p>
						Why do you have to do this? This role tells the Admin Console what menu items to render when the <code class="literal">sales-admin</code> visits the Admin Console. The <code class="literal">query-clients</code> role tells the Admin Console that it should render client menus for the <code class="literal">sales-admin</code> user.
					</p><p>
						IMPORTANT If you do not set the <code class="literal">query-clients</code> role, restricted admins like <code class="literal">sales-admin</code> will not see any menu options when they log into the Admin Console
					</p></section><section class="section" id="testing_it_out"><div class="titlepage"><div><div><h4 class="title">11.3.1.2. Testing It Out.</h4></div></div></div><p>
						Next we log out of the master realm and re-login to the <a class="link" href="#per_realm_admin_permissions" title="11.2. Dedicated Realm Admin Consoles">dedicated admin console</a> for the <code class="literal">test</code> realm using the <code class="literal">sales-admin</code> as a username. This is located under <code class="literal">/auth/admin/test/console</code>.
					</p><div class="formalpara"><p class="title"><strong>Sales Admin Login</strong></p><p>
							<span class="inlinemediaobject"><img src="images/rhsso-images/fine-grain-sales-admin-login.png" alt="fine grain sales admin login"/></span>
						</p></div><p>
						This admin is now able to manage this one client.
					</p></section></section><section class="section" id="restrict_user_role_mapping"><div class="titlepage"><div><div><h3 class="title">11.3.2. Restrict User Role Mapping</h3></div></div></div><p>
					Another thing you might want to do is to restrict the set a roles an admin is allowed to assign to a user. Continuing our last example, let’s expand the permission set of the 'sales-admin' user so that he can also control which users are allowed to access this application. Through fine grain permissions we can enable it so that the <code class="literal">sales-admin</code> can only assign roles that grant specific access to the <code class="literal">sales-application</code>. We can also restrict it so that the admin can only map roles and not perform any other types of user administration.
				</p><p>
					The <code class="literal">sales-application</code> has defined three different client roles.
				</p><div class="formalpara"><p class="title"><strong>Sales Application Roles</strong></p><p>
						<span class="inlinemediaobject"><img src="images/rhsso-images/fine-grain-sales-application-roles.png" alt="fine grain sales application roles"/></span>
					</p></div><p>
					We want the <code class="literal">sales-admin</code> user to be able to map these roles to any user in the system. The first step to do this is to allow the role to be mapped by the admin. If we click on the <code class="literal">viewLeads</code> role, you’ll see that there is a <code class="literal">Permissions</code> tab for this role.
				</p><div class="formalpara"><p class="title"><strong>View Leads Role Permission Tab</strong></p><p>
						<span class="inlinemediaobject"><img src="images/rhsso-images/fine-grain-view-leads-role-tab.png" alt="fine grain view leads role tab"/></span>
					</p></div><p>
					If we click on that tab and turn the <code class="literal">Permissions Enabled</code> on, you’ll see that there are a number of actions we can apply policies to.
				</p><div class="formalpara"><p class="title"><strong>View Leads Permissions</strong></p><p>
						<span class="inlinemediaobject"><img src="images/rhsso-images/fine-grain-view-leads-permissions.png" alt="fine grain view leads permissions"/></span>
					</p></div><p>
					The one we are interested in is <code class="literal">map-role</code>. Click on this permission and add the same User Policy that was created in the earlier example.
				</p><div class="formalpara"><p class="title"><strong>Map-roles Permission</strong></p><p>
						<span class="inlinemediaobject"><img src="images/rhsso-images/fine-grain-map-roles-permission.png" alt="fine grain map roles permission"/></span>
					</p></div><p>
					What we’ve done is say that the <code class="literal">sales-admin</code> can map the <code class="literal">viewLeads</code> role. What we have not done is specify which users the admin is allowed to map this role too. To do that we must go to the <code class="literal">Users</code> section of the admin console for this realm. Clicking on the <code class="literal">Users</code> left menu item brings us to the users interface of the realm. You should see a <code class="literal">Permissions</code> tab. Click on that and enable it.
				</p><div class="formalpara"><p class="title"><strong>Users Permissions</strong></p><p>
						<span class="inlinemediaobject"><img src="images/rhsso-images/fine-grain-users-permissions.png" alt="fine grain users permissions"/></span>
					</p></div><p>
					The permission we are interested in is <code class="literal">map-roles</code>. This is a restrictive policy in that it only allows admins the ability to map roles to a user. If we click on the <code class="literal">map-roles</code> permission and again add the User Policy we created for this, our <code class="literal">sales-admin</code> will be able to map roles to any user.
				</p><p>
					The last thing we have to do is add the <code class="literal">view-users</code> role to the <code class="literal">sales-admin</code>. This will allow the admin to view users in the realm he wants to add the <code class="literal">sales-application</code> roles to.
				</p><div class="formalpara"><p class="title"><strong>Add view-users</strong></p><p>
						<span class="inlinemediaobject"><img src="images/rhsso-images/fine-grain-add-view-users.png" alt="fine grain add view users"/></span>
					</p></div><section class="section" id="testing_it_out_2"><div class="titlepage"><div><div><h4 class="title">11.3.2.1. Testing It Out.</h4></div></div></div><p>
						Next we log out of the master realm and re-login to the <a class="link" href="#per_realm_admin_permissions" title="11.2. Dedicated Realm Admin Consoles">dedicated admin console</a> for the <code class="literal">test</code> realm using the <code class="literal">sales-admin</code> as a username. This is located under <code class="literal">/auth/admin/test/console</code>.
					</p><p>
						You will see that now the <code class="literal">sales-admin</code> can view users in the system. If you select one of the users you’ll see that each user detail page is read only, except for the <code class="literal">Role Mappings</code> tab. Going to these tab you’ll find that there are no <code class="literal">Available</code> roles for the admin to map to the user except when we browse the <code class="literal">sales-application</code> roles.
					</p><div class="formalpara"><p class="title"><strong>Add viewLeads</strong></p><p>
							<span class="inlinemediaobject"><img src="images/rhsso-images/fine-grain-add-view-leads.png" alt="fine grain add view leads"/></span>
						</p></div><p>
						We’ve only specified that the <code class="literal">sales-admin</code> can map the <code class="literal">viewLeads</code> role.
					</p></section><section class="section" id="per_client_map_roles_shortcut"><div class="titlepage"><div><div><h4 class="title">11.3.2.2. Per Client map-roles Shortcut</h4></div></div></div><p>
						It would be tedious if we had to do this for every client role that the <code class="literal">sales-application</code> published. to make things easier, there’s a way to specify that an admin can map any role defined by a client. If we log back into the admin console to our master realm admin and go back to the <code class="literal">sales-application</code> permissions page, you’ll see the <code class="literal">map-roles</code> permission.
					</p><div class="formalpara"><p class="title"><strong>Client map-roles Permission</strong></p><p>
							<span class="inlinemediaobject"><img src="images/rhsso-images/fine-grain-client-permissions-tab-on.png" alt="fine grain client permissions tab on"/></span>
						</p></div><p>
						If you grant access to this particular parmission to an admin, that admin will be able map any role defined by the client.
					</p></section></section><section class="section" id="full_list_of_permissions"><div class="titlepage"><div><div><h3 class="title">11.3.3. Full List of Permissions</h3></div></div></div><p>
					You can do a lot more with fine grain permissions beyond managing a specific client or the specific roles of a client. This chapter defines the whole list of permission types that can be described for a realm.
				</p><section class="section" id="role"><div class="titlepage"><div><div><h4 class="title">11.3.3.1. Role</h4></div></div></div><p>
						When going to the <code class="literal">Permissions</code> tab for a specific role, you will see these permission types listed.
					</p><div class="variablelist"><dl class="variablelist"><dt><span class="term">map-role</span></dt><dd>
									Policies that decide if an admin can map this role to a user. These policies only specify that the role can be mapped to a user, not that the admin is allowed to perform user role mapping tasks. The admin will also have to have manage or role mapping permissions. See <a class="link" href="#users-permissions" title="11.3.3.3. Users">Users Permissions</a> for more information.
								</dd><dt><span class="term">map-role-composite</span></dt><dd>
									Policies that decide if an admin can map this role as a composite to another role. An admin can define roles for a client if he has manage permissions for that client but he will not be able to add composites to those roles unless he has the <code class="literal">map-role-composite</code> privileges for the role he wants to add as a composite.
								</dd><dt><span class="term">map-role-client-scope</span></dt><dd>
									Policies that decide if an admin can apply this role to the scope of a client. Even if the admin can manage the client, he will not have permission to create tokens for that client that contain this role unless this privilege is granted.
								</dd></dl></div></section><section class="section" id="client"><div class="titlepage"><div><div><h4 class="title">11.3.3.2. Client</h4></div></div></div><p>
						When going to the <code class="literal">Permissions</code> tab for a specific client, you will see these permission types listed.
					</p><div class="variablelist"><dl class="variablelist"><dt><span class="term">view</span></dt><dd>
									Policies that decide if an admin can view the client’s configuration.
								</dd><dt><span class="term">manage</span></dt><dd>
									Policies that decide if an admin can view and manage the client’s configuration. There is some issues with this in that privileges could be leaked unintentionally. For example, the admin could define a protocol mapper that hardcoded a role even if the admin does not have privileges to map the role to the client’s scope. This is currently the limitation of protocol mappers as they don’t have a way to assign individual permissions to them like roles do.
								</dd><dt><span class="term">configure</span></dt><dd>
									Reduced set of prileges to manage the client. Its like the <code class="literal">manage</code> scope except the admin is not allowed to define protocol mappers, change the client template, or the client’s scope.
								</dd><dt><span class="term">map-roles</span></dt><dd>
									Policies that decide if an admin can map any role defined by the client to a user. This is a shortcut, easy-of-use feature to avoid having to defin policies for each and every role defined by the client.
								</dd><dt><span class="term">map-roles-composite</span></dt><dd>
									Policies that decide if an admin can map any role defined by the client as a composite to another role. This is a shortcut, easy-of-use feature to avoid having to define policies for each and every role defined by the client.
								</dd><dt><span class="term">map-roles-client-scope</span></dt><dd>
									Policies that decide if an admin can map any role defined by the client to the scope of another client. This is a shortcut, easy-of-use feature to avoid having to define policies for each and every role defined by the client.
								</dd></dl></div></section><section class="section" id="users-permissions"><div class="titlepage"><div><div><h4 class="title">11.3.3.3. Users</h4></div></div></div><p>
						When going to the <code class="literal">Permissions</code> tab for all users, you will see these permission types listed.
					</p><div class="variablelist"><dl class="variablelist"><dt><span class="term">view</span></dt><dd>
									Policies that decide if an admin can view all users in the realm.
								</dd><dt><span class="term">manage</span></dt><dd>
									Policies that decide if an admin can manage all users in the realm. This permission grants the admin the privilege to perfor user role mappings, but it does not specify which roles the admin is allowed to map. You’ll need to define the privilege for each role you want the admin to be able to map.
								</dd><dt><span class="term">map-roles</span></dt><dd>
									This is a subset of the privileges granted by the <code class="literal">manage</code> scope. In this case the admin is only allowed to map roles. The admin is not allowed to perform any other user management operation. Also, like <code class="literal">manage</code>, the roles that the admin is allowed to apply must be specified per role or per set of roles if dealing with client roles.
								</dd><dt><span class="term">manage-group-membership</span></dt><dd>
									Similar to <code class="literal">map-roles</code> except that it pertains to group membership: which groups a user can be added or removed from. These policies just grant the admin permission to manage group membership, not which groups the admin is allowed to manage membership for. You’ll have to specify policies for each group’s <code class="literal">manage-members</code> permission.
								</dd><dt><span class="term">impersonate</span></dt><dd>
									Policies that decide if the admin is allowed to impersonate other users. These policies are applied to the admin’s attributes and role mappings.
								</dd><dt><span class="term">user-impersonated</span></dt><dd>
									Policies that decide which users can be impersonated. These policies will be applied to the user being impersonated. For example, you might want to define a policy that will forbid anybody from impersonating a user that has admin privileges.
								</dd></dl></div></section><section class="section" id="group"><div class="titlepage"><div><div><h4 class="title">11.3.3.4. Group</h4></div></div></div><p>
						When going to the <code class="literal">Permissions</code> tab for a specific group, you will see these permission types listed.
					</p><div class="variablelist"><dl class="variablelist"><dt><span class="term">view</span></dt><dd>
									Policies that decide if the admin can view information about the group.
								</dd><dt><span class="term">manage</span></dt><dd>
									Policies that decide if the admin can manage the configuration of the group.
								</dd><dt><span class="term">view-members</span></dt><dd>
									Policies that decide if the admin can view the user details of members of the group.
								</dd><dt><span class="term">manage-members</span></dt><dd>
									Policies that decide if the admin can manage the users that belong to this group.
								</dd><dt><span class="term">manage-membership</span></dt><dd>
									Policies that decide if an admin can change the membership of the group. Add or remove members from the group.
								</dd></dl></div></section></section></section><section class="section" id="realm_keys"><div class="titlepage"><div><div><h2 class="title">11.4. Realm Keys</h2></div></div></div><p>
				The authentication protocols that are used by Red Hat Single Sign-On require cryptographic signatures and sometimes encryption. Red Hat Single Sign-On uses asymmetric key pairs, a private and public key, to accomplish this.
			</p><p>
				Red Hat Single Sign-On has a single active keypair at a time, but can have several passive keys as well. The active keypair is used to create new signatures, while the passive keypairs can be used to verify previous signatures. This makes it possible to regularly rotate the keys without any downtime or interruption to users.
			</p><p>
				When a realm is created a key pair and a self-signed certificate is automatically generated.
			</p><p>
				To view the active keys for a realm select the realm in the admin console click on <code class="literal">Realm settings</code> then <code class="literal">Keys</code>. This will show the currently active keys for the realm.
			</p><p>
				To view passive or disabled keys select <code class="literal">Passive</code> or <code class="literal">Disabled</code>. A keypair can have the status <code class="literal">Active</code>, but still not be selected as the currently active keypair for the realm. The selected active pair which is used for signatures is selected based on the first key provider sorted by priority that is able to provide an active keypair.
			</p><section class="section" id="rotating_keys"><div class="titlepage"><div><div><h3 class="title">11.4.1. Rotating keys</h3></div></div></div><p>
					It’s recommended to regularly rotate keys. To do so you should start by creating new keys with a higher priority than the existing active keys. Or create new keys with the same priority and making the previous keys passive.
				</p><p>
					Once new keys are available all new tokens and cookies will be signed with the new keys. When a user authenticates to an application the SSO cookie is updated with the new signature. When OpenID Connect tokens are refreshed new tokens are signed with the new keys. This means that over time all cookies and tokens will use the new keys and after a while the old keys can be removed.
				</p><p>
					How long you wait to delete old keys is a tradeoff between security and making sure all cookies and tokens are updated. In general it should be acceptable to drop old keys after a few weeks. Users that have not been active in the period between the new keys where added and the old keys removed will have to re-authenticate.
				</p><p>
					This also applies to offline tokens. To make sure they are updated the applications need to refresh the tokens before the old keys are removed.
				</p><p>
					As a guideline, it may be a good idea to create new keys every 3-6 months and delete old keys 1-2 months after the new keys were created.
				</p></section><section class="section" id="adding_a_generated_keypair"><div class="titlepage"><div><div><h3 class="title">11.4.2. Adding a generated keypair</h3></div></div></div><p>
					To add a new generated keypair select <code class="literal">Providers</code> and choose <code class="literal">rsa-generated</code> from the dropdown. You can change the priority to make sure the new keypair becomes the active keypair. You can also change the <code class="literal">keysize</code> if you want smaller or larger keys (default is 2048, supported values are 1024, 2048 and 4096).
				</p><p>
					Click <code class="literal">Save</code> to add the new keys. This will generated a new keypair including a self-signed certificate.
				</p><p>
					Changing the priority for a provider will not cause the keys to be re-generated, but if you want to change the keysize you can edit the provider and new keys will be generated.
				</p></section><section class="section" id="adding_an_existing_keypair_and_certificate"><div class="titlepage"><div><div><h3 class="title">11.4.3. Adding an existing keypair and certificate</h3></div></div></div><p>
					To add a keypair and certificate obtained elsewhere select <code class="literal">Providers</code> and choose <code class="literal">rsa</code> from the dropdown. You can change the priority to make sure the new keypair becomes the active keypair.
				</p><p>
					Click on <code class="literal">Select file</code> for <code class="literal">Private RSA Key</code> to upload your private key. The file should be encoded in PEM format. You don’t need to upload the public key as it is automatically extracted from the private key.
				</p><p>
					If you have a signed certificate for the keys click on <code class="literal">Select file</code> next to <code class="literal">X509 Certificate</code>. If you don’t have one you can skip this and a self-signed certificate will be generated.
				</p></section><section class="section" id="loading_keys_from_a_java_keystore"><div class="titlepage"><div><div><h3 class="title">11.4.4. Loading keys from a Java Keystore</h3></div></div></div><p>
					To add a keypair and certificate stored in a Java Keystore file on the host select <code class="literal">Providers</code> and choose <code class="literal">java-keystore</code> from the dropdown. You can change the priority to make sure the new keypair becomes the active keypair.
				</p><p>
					Fill in the values for <code class="literal">Keystore</code>, <code class="literal">Keystore Password</code>, <code class="literal">Key Alias</code> and <code class="literal">Key Password</code> and click on <code class="literal">Save</code>.
				</p></section><section class="section" id="making_keys_passive"><div class="titlepage"><div><div><h3 class="title">11.4.5. Making keys passive</h3></div></div></div><p>
					Locate the keypair in <code class="literal">Active</code> then click on the provider in the <code class="literal">Provider</code> column. This will take you to the configuration screen for the key provider for the keys. Click on <code class="literal">Active</code> to turn it <code class="literal">OFF</code>, then click on <code class="literal">Save</code>. The keys will no longer be active and can only be used for verifying signatures.
				</p></section><section class="section" id="disabling_keys"><div class="titlepage"><div><div><h3 class="title">11.4.6. Disabling keys</h3></div></div></div><p>
					Locate the keypair in <code class="literal">Active</code> then click on the provider in the <code class="literal">Provider</code> column. This will take you to the configuration screen for the key provider for the keys. Click on <code class="literal">Enabled</code> to turn it <code class="literal">OFF</code>, then click on <code class="literal">Save</code>. The keys will no longer be enabled.
				</p><p>
					Alternatively, you can delete the provider from the <code class="literal">Providers</code> table.
				</p></section><section class="section" id="compromised_keys"><div class="titlepage"><div><div><h3 class="title">11.4.7. Compromised keys</h3></div></div></div><p>
					Red Hat Single Sign-On has the signing keys stored just locally and they are never shared with the client applications, users or other entities. However if you think that your realm signing key was compromised, you should first generate new keypair as described above and then immediately remove the compromised keypair.
				</p><p>
					Then to ensure that client applications won’t accept the tokens signed by the compromised key, you should update and push not-before policy for the realm, which is doable from the admin console. Pushing new policy will ensure that client applications won’t accept the existing tokens signed by the compromised key, but also the client application will be forced to download new keypair from the Red Hat Single Sign-On, hence the tokens signed by the compromised key won’t be valid anymore. Note that your REST and confidential clients must have set <code class="literal">Admin URL</code>, so that Red Hat Single Sign-On is able to send them the request about pushed not-before policy.
				</p></section></section></section><section class="chapter" id="identity_broker"><div class="titlepage"><div><div><h1 class="title">Chapter 12. Identity Brokering</h1></div></div></div><p>
			An Identity Broker is an intermediary service that connects multiple service providers with different identity providers. As an intermediary service, the identity broker is responsible for creating a trust relationship with an external identity provider in order to use its identities to access internal services exposed by service providers.
		</p><p>
			From a user perspective, an identity broker provides a user-centric and centralized way to manage identities across different security domains or realms. An existing account can be linked with one or more identities from different identity providers or even created based on the identity information obtained from them.
		</p><p>
			An identity provider is usually based on a specific protocol that is used to authenticate and communicate authentication and authorization information to their users. It can be a social provider such as Facebook, Google or Twitter. It can be a business partner whose users need to access your services. Or it can be a cloud-based identity service that you want to integrate with.
		</p><p>
			Usually, identity providers are based on the following protocols:
		</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">
					<code class="literal">SAML v2.0</code>
				</li><li class="listitem">
					<code class="literal">OpenID Connect v1.0</code>
				</li><li class="listitem">
					<code class="literal">OAuth v2.0</code>
				</li></ul></div><p>
			In the next sections we’ll see how to configure and use Red Hat Single Sign-On as an identity broker, covering some important aspects such as:
		</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">
					<code class="literal">Social Authentication</code>
				</li><li class="listitem">
					<code class="literal">OpenID Connect v1.0 Brokering</code>
				</li><li class="listitem">
					<code class="literal">SAML v2.0 Brokering</code>
				</li><li class="listitem">
					<code class="literal">Identity Federation</code>
				</li></ul></div><section class="section" id="identity_broker_overview"><div class="titlepage"><div><div><h2 class="title">12.1. Brokering Overview</h2></div></div></div><p>
				When using Red Hat Single Sign-On as an identity broker, users are not forced to provide their credentials in order to authenticate in a specific realm. Instead, they are presented with a list of identity providers from which they can authenticate.
			</p><p>
				You can also configure a default identity provider. In this case the user will not be given a choice, but will instead be redirected directly to the default provider.
			</p><p>
				The following diagram demonstrates the steps involved when using Red Hat Single Sign-On to broker an external identity provider:
			</p><div class="formalpara"><p class="title"><strong>Identity Broker Flow</strong></p><p>
					<span class="inlinemediaobject"><img src="images/identity_broker_flow.png" alt="identity broker flow"/></span>
				</p></div><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem">
						User is not authenticated and requests a protected resource in a client application.
					</li><li class="listitem">
						The client applications redirects the user to Red Hat Single Sign-On to authenticate.
					</li><li class="listitem">
						At this point the user is presented with the login page where there is a list of identity providers configured in a realm.
					</li><li class="listitem">
						User selects one of the identity providers by clicking on its respective button or link.
					</li><li class="listitem">
						Red Hat Single Sign-On issues an authentication request to the target identity provider asking for authentication and the user is redirected to the login page of the identity provider. The connection properties and other configuration options for the identity provider were previously set by the administrator in the Admin Console.
					</li><li class="listitem">
						User provides his credentials or consent in order to authenticate with the identity provider.
					</li><li class="listitem">
						Upon a successful authentication by the identity provider, the user is redirected back to Red Hat Single Sign-On with an authentication response. Usually this response contains a security token that will be used by Red Hat Single Sign-On to trust the authentication performed by the identity provider and retrieve information about the user.
					</li><li class="listitem">
						Now Red Hat Single Sign-On is going to check if the response from the identity provider is valid. If valid, it will import and create a new user or just skip that if the user already exists. If it is a new user, Red Hat Single Sign-On may ask the identity provider for information about the user if that info doesn’t already exist in the token. This is what we call <span class="emphasis"><em>identity federation</em></span>. If the user already exists Red Hat Single Sign-On may ask him to link the identity returned from the identity provider with the existing account. We call this process <span class="emphasis"><em>account linking</em></span>. What exactly is done is configurable and can be specified by setup of <a class="link" href="#identity_broker_first_login" title="12.10. First Login Flow">First Login Flow</a>. At the end of this step, Red Hat Single Sign-On authenticates the user and issues its own token in order to access the requested resource in the service provider.
					</li><li class="listitem">
						Once the user is locally authenticated, Red Hat Single Sign-On redirects the user to the service provider by sending the token previously issued during the local authentication.
					</li><li class="listitem">
						The service provider receives the token from Red Hat Single Sign-On and allows access to the protected resource.
					</li></ol></div><p>
				There are some variations of this flow that we will talk about later. For instance, instead of presenting a list of identity providers, the client application can request a specific one. Or you can tell Red Hat Single Sign-On to force the user to provide additional information before federating his identity.
			</p><div class="admonition note"><div class="admonition_header">Note</div><div><p>
					Different protocols may require different authentication flows. At this moment, all the identity providers supported by Red Hat Single Sign-On use a flow just like described above. However, regardless of the protocol in use, user experience should be pretty much the same.
				</p></div></div><p>
				As you may notice, at the end of the authentication process Red Hat Single Sign-On will always issue its own token to client applications. What this means is that client applications are completely decoupled from external identity providers. They don’t need to know which protocol (eg.: SAML, OpenID Connect, OAuth, etc) was used or how the user’s identity was validated. They only need to know about Red Hat Single Sign-On.
			</p></section><section class="section" id="default_identity_provider"><div class="titlepage"><div><div><h2 class="title">12.2. Default Identity Provider</h2></div></div></div><p>
				It is possible to automatically redirect to a identity provider instead of displaying the login form. To enable this go to the <code class="literal">Authentication</code> page in the administration console and select the <code class="literal">Browser</code> flow. Then click on config for the <code class="literal">Identity Provider Redirector</code> authenticator. Set <code class="literal">Default Identity Provider</code> to the alias of the identity provider you want to automatically redirect users to.
			</p><p>
				If the configured default identity provider is not found the login form will be displayed instead.
			</p><p>
				This authenticator is also responsible for dealing with the <code class="literal">kc_idp_hint</code> query parameter. See <a class="link" href="#client_suggested_idp" title="12.7. Client-suggested Identity Provider">client suggested identity provider</a> section for more details.
			</p></section><section class="section" id="general-idp-config"><div class="titlepage"><div><div><h2 class="title">12.3. General Configuration</h2></div></div></div><p>
				The identity broker configuration is all based on identity providers. Identity providers are created for each realm and by default they are enabled for every single application. That means that users from a realm can use any of the registered identity providers when signing in to an application.
			</p><p>
				In order to create an identity provider click the <code class="literal">Identity Providers</code> left menu item.
			</p><div class="formalpara"><p class="title"><strong>Identity Providers</strong></p><p>
					<span class="inlinemediaobject"><img src="images/rhsso-images/identity-providers.png" alt="identity providers"/></span>
				</p></div><p>
				In the drop down list box, choose the identity provider you want to add. This will bring you to the configuration page for that identity provider type.
			</p><div class="formalpara"><p class="title"><strong>Add Identity Provider</strong></p><p>
					<span class="inlinemediaobject"><img src="images/rhsso-images/add-identity-provider.png" alt="add identity provider"/></span>
				</p></div><p>
				Above is an example of configuring a Google social login provider. Once you configure an IDP, it will appear on the Red Hat Single Sign-On login page as an option.
			</p><div class="formalpara"><p class="title"><strong>IDP login page</strong></p><p>
					<span class="inlinemediaobject"><img src="images/rhsso-images/identity-provider-login-page.png" alt="identity provider login page"/></span>
				</p></div><div class="variablelist"><dl class="variablelist"><dt><span class="term">Social</span></dt><dd>
							Social providers allow you to enable social authentication in your realm. Red Hat Single Sign-On makes it easy to let users log in to your application using an existing account with a social network. Currently supported providers include: Twitter, Facebook, Google, LinkedIn, Instagram, Microsoft, PayPal, Openshift v3, GitHub, GitLab, Bitbucket, and Stack Overflow.
						</dd><dt><span class="term">Protocol-based</span></dt><dd>
							Protocol-based providers are those that rely on a specific protocol in order to authenticate and authorize users. They allow you to connect to any identity provider compliant with a specific protocol. Red Hat Single Sign-On provides support for SAML v2.0 and OpenID Connect v1.0 protocols. It makes it easy to configure and broker any identity provider based on these open standards.
						</dd></dl></div><p>
				Although each type of identity provider has its own configuration options, all of them share some very common configuration. Regardless of which identity provider you are creating, you’ll see the following configuration options available:
			</p><div class="table" id="idm140464617809856"><p class="title"><strong>Table 12.1. Common Configuration</strong></p><div class="table-contents"><table class="lt-4-cols lt-7-rows"><colgroup><col style="width: 50%; " class="col_1"/><col style="width: 50%; " class="col_2"/></colgroup><thead><tr><th align="left" valign="top" id="idm140464617805024" scope="col">Configuration</th><th align="left" valign="top" id="idm140464617803936" scope="col">Description</th></tr></thead><tbody><tr><td align="left" valign="top" headers="idm140464617805024">
							<p>
								Alias
							</p>
							</td><td align="left" valign="top" headers="idm140464617803936">
							<p>
								The alias is a unique identifier for an identity provider. It is used to reference an identity provider internally. Some protocols such as OpenID Connect require a redirect URI or callback url in order to communicate with an identity provider. In this case, the alias is used to build the redirect URI. Every single identity provider must have an alias. Examples are <code class="literal">facebook</code>, <code class="literal">google</code>, <code class="literal">idp.acme.com</code>, etc.
							</p>
							</td></tr><tr><td align="left" valign="top" headers="idm140464617805024">
							<p>
								Enabled
							</p>
							</td><td align="left" valign="top" headers="idm140464617803936">
							<p>
								Turn the provider on/off.
							</p>
							</td></tr><tr><td align="left" valign="top" headers="idm140464617805024">
							<p>
								Hide on Login Page
							</p>
							</td><td align="left" valign="top" headers="idm140464617803936">
							<p>
								When this switch is on, this provider will not be shown as a login option on the login page. Clients can still request to use this provider by using the 'kc_idp_hint' parameter in the URL they use to request a login.
							</p>
							</td></tr><tr><td align="left" valign="top" headers="idm140464617805024">
							<p>
								Account Linking Only
							</p>
							</td><td align="left" valign="top" headers="idm140464617803936">
							<p>
								When this switch is on, this provider cannot be used to login users and will not be shown as an option on the login page. Existing accounts can still be linked with this provider though.
							</p>
							</td></tr><tr><td align="left" valign="top" headers="idm140464617805024">
							<p>
								Store Tokens
							</p>
							</td><td align="left" valign="top" headers="idm140464617803936">
							<p>
								Whether or not to store the token received from the identity provider.
							</p>
							</td></tr><tr><td align="left" valign="top" headers="idm140464617805024">
							<p>
								Stored Tokens Readable
							</p>
							</td><td align="left" valign="top" headers="idm140464617803936">
							<p>
								Whether or not users are allowed to retrieve the stored identity provider token. This also applies to the <span class="emphasis"><em>broker</em></span> client-level role <span class="emphasis"><em>read token</em></span>.
							</p>
							</td></tr><tr><td align="left" valign="top" headers="idm140464617805024">
							<p>
								Trust Email
							</p>
							</td><td align="left" valign="top" headers="idm140464617803936">
							<p>
								If the identity provider supplies an email address this email address will be trusted. If the realm required email validation, users that log in from this IDP will not have to go through the email verification process.
							</p>
							</td></tr><tr><td align="left" valign="top" headers="idm140464617805024">
							<p>
								GUI Order
							</p>
							</td><td align="left" valign="top" headers="idm140464617803936">
							<p>
								The order number that sorts how the available IDPs are listed on the login page.
							</p>
							</td></tr><tr><td align="left" valign="top" headers="idm140464617805024">
							<p>
								First Login Flow
							</p>
							</td><td align="left" valign="top" headers="idm140464617803936">
							<p>
								This is the authentication flow that will be triggered for users that log into Red Hat Single Sign-On through this IDP for the first time ever.
							</p>
							</td></tr><tr><td align="left" valign="top" headers="idm140464617805024">
							<p>
								Post Login Flow
							</p>
							</td><td align="left" valign="top" headers="idm140464617803936">
							<p>
								Authentication flow that is triggered after the user finishes logging in with the external identity provider.
							</p>
							</td></tr><tr><td align="left" valign="top" headers="idm140464617805024">
							<p>
								Sync Mode
							</p>
							</td><td align="left" valign="top" headers="idm140464617803936">
							<p>
								Strategy of how to update user information from the idp through mappers: When choosing <code class="literal">legacy</code>, the current behavior is kept, <code class="literal">import</code> will never update user data, while <code class="literal">force</code> will always update user data when possible. See also the documentation for <a class="link" href="#mappers" title="12.8. Mapping Claims and Assertions">Identity Provider Mappers</a> for more details.
							</p>
							</td></tr></tbody></table></div></div></section><section class="section" id="social_identity_providers"><div class="titlepage"><div><div><h2 class="title">12.4. Social Identity Providers</h2></div></div></div><p>
				For Internet facing applications, it is quite burdensome for users to have to register at your site to obtain access. It requires them to remember yet another username and password combination. Social identity providers allow you to delegate authentication to a semi-trusted and respected entity where the user probably already has an account. Red Hat Single Sign-On provides built-in support for the most common social networks out there, such as Google, Facebook, Twitter, GitHub, LinkedIn, Microsoft and Stack Overflow.
			</p><section class="section" id="bitbucket"><div class="titlepage"><div><div><h3 class="title">12.4.1. Bitbucket</h3></div></div></div><p>
					There are a number of steps you have to complete to be able to enable login with Bitbucket.
				</p><p>
					First, open the <code class="literal">Identity Providers</code> left menu item and select <code class="literal">Bitbucket</code> from the <code class="literal">Add provider</code> drop down list. This will bring you to the <code class="literal">Add identity provider</code> page.
				</p><div class="formalpara"><p class="title"><strong>Add Identity Provider</strong></p><p>
						<span class="inlinemediaobject"><img src="images/rhsso-images/bitbucket-add-identity-provider.png" alt="bitbucket add identity provider"/></span>
					</p></div><p>
					Before you can click <code class="literal">Save</code>, you must obtain a <code class="literal">Client ID</code> and <code class="literal">Client Secret</code> from Bitbucket.
				</p><div class="admonition note"><div class="admonition_header">Note</div><div><p>
						You will use the <code class="literal">Redirect URI</code> from this page in a later step, which you will provide to Bitbucket when you register Red Hat Single Sign-On as a client there.
					</p></div></div><div class="formalpara"><p class="title"><strong>Add a New App</strong></p><p>
						To enable login with Bitbucket you must first register an application project in <a class="link" href="https://confluence.atlassian.com/bitbucket/oauth-on-bitbucket-cloud-238027431.html">OAuth on Bitbucket Cloud</a>.
					</p></div><div class="admonition note"><div class="admonition_header">Note</div><div><p>
						Bitbucket often changes the look and feel of application registration, so what you see on the Bitbucket site may differ. If in doubt, see the Bitbucket documentation.
					</p></div></div><p>
					<span class="inlinemediaobject"><img src="images/bitbucket-developer-applications.png" alt="bitbucket developer applications"/></span>
				</p><p>
					Click the <code class="literal">Add consumer</code> button.
				</p><div class="formalpara"><p class="title"><strong>Register App</strong></p><p>
						<span class="inlinemediaobject"><img src="images/bitbucket-register-app.png" alt="bitbucket register app"/></span>
					</p></div><p>
					Copy the <code class="literal">Redirect URI</code> from the Red Hat Single Sign-On <code class="literal">Add Identity Provider</code> page and enter it into the Callback URL field on the Bitbucket Add OAuth Consumer page.
				</p><p>
					On the same page, mark the <code class="literal">Email</code> and <code class="literal">Read</code> boxes under <code class="literal">Account</code> to allow your application to read user email.
				</p><div class="formalpara"><p class="title"><strong>Bitbucket App Page</strong></p><p>
						<span class="inlinemediaobject"><img src="images/bitbucket-app-page.png" alt="bitbucket app page"/></span>
					</p></div><p>
					When you are done registering, click <code class="literal">Save</code>. This will open the application management page in Bitbucket. Find the client ID and secret from this page so you can enter them into the Red Hat Single Sign-On <code class="literal">Add identity provider</code> page. Click <code class="literal">Save</code>.
				</p></section><section class="section" id="facebook"><div class="titlepage"><div><div><h3 class="title">12.4.2. Facebook</h3></div></div></div><p>
					There are a number of steps you have to complete to be able to enable login with Facebook. First, go to the <code class="literal">Identity Providers</code> left menu item and select <code class="literal">Facebook</code> from the <code class="literal">Add provider</code> drop down list. This will bring you to the <code class="literal">Add identity provider</code> page.
				</p><div class="formalpara"><p class="title"><strong>Add Identity Provider</strong></p><p>
						<span class="inlinemediaobject"><img src="images/rhsso-images/facebook-add-identity-provider.png" alt="facebook add identity provider"/></span>
					</p></div><p>
					You can’t click save yet, as you’ll need to obtain a <code class="literal">Client ID</code> and <code class="literal">Client Secret</code> from Facebook. One piece of data you’ll need from this page is the <code class="literal">Redirect URI</code>. You’ll have to provide that to Facebook when you register Red Hat Single Sign-On as a client there, so copy this URI to your clipboard.
				</p><p>
					To enable login with Facebook you first have to create a project and a client in the <a class="link" href="https://developers.facebook.com/">Facebook Developer Console</a>.
				</p><div class="admonition note"><div class="admonition_header">Note</div><div><p>
						Facebook often changes the look and feel of the Facebook Developer Console, so these directions might not always be up to date and the configuration steps might be slightly different.
					</p></div></div><p>
					Once you’ve logged into the console there is a pull down menu in the top right corner of the screen that says <code class="literal">My Apps</code>. Select the <code class="literal">Add a New App</code> menu item.
				</p><div class="formalpara"><p class="title"><strong>Add a New App</strong></p><p>
						<span class="inlinemediaobject"><img src="images/facebook-add-new-app.png" alt="facebook add new app"/></span>
					</p></div><p>
					Select the <code class="literal">Website</code> icon. Click the <code class="literal">Skip and Create App ID</code> button.
				</p><div class="formalpara"><p class="title"><strong>Create a New App ID</strong></p><p>
						<span class="inlinemediaobject"><img src="images/facebook-create-app-id.png" alt="facebook create app id"/></span>
					</p></div><p>
					The email address and app category are required fields. Once you’re done with that, you will be brought to the dashboard for the application. Click the <code class="literal">Settings</code> left menu item.
				</p><div class="formalpara"><p class="title"><strong>Create a New App ID</strong></p><p>
						<span class="inlinemediaobject"><img src="images/facebook-app-settings.png" alt="facebook app settings"/></span>
					</p></div><p>
					Click on the <code class="literal">+ Add Platform</code> button at the end of this page and select the <code class="literal">Website</code> icon. Copy and paste the <code class="literal">Redirect URI</code> from the Red Hat Single Sign-On <code class="literal">Add identity provider</code> page into the <code class="literal">Site URL</code> of the Facebook <code class="literal">Website</code> settings block.
				</p><div class="formalpara"><p class="title"><strong>Specify Website</strong></p><p>
						<span class="inlinemediaobject"><img src="images/facebook-app-settings-website.png" alt="facebook app settings website"/></span>
					</p></div><p>
					After this it is necessary to make the Facebook app public. Click <code class="literal">App Review</code> left menu item and switch button to "Yes".
				</p><p>
					You will need also to obtain the App ID and App Secret from this page so you can enter them into the Red Hat Single Sign-On <code class="literal">Add identity provider</code> page. To obtain this click on the <code class="literal">Dashboard</code> left menu item and click on <code class="literal">Show</code> under <code class="literal">App Secret</code>. Go back to Red Hat Single Sign-On and specify those items and finally save your Facebook Identity Provider.
				</p><p>
					One config option to note on the <code class="literal">Add identity provider</code> page for Facebook is the <code class="literal">Default Scopes</code> field. This field allows you to manually specify the scopes that users must authorize when authenticating with this provider. For a complete list of scopes, please take a look at <a class="link" href="https://developers.facebook.com/docs/graph-api">https://developers.facebook.com/docs/graph-api</a>. By default, Red Hat Single Sign-On uses the following scopes: <code class="literal">email</code>.
				</p></section><section class="section" id="github"><div class="titlepage"><div><div><h3 class="title">12.4.3. GitHub</h3></div></div></div><p>
					There are a number of steps you have to complete to be able to enable login with GitHub. First, go to the <code class="literal">Identity Providers</code> left menu item and select <code class="literal">GitHub</code> from the <code class="literal">Add provider</code> drop down list. This will bring you to the <code class="literal">Add identity provider</code> page.
				</p><div class="formalpara"><p class="title"><strong>Add Identity Provider</strong></p><p>
						<span class="inlinemediaobject"><img src="images/rhsso-images/github-add-identity-provider.png" alt="github add identity provider"/></span>
					</p></div><p>
					You can’t click save yet, as you’ll need to obtain a <code class="literal">Client ID</code> and <code class="literal">Client Secret</code> from GitHub. One piece of data you’ll need from this page is the <code class="literal">Redirect URI</code>. You’ll have to provide that to GitHub when you register Red Hat Single Sign-On as a client there, so copy this URI to your clipboard.
				</p><p>
					To enable login with GitHub you first have to register an application project in <a class="link" href="https://github.com/settings/developers">GitHub Developer applications</a>.
				</p><div class="admonition note"><div class="admonition_header">Note</div><div><p>
						GitHub often changes the look and feel of application registration, so these directions might not always be up to date and the configuration steps might be slightly different.
					</p></div></div><div class="formalpara"><p class="title"><strong>Add a New App</strong></p><p>
						<span class="inlinemediaobject"><img src="images/github-developer-applications.png" alt="github developer applications"/></span>
					</p></div><p>
					Click the <code class="literal">Register a new application</code> button.
				</p><div class="formalpara"><p class="title"><strong>Register App</strong></p><p>
						<span class="inlinemediaobject"><img src="images/github-register-app.png" alt="github register app"/></span>
					</p></div><p>
					You’ll have to copy the <code class="literal">Redirect URI</code> from the Red Hat Single Sign-On <code class="literal">Add Identity Provider</code> page and enter it into the <code class="literal">Authorization callback URL</code> field on the GitHub <code class="literal">Register a new OAuth application</code> page. Once you’ve completed this page you will be brought to the application’s management page.
				</p><div class="formalpara"><p class="title"><strong>GitHub App Page</strong></p><p>
						<span class="inlinemediaobject"><img src="images/github-app-page.png" alt="github app page"/></span>
					</p></div><p>
					You will need to obtain the client ID and secret from this page so you can enter them into the Red Hat Single Sign-On <code class="literal">Add identity provider</code> page. Go back to Red Hat Single Sign-On and specify those items.
				</p></section><section class="section" id="gitlab"><div class="titlepage"><div><div><h3 class="title">12.4.4. GitLab</h3></div></div></div><p>
					There are a number of steps you have to complete to be able to enable login with GitLab.
				</p><p>
					First, go to the <code class="literal">Identity Providers</code> left menu item and select <code class="literal">GitLab</code> from the <code class="literal">Add provider</code> drop down list. This will bring you to the <code class="literal">Add identity provider</code> page.
				</p><div class="formalpara"><p class="title"><strong>Add Identity Provider</strong></p><p>
						<span class="inlinemediaobject"><img src="images/rhsso-images/gitlab-add-identity-provider.png" alt="gitlab add identity provider"/></span>
					</p></div><p>
					Before you can click <code class="literal">Save</code>, you must obtain a <code class="literal">Client ID</code> and <code class="literal">Client Secret</code> from GitLab.
				</p><div class="admonition note"><div class="admonition_header">Note</div><div><p>
						You will use the <code class="literal">Redirect URI</code> from this page in a later step, which you will provide to GitLab when you register Red Hat Single Sign-On as a client there.
					</p></div></div><p>
					To enable login with GitLab you first have to register an application in <a class="link" href="https://docs.gitlab.com/ee/integration/oauth_provider.html">GitLab as OAuth2 authentication service provider</a>.
				</p><div class="admonition note"><div class="admonition_header">Note</div><div><p>
						GitLab often changes the look and feel of application registration, so what you see on the GitLab site may differ. If in doubt, see the GitLab documentation.
					</p></div></div><div class="formalpara"><p class="title"><strong>Add a New App</strong></p><p>
						<span class="inlinemediaobject"><img src="images/gitlab-developer-applications.png" alt="gitlab developer applications"/></span>
					</p></div><p>
					Copy the <code class="literal">Redirect URI</code> from the Red Hat Single Sign-On <code class="literal">Add Identity Provider</code> page and enter it into the Redirect URI field on the GitLab Add new application page.
				</p><div class="formalpara"><p class="title"><strong>GitLab App Page</strong></p><p>
						<span class="inlinemediaobject"><img src="images/gitlab-app-page.png" alt="gitlab app page"/></span>
					</p></div><p>
					When you are done registering, click <code class="literal">Save application</code>. This will open the application management page in GitLab. Find the client ID and secret from this page so you can enter them into the Red Hat Single Sign-On <code class="literal">Add identity provider</code> page.
				</p><p>
					To finish, return to Red Hat Single Sign-On and enter them. Click <code class="literal">Save</code>.
				</p></section><section class="section" id="google"><div class="titlepage"><div><div><h3 class="title">12.4.5. Google</h3></div></div></div><p>
					There are a number of steps you have to complete to be able to enable login with Google. First, go to the <code class="literal">Identity Providers</code> left menu item and select <code class="literal">Google</code> from the <code class="literal">Add provider</code> drop down list. This will bring you to the <code class="literal">Add identity provider</code> page.
				</p><div class="formalpara"><p class="title"><strong>Add Identity Provider</strong></p><p>
						<span class="inlinemediaobject"><img src="images/rhsso-images/google-add-identity-provider.png" alt="google add identity provider"/></span>
					</p></div><p>
					You can’t click save yet, as you’ll need to obtain a <code class="literal">Client ID</code> and <code class="literal">Client Secret</code> from Google. One piece of data you’ll need from this page is the <code class="literal">Redirect URI</code>. You’ll have to provide that to Google when you register Red Hat Single Sign-On as a client there, so copy this URI to your clipboard.
				</p><p>
					To enable login with Google you first have to create a project and a client in the <a class="link" href="https://console.cloud.google.com/project">Google Developer Console</a>. Then you need to copy the client ID and secret into the Red Hat Single Sign-On Admin Console.
				</p><div class="admonition note"><div class="admonition_header">Note</div><div><p>
						Google often changes the look and feel of the Google Developer Console, so these directions might not always be up to date and the configuration steps might be slightly different.
					</p></div></div><p>
					Let’s see first how to create a project with Google.
				</p><p>
					Log in to the <a class="link" href="https://console.cloud.google.com/project">Google Developer Console</a>.
				</p><div class="formalpara"><p class="title"><strong>Google Developer Console</strong></p><p>
						<span class="inlinemediaobject"><img src="images/google-developer-console.png" alt="google developer console"/></span>
					</p></div><p>
					Click the <code class="literal">Create Project</code> button. Use any value for <code class="literal">Project name</code> and <code class="literal">Project ID</code> you want, then click the <code class="literal">Create</code> button. Wait for the project to be created (this may take a while). Once created you will be brought to the project’s dashboard.
				</p><div class="formalpara"><p class="title"><strong>Dashboard</strong></p><p>
						<span class="inlinemediaobject"><img src="images/google-dashboard.png" alt="google dashboard"/></span>
					</p></div><p>
					Then navigate to the <code class="literal">APIs &amp; Services</code> section in the Google Developer Console. On that screen, navigate to <code class="literal">Credentials</code> administration.
				</p><p>
					When users log into Google from Red Hat Single Sign-On they will see a consent screen from Google which will ask the user if Red Hat Single Sign-On is allowed to view information about their user profile. Thus Google requires some basic information about the product before creating any secrets for it. For a new project, you have first to configure <code class="literal">OAuth consent screen</code>.
				</p><p>
					For the very basic setup, filling in the Application name is sufficient. You can also set additional details like scopes for Google APIs in this page.
				</p><div class="formalpara"><p class="title"><strong>Fill in OAuth consent screen details</strong></p><p>
						<span class="inlinemediaobject"><img src="images/google-oauth-consent-screen.png" alt="google oauth consent screen"/></span>
					</p></div><p>
					The next step is to create OAuth client ID and client secret. Back in <code class="literal">Credentials</code> administration, navigate to <code class="literal">Credentials</code> tab and select <code class="literal">OAuth client ID</code> under the <code class="literal">Create credentials</code> button.
				</p><div class="formalpara"><p class="title"><strong>Create credentials</strong></p><p>
						<span class="inlinemediaobject"><img src="images/google-create-credentials.png" alt="google create credentials"/></span>
					</p></div><p>
					You will then be brought to the <code class="literal">Create OAuth client ID</code> page. Select <code class="literal">Web application</code> as the application type. Specify the name you want for your client. You’ll also need to copy and paste the <code class="literal">Redirect URI</code> from the Red Hat Single Sign-On <code class="literal">Add Identity Provider</code> page into the <code class="literal">Authorized redirect URIs</code> field. After you do this, click the <code class="literal">Create</code> button.
				</p><div class="formalpara"><p class="title"><strong>Create OAuth client ID</strong></p><p>
						<span class="inlinemediaobject"><img src="images/google-create-oauth-id.png" alt="google create oauth id"/></span>
					</p></div><p>
					After you click <code class="literal">Create</code> you will be brought to the <code class="literal">Credentials</code> page. Click on your new OAuth 2.0 Client ID to view the settings of your new Google Client.
				</p><div class="formalpara"><p class="title"><strong>Google Client Credentials</strong></p><p>
						<span class="inlinemediaobject"><img src="images/google-client-credentials.png" alt="google client credentials"/></span>
					</p></div><p>
					You will need to obtain the client ID and secret from this page so you can enter them into the Red Hat Single Sign-On <code class="literal">Add identity provider</code> page. Go back to Red Hat Single Sign-On and specify those items.
				</p><p>
					One config option to note on the <code class="literal">Add identity provider</code> page for Google is the <code class="literal">Default Scopes</code> field. This field allows you to manually specify the scopes that users must authorize when authenticating with this provider. For a complete list of scopes, please take a look at <a class="link" href="https://developers.google.com/oauthplayground/">https://developers.google.com/oauthplayground/</a> . By default, Red Hat Single Sign-On uses the following scopes: <code class="literal">openid</code> <code class="literal">profile</code> <code class="literal">email</code>.
				</p><p>
					If your organization uses the G Suite and you want to restrict access to only members of your organization, you must enter the domain that is used for the G Suite into the <code class="literal">Hosted Domain</code> field to enable it.
				</p></section><section class="section" id="linkedin"><div class="titlepage"><div><div><h3 class="title">12.4.6. LinkedIn</h3></div></div></div><p>
					There are a number of steps you have to complete to be able to enable login with LinkedIn. First, go to the <code class="literal">Identity Providers</code> left menu item and select <code class="literal">LinkedIn</code> from the <code class="literal">Add provider</code> drop down list. This will bring you to the <code class="literal">Add identity provider</code> page.
				</p><div class="formalpara"><p class="title"><strong>Add Identity Provider</strong></p><p>
						<span class="inlinemediaobject"><img src="images/rhsso-images/linked-in-add-identity-provider.png" alt="linked in add identity provider"/></span>
					</p></div><p>
					You can’t click save yet, as you’ll need to obtain a <code class="literal">Client ID</code> and <code class="literal">Client Secret</code> from LinkedIn. One piece of data you’ll need from this page is the <code class="literal">Redirect URI</code>. You’ll have to provide that to LinkedIn when you register Red Hat Single Sign-On as a client there, so copy this URI to your clipboard.
				</p><p>
					To enable login with LinkedIn you first have to create an application in <a class="link" href="https://www.linkedin.com/developer/apps">LinkedIn Developer Network</a>.
				</p><div class="admonition note"><div class="admonition_header">Note</div><div><p>
						LinkedIn may change the look and feel of application registration, so these directions may not always be up to date.
					</p></div></div><div class="formalpara"><p class="title"><strong>Developer Network</strong></p><p>
						<span class="inlinemediaobject"><img src="images/linked-in-developer-network.png" alt="linked in developer network"/></span>
					</p></div><p>
					Click on the <code class="literal">Create Application</code> button. This will bring you to the <code class="literal">Create a New Application</code> Page.
				</p><div class="formalpara"><p class="title"><strong>Create App</strong></p><p>
						<span class="inlinemediaobject"><img src="images/linked-in-create-app.png" alt="linked in create app"/></span>
					</p></div><p>
					Fill in the form with the appropriate values, then click the <code class="literal">Submit</code> button. This will bring you to the new application’s settings page.
				</p><div class="formalpara"><p class="title"><strong>App Settings</strong></p><p>
						<span class="inlinemediaobject"><img src="images/linked-in-app-settings.png" alt="linked in app settings"/></span>
					</p></div><p>
					Select <code class="literal">r_basicprofile</code> and <code class="literal">r_emailaddress</code> in the <code class="literal">Default Application Permissions</code> section. You’ll have to copy the <code class="literal">Redirect URI</code> from the Red Hat Single Sign-On <code class="literal">Add Identity Provider</code> page and enter it into the <code class="literal">OAuth 2.0</code> <code class="literal">Authorized Redirect URLs</code> field on the LinkedIn app settings page. Don’t forget to click the <code class="literal">Update</code> button after you do this!
				</p><p>
					You will then need to obtain the client ID and secret from this page so you can enter them into the Red Hat Single Sign-On <code class="literal">Add identity provider</code> page. Go back to Red Hat Single Sign-On and specify those items.
				</p></section><section class="section" id="microsoft"><div class="titlepage"><div><div><h3 class="title">12.4.7. Microsoft</h3></div></div></div><p>
					There are a number of steps you have to complete to be able to enable login with Microsoft. First, go to the <code class="literal">Identity Providers</code> left menu item and select <code class="literal">Microsoft</code> from the <code class="literal">Add provider</code> drop down list. This will bring you to the <code class="literal">Add identity provider</code> page.
				</p><div class="formalpara"><p class="title"><strong>Add Identity Provider</strong></p><p>
						<span class="inlinemediaobject"><img src="images/rhsso-images/microsoft-add-identity-provider.png" alt="microsoft add identity provider"/></span>
					</p></div><p>
					You can’t click save yet, as you’ll need to obtain a <code class="literal">Client ID</code> and <code class="literal">Client Secret</code> from Microsoft. One piece of data you’ll need from this page is the <code class="literal">Redirect URI</code>. You’ll have to provide that to Microsoft when you register Red Hat Single Sign-On as a client there, so copy this URI to your clipboard.
				</p><p>
					To enable login with Microsoft account you first have to register an OAuth application at Microsoft. Go to the <a class="link" href="https://account.live.com/developers/applications/create">Microsoft Application Registration</a> url.
				</p><div class="admonition note"><div class="admonition_header">Note</div><div><p>
						Microsoft often changes the look and feel of application registration, so these directions might not always be up to date and the configuration steps might be slightly different.
					</p></div></div><div class="formalpara"><p class="title"><strong>Register Application</strong></p><p>
						<span class="inlinemediaobject"><img src="images/microsoft-app-register.png" alt="microsoft app register"/></span>
					</p></div><p>
					Enter in the application name and click <code class="literal">Create application</code>. This will bring you to the application settings page of your new application.
				</p><div class="formalpara"><p class="title"><strong>Settings</strong></p><p>
						<span class="inlinemediaobject"><img src="images/microsoft-app-settings.png" alt="microsoft app settings"/></span>
					</p></div><p>
					You’ll have to copy the <code class="literal">Redirect URI</code> from the Red Hat Single Sign-On <code class="literal">Add Identity Provider</code> page and add it to the <code class="literal">Redirect URIs</code> field on the Microsoft application page. Be sure to click the <code class="literal">Add Url</code> button and <code class="literal">Save</code> your changes.
				</p><p>
					Finally, you will need to obtain the Application ID and secret from this page so you can enter them back on the Red Hat Single Sign-On <code class="literal">Add identity provider</code> page. Go back to Red Hat Single Sign-On and specify those items.
				</p><div class="admonition warning"><div class="admonition_header">Warning</div><div><p>
						From November 2018 onwards, Microsoft is removing support for the Live SDK API in favor of the new Microsoft Graph API. The Red Hat Single Sign-On Microsoft identity provider has been updated to use the new endpoints so make sure to upgrade to Red Hat Single Sign-On version 7.2.5 or later in order to use this provider. Furthermore, client applications registered with Microsoft under "Live SDK applications" will need to be re-registered in the <a class="link" href="https://account.live.com/developers/applications/create">Microsoft Application Registration</a> portal to obtain an application id that is compatible with the Microsoft Graph API.
					</p></div></div></section><section class="section" id="openshift_3"><div class="titlepage"><div><div><h3 class="title">12.4.8. OpenShift 3</h3></div></div></div><div class="admonition note"><div class="admonition_header">Note</div><div><p>
						OpenShift Online is currently in the developer preview mode. This documentation has been based on on-premise installations and local <code class="literal">minishift</code> development environment.
					</p></div></div><p>
					There are a just a few steps you have to complete to be able to enable login with OpenShift. First, go to the <code class="literal">Identity Providers</code> left menu item and select <code class="literal">OpenShift</code> from the <code class="literal">Add provider</code> drop down list. This will bring you to the <code class="literal">Add identity provider</code> page.
				</p><div class="formalpara"><p class="title"><strong>Add Identity Provider</strong></p><p>
						<span class="inlinemediaobject"><img src="images/openshift-add-identity-provider.png" alt="openshift add identity provider"/></span>
					</p></div><div class="formalpara"><p class="title"><strong>Registering OAuth client</strong></p><p>
						You can register your client using <code class="literal">oc</code> command line tool.
					</p></div><div class="informalexample"><pre class="programlisting language-bash">$ oc create -f &lt;(echo '
kind: OAuthClient
apiVersion: v1
metadata:
 name: kc-client <span id="CO1-1"/><span class="callout">1</span>
secret: "..." <span id="CO1-2"/><span class="callout">2</span>
redirectURIs:
 - "http://www.example.com/" <span id="CO1-3"/><span class="callout">3</span>
grantMethod: prompt <span id="CO1-4"/><span class="callout">4</span>
')</pre><div class="calloutlist"><dl class="calloutlist"><dt><a href="#CO1-1"><span class="callout">1</span></a> </dt><dd><div class="para">
							The <code class="literal">name</code> of your OAuth client. Passed as <code class="literal">client_id</code> request parameter when making requests to <code class="literal"><span class="emphasis"><em>&lt;openshift_master&gt;</em></span>/oauth/authorize</code> and <code class="literal"><span class="emphasis"><em>&lt;openshift_master&gt;</em></span>/oauth/token</code>.
						</div></dd><dt><a href="#CO1-2"><span class="callout">2</span></a> </dt><dd><div class="para">
							<code class="literal">secret</code> is used as the <code class="literal">client_secret</code> request parameter.
						</div></dd><dt><a href="#CO1-3"><span class="callout">3</span></a> </dt><dd><div class="para">
							The <code class="literal">redirect_uri</code> parameter specified in requests to <code class="literal"><span class="emphasis"><em>&lt;openshift_master&gt;</em></span>/oauth/authorize</code> and <code class="literal"><span class="emphasis"><em>&lt;openshift_master&gt;</em></span>/oauth/token</code> must be equal to (or prefixed by) one of the URIs in <code class="literal">redirectURIs</code>.
						</div></dd><dt><a href="#CO1-4"><span class="callout">4</span></a> </dt><dd><div class="para">
							The <code class="literal">grantMethod</code> is used to determine what action to take when this client requests tokens and has not yet been granted access by the user.
						</div></dd></dl></div></div><p>
					Use client ID and secret defined by <code class="literal">oc create</code> command to enter them back on the Red Hat Single Sign-On <code class="literal">Add identity provider</code> page. Go back to Red Hat Single Sign-On and specify those items.
				</p><p>
					Please refer to <a class="link" href="https://docs.okd.io/latest/authentication/configuring-internal-oauth.html#oauth-register-additional-client_configuring-internal-oauth">official OpenShift documentation</a> for more detailed guides.
				</p></section><section class="section" id="openshift_4"><div class="titlepage"><div><div><h3 class="title">12.4.9. OpenShift 4</h3></div></div></div><div class="admonition note"><div class="admonition_header">Note</div><div><p>
						Prior to configuring OpenShift 4 Identity Provider, please locate the correct OpenShift 4 API URL up. In some scenarios, that URL might be hidden from users. The easiest way to obtain it is to invoke the following command (this might require installing <code class="literal">jq</code> command separately) <code class="literal">curl -s -k -H "Authorization: Bearer $(oc whoami -t)" https://&lt;openshift-user-facing-api-url&gt;/apis/config.openshift.io/v1/infrastructures/cluster | jq ".status.apiServerURL"</code>. In most cases, the address will be protected by HTTPS. Therefore, it is essential to configure <code class="literal">X509_CA_BUNDLE</code> in the container and set it to <code class="literal">/var/run/secrets/kubernetes.io/serviceaccount/ca.crt</code>. Otherwise, Red Hat Single Sign-On won’t be able to communicate with the API Server.
					</p></div></div><p>
					There are a just a few steps you have to complete to be able to enable login with OpenShift 4. First, go to the <code class="literal">Identity Providers</code> left menu item and select <code class="literal">OpenShift v4</code> from the <code class="literal">Add provider</code> drop down list. This will bring you to the <code class="literal">Add identity provider</code> page.
				</p><div class="formalpara"><p class="title"><strong>Add Identity Provider</strong></p><p>
						<span class="inlinemediaobject"><img src="images/openshift-4-add-identity-provider.png" alt="openshift 4 add identity provider"/></span>
					</p></div><div class="formalpara"><p class="title"><strong>Registering OAuth client</strong></p><p>
						You can register your client using <code class="literal">oc</code> command line tool.
					</p></div><div class="informalexample"><pre class="programlisting language-bash">$ oc create -f &lt;(echo '
kind: OAuthClient
apiVersion: v1
metadata:
 name: keycloak-broker <span id="CO2-1"/><span class="callout">1</span>
secret: "..." <span id="CO2-2"/><span class="callout">2</span>
redirectURIs:
 - "&lt;copy pasted Redirect URI from OpenShift 4 Identity Providers page&gt;" <span id="CO2-3"/><span class="callout">3</span>
grantMethod: prompt <span id="CO2-4"/><span class="callout">4</span>
')</pre><div class="calloutlist"><dl class="calloutlist"><dt><a href="#CO2-1"><span class="callout">1</span></a> </dt><dd><div class="para">
							The <code class="literal">name</code> of your OAuth client. Passed as <code class="literal">client_id</code> request parameter when making requests to <code class="literal"><span class="emphasis"><em>&lt;openshift_master&gt;</em></span>/oauth/authorize</code> and <code class="literal"><span class="emphasis"><em>&lt;openshift_master&gt;</em></span>/oauth/token</code>. The <code class="literal">name</code> parameter needs to be the same in <code class="literal">OAuthClient</code> object as well as in Red Hat Single Sign-On configuration.
						</div></dd><dt><a href="#CO2-2"><span class="callout">2</span></a> </dt><dd><div class="para">
							<code class="literal">secret</code> is used as the <code class="literal">client_secret</code> request parameter.
						</div></dd><dt><a href="#CO2-3"><span class="callout">3</span></a> </dt><dd><div class="para">
							The <code class="literal">redirect_uri</code> parameter specified in requests to <code class="literal"><span class="emphasis"><em>&lt;openshift_master&gt;</em></span>/oauth/authorize</code> and <code class="literal"><span class="emphasis"><em>&lt;openshift_master&gt;</em></span>/oauth/token</code> must be equal to (or prefixed by) one of the URIs in <code class="literal">redirectURIs</code>. The easiest way to configure it correctly is to copy-paste it from Red Hat Single Sign-On OpenShift 4 Identity Provider configuration page (<code class="literal">Redirect URI</code> field).
						</div></dd><dt><a href="#CO2-4"><span class="callout">4</span></a> </dt><dd><div class="para">
							The <code class="literal">grantMethod</code> is used to determine what action to take when this client requests tokens and has not yet been granted access by the user.
						</div></dd></dl></div></div><p>
					Use the client ID and secret defined by <code class="literal">oc create</code> command to enter them back on the Red Hat Single Sign-On <code class="literal">Add identity provider</code> page. Go back to Red Hat Single Sign-On and specify those items.
				</p><div class="admonition tip"><div class="admonition_header">Tip</div><div><p>
					The OpenShift API server returns <code class="literal">The client is not authorized to request a token using this method</code> whenever <code class="literal">OAuthClient</code> <code class="literal">name</code>, <code class="literal">secret</code> or <code class="literal">redirectURIs</code> is incorrect. Make sure you copy-pasted them into Red Hat Single Sign-On OpenShift 4 Identity Provider page correctly.
				</p></div></div><p>
					Please refer to <a class="link" href="https://docs.okd.io/latest/authentication/configuring-internal-oauth.html#oauth-register-additional-client_configuring-internal-oauth">official OpenShift documentation</a> for more detailed guides.
				</p></section><section class="section" id="paypal"><div class="titlepage"><div><div><h3 class="title">12.4.10. PayPal</h3></div></div></div><p>
					There are a number of steps you have to complete to be able to enable login with PayPal. First, go to the <code class="literal">Identity Providers</code> left menu item and select <code class="literal">PayPal</code> from the <code class="literal">Add provider</code> drop down list. This will bring you to the <code class="literal">Add identity provider</code> page.
				</p><div class="formalpara"><p class="title"><strong>Add Identity Provider</strong></p><p>
						<span class="inlinemediaobject"><img src="images/rhsso-images/paypal-add-identity-provider.png" alt="paypal add identity provider"/></span>
					</p></div><p>
					You can’t click save yet, as you’ll need to obtain a <code class="literal">Client ID</code> and <code class="literal">Client Secret</code> from PayPal. One piece of data you’ll need from this page is the <code class="literal">Redirect URI</code>. You’ll have to provide that to PayPal when you register Red Hat Single Sign-On as a client there, so copy this URI to your clipboard.
				</p><p>
					To enable login with PayPal you first have to register an application project in <a class="link" href="https://developer.paypal.com/developer/applications">PayPal Developer applications</a>.
				</p><div class="formalpara"><p class="title"><strong>Add a New App</strong></p><p>
						<span class="inlinemediaobject"><img src="images/paypal-developer-applications.png" alt="paypal developer applications"/></span>
					</p></div><p>
					Click the <code class="literal">Create App</code> button.
				</p><div class="formalpara"><p class="title"><strong>Register App</strong></p><p>
						<span class="inlinemediaobject"><img src="images/paypal-register-app.png" alt="paypal register app"/></span>
					</p></div><p>
					You will now be brought to the app settings page.
				</p><div class="itemizedlist"><p class="title"><strong>Do the following changes</strong></p><ul class="itemizedlist" type="disc"><li class="listitem">
							Choose to configure either Sandbox or Live (choose Live if you haven’t enabled the <code class="literal">Target Sandbox</code> switch on the <code class="literal">Add identity provider</code> page)
						</li><li class="listitem">
							Copy Client ID and Secret so you can paste them into the Red Hat Single Sign-On <code class="literal">Add identity provider</code> page.
						</li><li class="listitem">
							Scroll down to <code class="literal">App Settings</code>
						</li><li class="listitem">
							Copy the <code class="literal">Redirect URI</code> from the Red Hat Single Sign-On <code class="literal">Add Identity Provider</code> page and enter it into the <code class="literal">Return URL</code> field.
						</li><li class="listitem">
							Check the <code class="literal">Log In with PayPal</code> checkbox.
						</li><li class="listitem">
							Check the <code class="literal">Full name</code> checkbox under the personal information section.
						</li><li class="listitem">
							Check the <code class="literal">Email address</code> checkbox under the address information section.
						</li><li class="listitem">
							Add both a privacy and a user agreement URL pointing to the respective pages on your domain.
						</li></ul></div></section><section class="section" id="stack_overflow"><div class="titlepage"><div><div><h3 class="title">12.4.11. Stack Overflow</h3></div></div></div><p>
					There are a number of steps you have to complete to be able to enable login with Stack Overflow. First, go to the <code class="literal">Identity Providers</code> left menu item and select <code class="literal">Stack Overflow</code> from the <code class="literal">Add provider</code> drop down list. This will bring you to the <code class="literal">Add identity provider</code> page.
				</p><div class="formalpara"><p class="title"><strong>Add Identity Provider</strong></p><p>
						<span class="inlinemediaobject"><img src="images/rhsso-images/stack-overflow-add-identity-provider.png" alt="stack overflow add identity provider"/></span>
					</p></div><p>
					To enable login with Stack Overflow you first have to register an OAuth application on <a class="link" href="https://stackapps.com/">StackApps</a>. Go to <a class="link" href="https://stackapps.com/apps/oauth/register">registering your application on Stack Apps</a> URL and login.
				</p><div class="admonition note"><div class="admonition_header">Note</div><div><p>
						Stack Overflow often changes the look and feel of application registration, so these directions might not always be up to date and the configuration steps might be slightly different.
					</p></div></div><div class="formalpara"><p class="title"><strong>Register Application</strong></p><p>
						<span class="inlinemediaobject"><img src="images/stack-overflow-app-register.png" alt="stack overflow app register"/></span>
					</p></div><p>
					Enter in the application name and the OAuth Domain Name of your application and click <code class="literal">Register your Application</code>. Type in anything you want for the other items.
				</p><div class="formalpara"><p class="title"><strong>Settings</strong></p><p>
						<span class="inlinemediaobject"><img src="images/stack-overflow-app-settings.png" alt="stack overflow app settings"/></span>
					</p></div><p>
					Finally, you will need to obtain the client ID, secret, and key from this page so you can enter them back on the Red Hat Single Sign-On <code class="literal">Add identity provider</code> page. Go back to Red Hat Single Sign-On and specify those items.
				</p></section><section class="section" id="twitter"><div class="titlepage"><div><div><h3 class="title">12.4.12. Twitter</h3></div></div></div><p>
					There are a number of steps you have to complete to be able to enable login with Twitter. First, go to the <code class="literal">Identity Providers</code> left menu item and select <code class="literal">Twitter</code> from the <code class="literal">Add provider</code> drop down list. This will bring you to the <code class="literal">Add identity provider</code> page.
				</p><div class="formalpara"><p class="title"><strong>Add Identity Provider</strong></p><p>
						<span class="inlinemediaobject"><img src="images/rhsso-images/twitter-add-identity-provider.png" alt="twitter add identity provider"/></span>
					</p></div><p>
					You can’t click save yet, as you’ll need to obtain a <code class="literal">Client ID</code> and <code class="literal">Client Secret</code> from Twitter. One piece of data you’ll need from this page is the <code class="literal">Redirect URI</code>. You’ll have to provide that to Twitter when you register Red Hat Single Sign-On as a client there, so copy this URI to your clipboard.
				</p><p>
					To enable login with Twtter you first have to create an application in the <a class="link" href="https://developer.twitter.com/apps/">Twitter Application Management</a>.
				</p><div class="formalpara"><p class="title"><strong>Register Application</strong></p><p>
						<span class="inlinemediaobject"><img src="images/twitter-app-register.png" alt="twitter app register"/></span>
					</p></div><p>
					Click on the <code class="literal">Create New App</code> button. This will bring you to the <code class="literal">Create an Application</code> page.
				</p><div class="formalpara"><p class="title"><strong>Register Application</strong></p><p>
						<span class="inlinemediaobject"><img src="images/twitter-app-create.png" alt="twitter app create"/></span>
					</p></div><p>
					Enter in a Name and Description. The Website can be anything, but cannot have a <code class="literal">localhost</code> address. For the <code class="literal">Callback URL</code> you must copy the <code class="literal">Redirect URI</code> from the Red Hat Single Sign-On <code class="literal">Add Identity Provider</code> page.
				</p><div class="admonition warning"><div class="admonition_header">Warning</div><div><p>
						You cannot use <code class="literal">localhost</code> in the <code class="literal">Callback URL</code>. Instead replace it with <code class="literal">127.0.0.1</code> if you are trying to test drive Twitter login on your laptop.
					</p></div></div><p>
					After clicking save you will be brought to the <code class="literal">Details</code> page.
				</p><div class="formalpara"><p class="title"><strong>App Details</strong></p><p>
						<span class="inlinemediaobject"><img src="images/twitter-details.png" alt="twitter details"/></span>
					</p></div><p>
					Next go to the <code class="literal">Keys and Access Tokens</code> tab.
				</p><div class="formalpara"><p class="title"><strong>Keys and Access Tokens</strong></p><p>
						<span class="inlinemediaobject"><img src="images/twitter-keys.png" alt="twitter keys"/></span>
					</p></div><p>
					Finally, you will need to obtain the API Key and secret from this page and copy them back into the <code class="literal">Client ID</code> and <code class="literal">Client Secret</code> fields on the Red Hat Single Sign-On <code class="literal">Add identity provider</code> page.
				</p></section></section><section class="section" id="identity_broker_oidc"><div class="titlepage"><div><div><h2 class="title">12.5. OpenID Connect v1.0 Identity Providers</h2></div></div></div><p>
				Red Hat Single Sign-On can broker identity providers based on the OpenID Connect protocol. These IDPs must support the <a class="link" href="#oidc" title="7.1. OpenID Connect">Authorization Code Flow</a> as defined by the specification in order to authenticate the user and authorize access.
			</p><p>
				To begin configuring an OIDC provider, go to the <code class="literal">Identity Providers</code> left menu item and select <code class="literal">OpenID Connect v1.0</code> from the <code class="literal">Add provider</code> drop down list. This will bring you to the <code class="literal">Add identity provider</code> page.
			</p><div class="formalpara"><p class="title"><strong>Add Identity Provider</strong></p><p>
					<span class="inlinemediaobject"><img src="images/rhsso-images/oidc-add-identity-provider.png" alt="oidc add identity provider"/></span>
				</p></div><p>
				The initial configuration options on this page are described in <a class="link" href="#general-idp-config" title="12.3. General Configuration">General IDP Configuration</a>. You must define the OpenID Connect configuration options as well. They basically describe the OIDC IDP you are communicating with.
			</p><div class="table" id="idm140464619978080"><p class="title"><strong>Table 12.2. OpenID Connect Config</strong></p><div class="table-contents"><table class="lt-4-cols lt-7-rows"><colgroup><col style="width: 50%; " class="col_1"/><col style="width: 50%; " class="col_2"/></colgroup><thead><tr><th align="left" valign="top" id="idm140464619973248" scope="col">Configuration</th><th align="left" valign="top" id="idm140464619972160" scope="col">Description</th></tr></thead><tbody><tr><td align="left" valign="top" headers="idm140464619973248">
							<p>
								Authorization URL
							</p>
							</td><td align="left" valign="top" headers="idm140464619972160">
							<p>
								Authorization URL endpoint required by the OIDC protocol.
							</p>
							</td></tr><tr><td align="left" valign="top" headers="idm140464619973248">
							<p>
								Token URL
							</p>
							</td><td align="left" valign="top" headers="idm140464619972160">
							<p>
								Token URL endpoint required by the OIDC protocol.
							</p>
							</td></tr><tr><td align="left" valign="top" headers="idm140464619973248">
							<p>
								Logout URL
							</p>
							</td><td align="left" valign="top" headers="idm140464619972160">
							<p>
								Logout URL endpoint defined in the OIDC protocol. This value is optional.
							</p>
							</td></tr><tr><td align="left" valign="top" headers="idm140464619973248">
							<p>
								Backchannel Logout
							</p>
							</td><td align="left" valign="top" headers="idm140464619972160">
							<p>
								Backchannel logout is a background, out-of-band, REST invocation to the IDP to logout the user. Some IDPs can only perform logout through browser redirects as they may only be able to identity sessions via a browser cookie.
							</p>
							</td></tr><tr><td align="left" valign="top" headers="idm140464619973248">
							<p>
								User Info URL
							</p>
							</td><td align="left" valign="top" headers="idm140464619972160">
							<p>
								User Info URL endpoint defined by the OIDC protocol. This is an endpoint from which user profile information can be downloaded.
							</p>
							</td></tr><tr><td align="left" valign="top" headers="idm140464619973248">
							<p>
								Client Authentication
							</p>
							</td><td align="left" valign="top" headers="idm140464619972160">
							<p>
								Switch to define the Client Authentication method to be used with the Authorization Code Flow. In the case of JWT signed with private key, the realm private key is used. In the other cases, a client secret has to be defined. For more details, see the <a class="link" href="https://openid.net/specs/openid-connect-core-1_0.html#ClientAuthentication">Client Authentication specifications</a>.
							</p>
							</td></tr><tr><td align="left" valign="top" headers="idm140464619973248">
							<p>
								Client ID
							</p>
							</td><td align="left" valign="top" headers="idm140464619972160">
							<p>
								This realm will act as an OIDC client to the external IDP. Your realm will need an OIDC client ID when using the Authorization Code Flow to interact with the external IDP.
							</p>
							</td></tr><tr><td align="left" valign="top" headers="idm140464619973248">
							<p>
								Client Secret
							</p>
							</td><td align="left" valign="top" headers="idm140464619972160">
							<p>
								This realm will need a client secret to use when using the Authorization Code Flow. The value of this field can refer a value from an external <a class="link" href="#vault-administration" title="Chapter 17. Using Vault to Obtain Secrets">vault</a>.
							</p>
							</td></tr><tr><td align="left" valign="top" headers="idm140464619973248">
							<p>
								Issuer
							</p>
							</td><td align="left" valign="top" headers="idm140464619972160">
							<p>
								Responses from the IDP may contain an issuer claim. This config value is optional. If specified, this claim will be validated against the value you provide.
							</p>
							</td></tr><tr><td align="left" valign="top" headers="idm140464619973248">
							<p>
								Default Scopes
							</p>
							</td><td align="left" valign="top" headers="idm140464619972160">
							<p>
								Space-separated list of OIDC scopes to send with the authentication request. The default is <code class="literal">openid</code>.
							</p>
							</td></tr><tr><td align="left" valign="top" headers="idm140464619973248">
							<p>
								Prompt
							</p>
							</td><td align="left" valign="top" headers="idm140464619972160">
							<p>
								Another optional switch. This is the prompt parameter defined by the OIDC specification. Through it you can force re-authentication and other options. See the specification for more details.
							</p>
							</td></tr><tr><td align="left" valign="top" headers="idm140464619973248">
							<p>
								Accepts prompt=none forward from client
							</p>
							</td><td align="left" valign="top" headers="idm140464619972160">
							<p>
								Specifies whether the IDP accepts forwarded authentication requests that contain the prompt=none query parameter or not. When a realm receives an auth request with <code class="literal">prompt=none</code> it checks if the user is currently authenticated and normally returns a <code class="literal">login_required</code> error if the user is not logged in. However, when a default IDP can be determined for the auth request (either via <code class="literal">kc_idp_hint</code> query param or by setting up a default IDP for the realm) we should be able to forward the auth request with <code class="literal">prompt=none</code> to the default IDP so that it checks if the user is currently authenticated there. Because not all IDPs support requests with <code class="literal">prompt=none</code> this switch is used to indicate if the default IDP supports the param before redirecting the auth request.
							</p>
							<p>
								It is important to note that if the user is not authenticated in the IDP, the client will still get a <code class="literal">login_required</code> error. Even if the user is currently authenticated in the IDP, the client might still get an <code class="literal">interaction_required</code> error if authentication or consent pages requiring user interaction would be otherwise displayed. This includes required actions (e.g. change password), consent screens and any screens set to be displayed by the <code class="literal">first broker login</code> flow or <code class="literal">post broker login</code> flow.
							</p>
							</td></tr><tr><td align="left" valign="top" headers="idm140464619973248">
							<p>
								Validate Signatures
							</p>
							</td><td align="left" valign="top" headers="idm140464619972160">
							<p>
								Another optional switch. This is to specify if Red Hat Single Sign-On will verify the signatures on the external ID Token signed by this identity provider. If this is on, the Red Hat Single Sign-On will need to know the public key of the external OIDC identity provider. See below for how to set it up. WARNING: For the performance purposes, Red Hat Single Sign-On caches the public key of the external OIDC identity provider. If you think that private key of your identity provider was compromised, it is obviously good to update your keys, but it’s also good to clear the keys cache. See <a class="link" href="#clear-cache" title="3.4. Clearing Server Caches">Clearing the cache</a> section for more details.
							</p>
							</td></tr><tr><td align="left" valign="top" headers="idm140464619973248">
							<p>
								Use JWKS URL
							</p>
							</td><td align="left" valign="top" headers="idm140464619972160">
							<p>
								Applicable if <code class="literal">Validate Signatures</code> is on. If the switch is on, then identity provider public keys will be downloaded from given JWKS URL. This allows great flexibility because new keys will be always re-downloaded when the identity provider generates new keypair. If the switch is off, then public key (or certificate) from the Red Hat Single Sign-On DB is used, so whenever the identity provider keypair changes, you will always need to import the new key to the Red Hat Single Sign-On DB as well.
							</p>
							</td></tr><tr><td align="left" valign="top" headers="idm140464619973248">
							<p>
								JWKS URL
							</p>
							</td><td align="left" valign="top" headers="idm140464619972160">
							<p>
								URL where the identity provider JWK keys are stored. See the <a class="link" href="https://self-issued.info/docs/draft-ietf-jose-json-web-key.html">JWK specification</a> for more details. If you use an external Red Hat Single Sign-On as an identity provider, then you can use URL like <a class="link" href="http://broker-keycloak:8180/auth/realms/test/protocol/openid-connect/certs">http://broker-keycloak:8180/auth/realms/test/protocol/openid-connect/certs</a> assuming your brokered Red Hat Single Sign-On is running on <a class="link" href="http://broker-keycloak:8180">http://broker-keycloak:8180</a> and it’s realm is <code class="literal">test</code>.
							</p>
							</td></tr><tr><td align="left" valign="top" headers="idm140464619973248">
							<p>
								Validating Public Key
							</p>
							</td><td align="left" valign="top" headers="idm140464619972160">
							<p>
								Applicable if <code class="literal">Use JWKS URL</code> is off. Here is the public key in PEM format that must be used to verify external IDP signatures.
							</p>
							</td></tr><tr><td align="left" valign="top" headers="idm140464619973248">
							<p>
								Validating Public Key Id
							</p>
							</td><td align="left" valign="top" headers="idm140464619972160">
							<p>
								Applicable if <code class="literal">Use JWKS URL</code> is off. This field specifies ID of the public key in PEM format. This config value is optional. As there is no standard way for computing key ID from key, various external identity providers might use different algorithm from Red Hat Single Sign-On. If the value of this field is not specified, the validating public key specified above is used for all requests regardless of key ID sent by external IDP. When set, value of this field serves as key ID used by Red Hat Single Sign-On for validating signatures from such providers and must match the key ID specified by the IDP.
							</p>
							</td></tr></tbody></table></div></div><p>
				You can also import all this configuration data by providing a URL or file that points to OpenID Provider Metadata (see OIDC Discovery specification). If you are connecting to a Red Hat Single Sign-On external IDP, you can import the IDP settings from the url <code class="literal">&lt;root&gt;/auth/realms/{realm-name}/.well-known/openid-configuration</code>. This link is a JSON document describing metadata about the IDP.
			</p></section><section class="section" id="saml_v2_0_identity_providers"><div class="titlepage"><div><div><h2 class="title">12.6. SAML v2.0 Identity Providers</h2></div></div></div><p>
				Red Hat Single Sign-On can broker identity providers based on the SAML v2.0 protocol.
			</p><p>
				To begin configuring an SAML v2.0 provider, go to the <code class="literal">Identity Providers</code> left menu item and select <code class="literal">SAML v2.0</code> from the <code class="literal">Add provider</code> drop down list. This will bring you to the <code class="literal">Add identity provider</code> page.
			</p><div class="formalpara"><p class="title"><strong>Add Identity Provider</strong></p><p>
					<span class="inlinemediaobject"><img src="images/rhsso-images/saml-add-identity-provider.png" alt="saml add identity provider"/></span>
				</p></div><p>
				The initial configuration options on this page are described in <a class="link" href="#general-idp-config" title="12.3. General Configuration">General IDP Configuration</a>. You must define the SAML configuration options as well. They basically describe the SAML IDP you are communicating with.
			</p><div class="table" id="idm140464621670160"><p class="title"><strong>Table 12.3. SAML Config</strong></p><div class="table-contents"><table class="lt-4-cols lt-7-rows"><colgroup><col style="width: 50%; " class="col_1"/><col style="width: 50%; " class="col_2"/></colgroup><thead><tr><th align="left" valign="top" id="idm140464621665328" scope="col">Configuration</th><th align="left" valign="top" id="idm140464621664240" scope="col">Description</th></tr></thead><tbody><tr><td align="left" valign="top" headers="idm140464621665328">
							<p>
								Single Sign-On Service URL
							</p>
							</td><td align="left" valign="top" headers="idm140464621664240">
							<p>
								This is a required field and specifies the SAML endpoint to start the authentication process. If your SAML IDP publishes an IDP entity descriptor, the value of this field will be specified there.
							</p>
							</td></tr><tr><td align="left" valign="top" headers="idm140464621665328">
							<p>
								Single Logout Service URL
							</p>
							</td><td align="left" valign="top" headers="idm140464621664240">
							<p>
								This is an optional field that specifies the SAML logout endpoint. If your SAML IDP publishes an IDP entity descriptor, the value of this field will be specified there.
							</p>
							</td></tr><tr><td align="left" valign="top" headers="idm140464621665328">
							<p>
								Backchannel Logout
							</p>
							</td><td align="left" valign="top" headers="idm140464621664240">
							<p>
								Enable if your SAML IDP supports backchannel logout.
							</p>
							</td></tr><tr><td align="left" valign="top" headers="idm140464621665328">
							<p>
								NameID Policy Format
							</p>
							</td><td align="left" valign="top" headers="idm140464621664240">
							<p>
								Specifies the URI reference corresponding to a name identifier format. Defaults to <code class="literal">urn:oasis:names:tc:SAML:2.0:nameid-format:persistent</code>.
							</p>
							</td></tr><tr><td align="left" valign="top" headers="idm140464621665328">
							<p>
								Principal Type
							</p>
							</td><td align="left" valign="top" headers="idm140464621664240">
							<p>
								Specifies which part of the SAML assertion will be used to identify and track external user identities. Can be either Subject NameID or SAML attribute (either by name or by friendly name).
							</p>
							</td></tr><tr><td align="left" valign="top" headers="idm140464621665328">
							<p>
								Principal Attribute
							</p>
							</td><td align="left" valign="top" headers="idm140464621664240">
							<p>
								If Principal is set to either "Attribute [Name]" or "Attribute [Friendly Name]", this field will specify the name or the friendly name of the identifying attribute, respectively.
							</p>
							</td></tr><tr><td align="left" valign="top" headers="idm140464621665328">
							<p>
								HTTP-POST Binding Response
							</p>
							</td><td align="left" valign="top" headers="idm140464621664240">
							<p>
								When this realm responds to any SAML requests sent by the external IDP, which SAML binding should be used? If set to <code class="literal">off</code>, then the Redirect Binding will be used.
							</p>
							</td></tr><tr><td align="left" valign="top" headers="idm140464621665328">
							<p>
								HTTP-POST Binding for AuthnRequest
							</p>
							</td><td align="left" valign="top" headers="idm140464621664240">
							<p>
								When this realm requests authentication from the external SAML IDP, which SAML binding should be used? If set to <code class="literal">off</code>, then the Redirect Binding will be used.
							</p>
							</td></tr><tr><td align="left" valign="top" headers="idm140464621665328">
							<p>
								Want AuthnRequests Signed
							</p>
							</td><td align="left" valign="top" headers="idm140464621664240">
							<p>
								If true, it will use the realm’s keypair to sign requests sent to the external SAML IDP.
							</p>
							</td></tr><tr><td align="left" valign="top" headers="idm140464621665328">
							<p>
								Signature Algorithm
							</p>
							</td><td align="left" valign="top" headers="idm140464621664240">
							<p>
								If <code class="literal">Want AuthnRequests Signed</code> is on, then you can also pick the signature algorithm to use.
							</p>
							</td></tr><tr><td align="left" valign="top" headers="idm140464621665328">
							<p>
								SAML Signature Key Name
							</p>
							</td><td align="left" valign="top" headers="idm140464621664240">
							<p>
								Signed SAML documents sent via POST binding contain identification of signing key in <code class="literal">KeyName</code> element. This by default contains Red Hat Single Sign-On key ID. However various external SAML IDPs might expect a different key name or no key name at all. This switch controls whether <code class="literal">KeyName</code> contains key ID (option <code class="literal">KEY_ID</code>), subject from certificate corresponding to the realm key (option <code class="literal">CERT_SUBJECT</code> - expected for instance by Microsoft Active Directory Federation Services), or that the key name hint is completely omitted from the SAML message (option <code class="literal">NONE</code>).
							</p>
							</td></tr><tr><td align="left" valign="top" headers="idm140464621665328">
							<p>
								Force Authentication
							</p>
							</td><td align="left" valign="top" headers="idm140464621664240">
							<p>
								Indicates that the user will be forced to enter their credentials at the external IDP even if they are already logged in.
							</p>
							</td></tr><tr><td align="left" valign="top" headers="idm140464621665328">
							<p>
								Validate Signature
							</p>
							</td><td align="left" valign="top" headers="idm140464621664240">
							<p>
								Whether or not the realm should expect that SAML requests and responses from the external IDP to be digitally signed. It is highly recommended you turn this on!
							</p>
							</td></tr><tr><td align="left" valign="top" headers="idm140464621665328">
							<p>
								Validating X509 Certificate
							</p>
							</td><td align="left" valign="top" headers="idm140464621664240">
							<p>
								The public certificate that will be used to validate the signatures of SAML requests and responses from the external IDP.
							</p>
							</td></tr></tbody></table></div></div><p>
				You can also import all this configuration data by providing a URL or file that points to the SAML IDP entity descriptor of the external IDP. If you are connecting to a Red Hat Single Sign-On external IDP, you can import the IDP settings from the URL <code class="literal">&lt;root&gt;/auth/realms/{realm-name}/protocol/saml/descriptor</code>. This link is an XML document describing metadata about the IDP.
			</p><p>
				You can also import all this configuration data by providing a URL or XML file that points to the entity descriptor of the external SAML IDP you want to connect to.
			</p><section class="section" id="identity_broker_saml_sp_descriptor"><div class="titlepage"><div><div><h3 class="title">12.6.1. SP Descriptor</h3></div></div></div><p>
					Once you create a SAML provider, there is an <code class="literal">EXPORT</code> button that appears when viewing that provider. Clicking this button will export a SAML SP entity descriptor which you can use to import into the external SP.
				</p><p>
					This metadata is also available publicly by going to the URL.
				</p><pre class="screen">http[s]://{host:port}/auth/realms/{realm-name}/broker/{broker-alias}/endpoint/descriptor</pre></section></section><section class="section" id="client_suggested_idp"><div class="titlepage"><div><div><h2 class="title">12.7. Client-suggested Identity Provider</h2></div></div></div><p>
				OIDC applications can bypass the Red Hat Single Sign-On login page by specifying a hint on which identity provider they want to use.
			</p><p>
				This is done by setting the <code class="literal">kc_idp_hint</code> query parameter in the Authorization Code Flow authorization endpoint.
			</p><p>
				Red Hat Single Sign-On OIDC client adapters also allow you to specify this query parameter when you access a secured resource at the application.
			</p><p>
				For example:
			</p><pre class="screen">GET /myapplication.com?kc_idp_hint=facebook HTTP/1.1
Host: localhost:8080</pre><p>
				In this case, it is expected that your realm has an identity provider with an alias <code class="literal">facebook</code>. If this provider doesn’t exist the login form will be displayed.
			</p><p>
				If you are using <code class="literal">keycloak.js</code> adapter, you can also achieve the same behavior:
			</p><pre class="programlisting language-javascript">var keycloak = new Keycloak('keycloak.json');

keycloak.createLoginUrl({
	idpHint: 'facebook'
});</pre><p>
				The <code class="literal">kc_idp_hint</code> query parameter also allows the client to override the default identity provider if one is configured for the <code class="literal">Identity Provider Redirector</code> authenticator. The client can also disable the automatic redirecting by setting the <code class="literal">kc_idp_hint</code> query parameter to an empty value.
			</p></section><section class="section" id="mappers"><div class="titlepage"><div><div><h2 class="title">12.8. Mapping Claims and Assertions</h2></div></div></div><p>
				You can import the SAML and OpenID Connect metadata provided by the external IDP you are authenticating with into the environment of the realm. This allows you to extract user profile metadata and other information so that you can make it available to your applications.
			</p><p>
				Each new user that logs into your realm via an external identity provider will have an entry for them created in the local Red Hat Single Sign-On database, based on the metadata from the SAML or OIDC assertions and claims.
			</p><p>
				If you click on an identity provider listed in the <code class="literal">Identity Providers</code> page for your realm, you will be brought to the IDPs <code class="literal">Settings</code> tab. On this page there is also a <code class="literal">Mappers</code> tab. Click on that tab to start mapping your incoming IDP metadata.
			</p><p>
				<span class="inlinemediaobject"><img src="images/rhsso-images/identity-provider-mappers.png" alt="identity provider mappers"/></span>
			</p><p>
				There is a <code class="literal">Create</code> button on this page. Clicking on this create button allows you to create a broker mapper. Broker mappers can import SAML attributes or OIDC ID/Access token claims into user attributes and user role mappings.
			</p><p>
				<span class="inlinemediaobject"><img src="images/rhsso-images/identity-provider-mapper.png" alt="identity provider mapper"/></span>
			</p><p>
				Select a mapper from the <code class="literal">Mapper Type</code> list. Hover over the tooltip to see a description of what the mapper does. The tooltips also describe what configuration information you need to enter. Click <code class="literal">Save</code> and your new mapper will be added.
			</p><p>
				The mapper will update user information when the user logs in repeatedly according to the <code class="literal">Sync Mode Override</code>:
			</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">
						Choose <code class="literal">legacy</code> to use the behavior in the previous Red Hat Single Sign-On version.
					</li><li class="listitem">
						Choose <code class="literal">import</code> to import only data from when the user was first created in Red Hat Single Sign-On during the first login to Red Hat Single Sign-On with a particular identity provider.
					</li><li class="listitem">
						Choose <code class="literal">force</code> to update user data at each user login.
					</li><li class="listitem">
						Choose <code class="literal">inherit</code> to use the sync mode configured in the identity provider, all other options will override this sync mode.
					</li></ul></div><p>
				For JSON based claims, you can use dot notation for nesting and square brackets to access array fields by index. For example 'contact.address[0].country'.
			</p><p>
				To investigate the structure of user profile JSON data provided by social providers you can enable the <code class="literal">DEBUG</code> level logger <code class="literal">org.keycloak.social.user_profile_dump</code>. This is done in the server’s app-server configuration file (domain.xml or standalone.xml).
			</p></section><section class="section" id="available_user_session_data"><div class="titlepage"><div><div><h2 class="title">12.9. Available User Session Data</h2></div></div></div><p>
				After a user logs in from the external IDP, there is some additional user session note data that Red Hat Single Sign-On stores that you can access. This data can be propagated to the client requesting a login via the token or SAML assertion being passed back to it by using an appropriate client mapper.
			</p><div class="variablelist"><dl class="variablelist"><dt><span class="term">identity_provider</span></dt><dd>
							This is the IDP alias of the broker used to perform the login.
						</dd><dt><span class="term">identity_provider_identity</span></dt><dd>
							This is the IDP username of the currently authenticated user. This is often the same as the Red Hat Single Sign-On username, but doesn’t necessarily needs to be. For example Red Hat Single Sign-On user <code class="literal">john</code> can be linked to the Facebook user <code class="literal">john123@gmail.com</code>, so in that case value of user session note will be <code class="literal">john123@gmail.com</code> .
						</dd></dl></div><p>
				You can use a <a class="link" href="#protocol-mappers" title="8.4. OIDC Token and SAML Assertion Mappings">Protocol Mapper</a> of type <code class="literal">User Session Note</code> to propagate this information to your clients.
			</p></section><section class="section" id="identity_broker_first_login"><div class="titlepage"><div><div><h2 class="title">12.10. First Login Flow</h2></div></div></div><p>
				When a user logs in through identity brokering some aspects of the user are imported and linked within the realm’s local database. When Red Hat Single Sign-On successfully authenticates users through an external identity provider there can be two situations:
			</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">
						There is already a Red Hat Single Sign-On user account imported and linked with the authenticated identity provider account. In this case, Red Hat Single Sign-On will just authenticate as the existing user and redirect back to application.
					</li><li class="listitem">
						There is not yet an existing Red Hat Single Sign-On user account imported and linked for this external user. Usually you just want to register and import the new account into Red Hat Single Sign-On database, but what if there is an existing Red Hat Single Sign-On account with the same email? Automatically linking the existing local account to the external identity provider is a potential security hole as you can’t always trust the information you get from the external identity provider.
					</li></ul></div><p>
				Different organizations have different requirements when dealing with some of the conflicts and situations listed above. For this, there is a <code class="literal">First Login Flow</code> option in the IDP settings which allows you to choose a <a class="link" href="#authentication-flows" title="6.3. Authentication Flows">workflow</a> that will be used after a user logs in from an external IDP the first time. By default it points to <code class="literal">first broker login</code> flow, but you can configure and use your own flow and use different flows for different identity providers.
			</p><p>
				The flow itself is configured in admin console under <code class="literal">Authentication</code> tab. When you choose <code class="literal">First Broker Login</code> flow, you will see what authenticators are used by default. You can re-configure the existing flow. (For example you can disable some authenticators, mark some of them as <code class="literal">required</code>, configure some authenticators, etc).
			</p><section class="section" id="default_first_login_flow"><div class="titlepage"><div><div><h3 class="title">12.10.1. Default First Login Flow</h3></div></div></div><p>
					Let’s describe the default behavior provided by <code class="literal">First Broker Login</code> flow.
				</p><div class="variablelist"><dl class="variablelist"><dt><span class="term">Review Profile</span></dt><dd>
								This authenticator might display the profile info page, where the user can review their profile retrieved from an identity provider. The authenticator is configurable. You can set the <code class="literal">Update Profile On First Login</code> option. When <code class="literal">On</code>, users will be always presented with the profile page asking for additional information in order to federate their identities. When <code class="literal">missing</code>, users will be presented with the profile page only if some mandatory information (email, first name, last name) is not provided by the identity provider. If <code class="literal">Off</code>, the profile page won’t be displayed, unless user clicks in later phase on <code class="literal">Review profile info</code> link (page displayed in later phase by <code class="literal">Confirm Link Existing Account</code> authenticator).
							</dd><dt><span class="term">Create User If Unique</span></dt><dd>
								This authenticator checks if there is already an existing Red Hat Single Sign-On account with the same email or username like the account from the identity provider. If it’s not, then the authenticator just creates a new local Red Hat Single Sign-On account and links it with the identity provider and the whole flow is finished. Otherwise it goes to the next <code class="literal">Handle Existing Account</code> subflow. If you always want to ensure that there is no duplicated account, you can mark this authenticator as <code class="literal">REQUIRED</code>. In this case, the user will see the error page if there is an existing Red Hat Single Sign-On account and the user will need to link his identity provider account through Account management.
							</dd><dt><span class="term">Confirm Link Existing Account</span></dt><dd>
								On the info page, the user will see that there is an existing Red Hat Single Sign-On account with the same email. They can review their profile again and use different email or username (flow is restarted and goes back to <code class="literal">Review Profile</code> authenticator). Or they can confirm that they want to link their identity provider account with their existing Red Hat Single Sign-On account. Disable this authenticator if you don’t want users to see this confirmation page, but go straight to linking identity provider account by email verification or re-authentication.
							</dd><dt><span class="term">Verify Existing Account By Email</span></dt><dd>
								This authenticator is <code class="literal">ALTERNATIVE</code> by default, so it’s used only if the realm has SMTP setup configured. It will send email to the user, where they can confirm that they want to link the identity provider with their Red Hat Single Sign-On account. Disable this if you don’t want to confirm linking by email, but instead you always want users to reauthenticate with their password (and alternatively OTP).
							</dd><dt><span class="term">Verify Existing Account By Re-authentication</span></dt><dd>
								This authenticator is used if email authenticator is disabled or not available (SMTP not configured for realm). It will display a login screen where the user needs to authenticate to link their Red Hat Single Sign-On account with the Identity provider. User can also re-authenticate with some different identity provider, which is already linked to their Red Hat Single Sign-On account. You can also force users to use OTP. Otherwise it’s optional and used only if OTP is already set for the user account.
							</dd></dl></div></section><section class="section" id="automatically_link_existing_first_login_flow"><div class="titlepage"><div><div><h3 class="title">12.10.2. Automatically Link Existing First Login Flow</h3></div></div></div><div class="admonition warning"><div class="admonition_header">Warning</div><div><p>
						The AutoLink authenticator would be dangerous in a generic environment where users can register themselves using arbitrary usernames/email addresses. Do not use this authenticator unless registration of users is carefully curated and usernames/email addresses are assigned, not requested.
					</p></div></div><p>
					In order to configure a first login flow in which users are automatically linked without being prompted, create a new flow with the following two authenticators:
				</p><div class="variablelist"><dl class="variablelist"><dt><span class="term">Create User If Unique</span></dt><dd>
								This authenticator ensures that unique users are handled. Set the authenticator requirement to "Alternative".
							</dd><dt><span class="term">Automatically Set Existing User</span></dt><dd>
								Automatically sets an existing user to the authentication context without any verification. Set the authenticator requirement to "Alternative".
							</dd></dl></div><div class="admonition note"><div class="admonition_header">Note</div><div><p>
						The described setup uses two authenticators. This setup is the simplest one, but it is possible to use other authenticators according to your needs. For example, you can add the Review Profile authenticator to the beginning of the flow if you still want end users to confirm their profile information. You can also add authentication mechanisms to this flow, forcing a user to verify his credentials. This would require a more complex flow, for example setting the "Automatically Set Existing User" and "Password Form" as "Required" in an "Alternative" sub-flow.
					</p></div></div></section><section class="section" id="disabling_automatic_user_creation"><div class="titlepage"><div><div><h3 class="title">12.10.3. Disabling Automatic User Creation</h3></div></div></div><p>
					The Default first login flow will look up a Keycloak account matching the external identity, and will then offer to link them; if there is no matching Keycloak account, it will automatically create one. This default behavior may be unsuitable for some setups, for example, when using read-only LDAP user store (which means all users are pre-created). In this case, automatic user creation should be turned off. To disable user creation:
				</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">
							open the <code class="literal">First Broker Login</code> flow configuration;
						</li><li class="listitem">
							set <code class="literal">Create User If Unique</code> to <code class="literal">DISABLED</code>;
						</li><li class="listitem">
							set <code class="literal">Confirm Link Existing Account</code> to <code class="literal">DISABLED</code>.
						</li></ul></div><p>
					This configuration also implies that Keycloak itself won’t be able to determine which internal account would correspond to the external identity. Therefore, the <code class="literal">Verify Existing Account By Re-authentication</code> authenticator will ask the user to provide both username and password.
				</p></section></section><section class="section" id="retrieving_external_idp_tokens"><div class="titlepage"><div><div><h2 class="title">12.11. Retrieving External IDP Tokens</h2></div></div></div><p>
				Red Hat Single Sign-On allows you to store tokens and responses from the authentication process with the external IDP. For that, you can use the <code class="literal">Store Token</code> configuration option on the IDP’s settings page.
			</p><p>
				Application code can retrieve these tokens and responses to pull in extra user information, or to securely invoke requests on the external IDP. For example, an application might want to use the Google token to invoke on other Google services and REST APIs. To retrieve a token for a particular identity provider you need to send a request as follows:
			</p><pre class="screen">GET /auth/realms/{realm}/broker/{provider_alias}/token HTTP/1.1
Host: localhost:8080
Authorization: Bearer &lt;KEYCLOAK ACCESS TOKEN&gt;</pre><p>
				An application must have authenticated with Red Hat Single Sign-On and have received an access token. This access token will need to have the <code class="literal">broker</code> client-level role <code class="literal">read-token</code> set. This means that the user must have a role mapping for this role and the client application must have that role within its scope. In this case, given that you are accessing a protected service in Red Hat Single Sign-On, you need to send the access token issued by Red Hat Single Sign-On during the user authentication. In the broker configuration page you can automatically assign this role to newly imported users by turning on the <code class="literal">Stored Tokens Readable</code> switch.
			</p><p>
				These external tokens can be re-established by either logging in again through the provider, or using the client-initiated account linking API.
			</p></section><section class="section" id="identity_broker_logout"><div class="titlepage"><div><div><h2 class="title">12.12. Identity broker logout</h2></div></div></div><p>
				When logout from Red Hat Single Sign-On is triggered, Red Hat Single Sign-On will send a request to the external identity provider that was used to login to Keycloak, and the user will be logged out from this identity provider as well. It is possible to skip this behavior and avoid logout at the external identity provider. See <a class="link" href="https://access.redhat.com/documentation/en-us/red_hat_single_sign-on/7.4/html-single/securing_applications_and_services_guide/#_java_adapter_logout">adapter logout documentation</a> for more details.
			</p></section></section><section class="chapter" id="user_session_management"><div class="titlepage"><div><div><h1 class="title">Chapter 13. User Session Management</h1></div></div></div><p>
			When a user logs into a realm, Red Hat Single Sign-On maintains a user session for them and remembers each and every client they have visited within the session. There are a lot of administrative functions that realm admins can perform on these user sessions. They can view login stats for the entire realm and dive down into each client to see who is logged in and where. Admins can logout a user or a set of users from the Admin Console. They can revoke tokens and set up all the token and session timeouts there too.
		</p><section class="section" id="administering_sessions"><div class="titlepage"><div><div><h2 class="title">13.1. Administering Sessions</h2></div></div></div><p>
				If you go to the <code class="literal">Sessions</code> left menu item you can see a top level view of the number of sessions that are currently active in the realm.
			</p><div class="formalpara"><p class="title"><strong>Sessions</strong></p><p>
					<span class="inlinemediaobject"><img src="images/rhsso-images/sessions.png" alt="sessions"/></span>
				</p></div><p>
				A list of clients is given and how many active sessions there currently are for that client. You can also log out all users in the realm by clicking the <code class="literal">Logout all</code> button on the right side of this list.
			</p><section class="section" id="limitations_of_the_literal_logout_all_literal_operation"><div class="titlepage"><div><div><h3 class="title">13.1.1. Limitations of the <code class="literal">Logout all</code> Operation</h3></div></div></div><p>
					Any SSO cookies set will now be invalid and clients that request authentication in active browser sessions will now have to re-login. Only certain clients are notified of this logout event, specifically clients that are using the Red Hat Single Sign-On OIDC client adapter. Other client types, such as SAML, will not receive a backchannel logout request.
				</p><p>
					It is important to note that any outstanding access tokens are not revoked by clicking <code class="literal">Logout all</code>. They have to expire naturally. You have to push a <a class="link" href="#revocation-policy" title="13.2. Revocation Policies">revocation policy</a> out to clients, but that also only works with clients using the Red Hat Single Sign-On OIDC client adapter.
				</p></section><section class="section" id="application_drilldown"><div class="titlepage"><div><div><h3 class="title">13.1.2. Application Drilldown</h3></div></div></div><p>
					On the <code class="literal">Sessions</code> page, you can also drill down to each client. This will bring you to the <code class="literal">Sessions</code> tab of that client. Clicking on the <code class="literal">Show Sessions</code> button there allows you to see which users are logged into that application.
				</p><div class="formalpara"><p class="title"><strong>Application Sessions</strong></p><p>
						<span class="inlinemediaobject"><img src="images/rhsso-images/application-sessions.png" alt="application sessions"/></span>
					</p></div></section><section class="section" id="user_drilldown"><div class="titlepage"><div><div><h3 class="title">13.1.3. User Drilldown</h3></div></div></div><p>
					If you go to the <code class="literal">Sessions</code> tab of an individual user, you can also view the session information.
				</p><div class="formalpara"><p class="title"><strong>User Sessions</strong></p><p>
						<span class="inlinemediaobject"><img src="images/rhsso-images/user-sessions.png" alt="user sessions"/></span>
					</p></div></section></section><section class="section" id="revocation-policy"><div class="titlepage"><div><div><h2 class="title">13.2. Revocation Policies</h2></div></div></div><p>
				If your system is compromised you will want a way to revoke all sessions and access tokens that have been handed out. You can do this by going to the <code class="literal">Revocation</code> tab of the <code class="literal">Sessions</code> screen.
			</p><div class="formalpara"><p class="title"><strong>Revocation</strong></p><p>
					<span class="inlinemediaobject"><img src="images/rhsso-images/revocation.png" alt="revocation"/></span>
				</p></div><p>
				You can only set a time-based revocation policy. The console allows you to specify a time and date where any session or token issued before that time and date is invalid. The <code class="literal">Set to now</code> will set the policy to the current time and date. The <code class="literal">Push</code> button will push this revocation policy to any registered OIDC client that has the Red Hat Single Sign-On OIDC client adapter installed.
			</p></section><section class="section" id="timeouts"><div class="titlepage"><div><div><h2 class="title">13.3. Session and Token Timeouts</h2></div></div></div><p>
				Red Hat Single Sign-On gives you fine grain control of session, cookie, and token timeouts. This is all done on the <code class="literal">Tokens</code> tab in the <code class="literal">Realm Settings</code> left menu item.
			</p><div class="formalpara"><p class="title"><strong>Tokens Tab</strong></p><p>
					<span class="inlinemediaobject"><img src="images/rhsso-images/tokens-tab.png" alt="tokens tab"/></span>
				</p></div><p>
				Let’s walk through each of the items on this page.
			</p><div class="informaltable"><table class="lt-4-cols lt-7-rows"><colgroup><col style="width: 50%; " class="col_1"/><col style="width: 50%; " class="col_2"/></colgroup><thead><tr><th align="left" valign="top" id="idm140464620686592" scope="col">Configuration</th><th align="left" valign="top" id="idm140464620685504" scope="col">Description</th></tr></thead><tbody><tr><td align="left" valign="top" headers="idm140464620686592">
							<p>
								Default Signature Algorithm
							</p>
							</td><td align="left" valign="top" headers="idm140464620685504">
							<p>
								The default algorithm that is used to assign tokens for this realm.
							</p>
							</td></tr><tr><td align="left" valign="top" headers="idm140464620686592">
							<p>
								Revoke Refresh Token
							</p>
							</td><td align="left" valign="top" headers="idm140464620685504">
							<p>
								For OIDC clients that are doing the refresh token flow, this flag, if on, will revoke that refresh token and issue another token with the request that the client has to use. The result is that each refresh token is used only once.
							</p>
							</td></tr><tr><td align="left" valign="top" headers="idm140464620686592">
							<p>
								SSO Session Idle
							</p>
							</td><td align="left" valign="top" headers="idm140464620685504">
							<p>
								Also pertains to OIDC clients. If the user is not active for longer than this timeout, the user session will be invalidated. The idle timeout is reset by a client requesting authentication or by a refresh token request. There is a small window of time that is always added to the idle timeout before the session invalidation takes effect. See the note below.
							</p>
							</td></tr><tr><td align="left" valign="top" headers="idm140464620686592">
							<p>
								SSO Session Max
							</p>
							</td><td align="left" valign="top" headers="idm140464620685504">
							<p>
								Maximum time before a user session is expired and invalidated. This option controls the maximum time that a user session can remain active, regardless of user activity.
							</p>
							</td></tr><tr><td align="left" valign="top" headers="idm140464620686592">
							<p>
								SSO Session Idle Remember Me
							</p>
							</td><td align="left" valign="top" headers="idm140464620685504">
							<p>
								Same as the standard SSO Session Idle configuration but specific to logins with Remember Me enabled. It allows for the specification of longer session idle timeouts when Remember Me is selected during the login process. It is an optional configuration and if not set to a value greater than 0 it uses the same idle timeout as set in the SSO Session Idle configuration.
							</p>
							</td></tr><tr><td align="left" valign="top" headers="idm140464620686592">
							<p>
								SSO Session Max Remember Me
							</p>
							</td><td align="left" valign="top" headers="idm140464620685504">
							<p>
								Same as the standard SSO Session Max but specific to logins with Remember Me enabled. It allows for the specification of longer lived sessions when Remember Me is selected during the login process. It is an optional configuration and if not set to a value greater than 0 it uses the same session lifespan as set in the SSO Session Max configuration.
							</p>
							</td></tr><tr><td align="left" valign="top" headers="idm140464620686592">
							<p>
								Offline Session Idle
							</p>
							</td><td align="left" valign="top" headers="idm140464620685504">
							<p>
								For <a class="link" href="#offline-access" title="13.4. Offline Access">offline access</a>, this is the time the session is allowed to remain idle before the offline token is revoked. There is a small window of time that is always added to the idle timeout before the session invalidation takes effect. See the note below.
							</p>
							</td></tr><tr><td align="left" valign="top" headers="idm140464620686592">
							<p>
								Offline Session Max Limited
							</p>
							</td><td align="left" valign="top" headers="idm140464620685504">
							<p>
								For <a class="link" href="#offline-access" title="13.4. Offline Access">offline access</a>, if this flag is on, Offline Session Max is enabled to control the maximum time the offline token can remain active, regardless of user activity.
							</p>
							</td></tr><tr><td align="left" valign="top" headers="idm140464620686592">
							<p>
								Offline Session Max
							</p>
							</td><td align="left" valign="top" headers="idm140464620685504">
							<p>
								For <a class="link" href="#offline-access" title="13.4. Offline Access">offline access</a>, this is the maximum time before the corresponding offline token is revoked. This option controls the maximum time the offline token can remain active, regardless of user activity.
							</p>
							</td></tr><tr><td align="left" valign="top" headers="idm140464620686592">
							<p>
								Client Session Idle
							</p>
							</td><td align="left" valign="top" headers="idm140464620685504">
							<p>
								If the user is not active for longer than this timeout, refresh token requests will bump the idle timeout. It allows for the specification of a shorter idle timeout of refresh token than session idle timeout. And it can be overridden on individual clients. It is an optional configuration and if not set to a value bigger than 0 it uses the same idle timeout set in the SSO Session Idle configuration.
							</p>
							</td></tr><tr><td align="left" valign="top" headers="idm140464620686592">
							<p>
								Client Session Max
							</p>
							</td><td align="left" valign="top" headers="idm140464620685504">
							<p>
								The maximum time before a refresh token is expired and invalidated. It allows for the specification of a shorter timeout of refresh token than session timeout. And it can be overridden on individual clients. It is an optional configuration and if not set to a value bigger than 0 it uses the same idle timeout set in the SSO Session Max configuration.
							</p>
							</td></tr><tr><td align="left" valign="top" headers="idm140464620686592">
							<p>
								Access Token Lifespan
							</p>
							</td><td align="left" valign="top" headers="idm140464620685504">
							<p>
								When an OIDC access token is created, this value affects the expiration.
							</p>
							</td></tr><tr><td align="left" valign="top" headers="idm140464620686592">
							<p>
								Access Token Lifespan For Implicit Flow
							</p>
							</td><td align="left" valign="top" headers="idm140464620685504">
							<p>
								With the Implicit Flow no refresh token is provided. For this reason there’s a separate timeout for access tokens created with the Implicit Flow.
							</p>
							</td></tr><tr><td align="left" valign="top" headers="idm140464620686592">
							<p>
								Client login timeout
							</p>
							</td><td align="left" valign="top" headers="idm140464620685504">
							<p>
								This is the maximum time that a client has to finish the Authorization Code Flow in OIDC.
							</p>
							</td></tr><tr><td align="left" valign="top" headers="idm140464620686592">
							<p>
								Login timeout
							</p>
							</td><td align="left" valign="top" headers="idm140464620685504">
							<p>
								Total time a login must take. If authentication takes longer than this time then the user will have to start the authentication process over.
							</p>
							</td></tr><tr><td align="left" valign="top" headers="idm140464620686592">
							<p>
								Login action timeout
							</p>
							</td><td align="left" valign="top" headers="idm140464620685504">
							<p>
								Maximum time a user can spend on any one page in the authentication process.
							</p>
							</td></tr><tr><td align="left" valign="top" headers="idm140464620686592">
							<p>
								User-Initiated Action Lifespan
							</p>
							</td><td align="left" valign="top" headers="idm140464620685504">
							<p>
								Maximum time before an action permit sent by a user (e.g. forgot password e-mail) is expired. This value is recommended to be short because it is expected that the user would react to self-created action quickly.
							</p>
							</td></tr><tr><td align="left" valign="top" headers="idm140464620686592">
							<p>
								Default Admin-Initiated Action Lifespan
							</p>
							</td><td align="left" valign="top" headers="idm140464620685504">
							<p>
								Maximum time before an action permit sent to a user by an admin is expired. This value is recommended to be long to allow admins send e-mails for users that are currently offline. The default timeout can be overridden right before issuing the token.
							</p>
							</td></tr><tr><td align="left" valign="top" headers="idm140464620686592">
							<p>
								Override User-Initiated Action Lifespan
							</p>
							</td><td align="left" valign="top" headers="idm140464620685504">
							<p>
								Permits the possibility of having independent timeouts per operation (for example, e-mail verification, forgot password, user actions and Identity Provider E-mail Verification). This field is optional. If nothing is specified, it defaults to the value configured at <span class="emphasis"><em>User-Initiated Action Lifespan</em></span>.
							</p>
							</td></tr></tbody></table></div><div class="admonition note"><div class="admonition_header">Note</div><div><p>
					For idle timeouts, there is a small window of time (2 minutes) during which the session is kept unexpired. For example, when you have timeout set to 30 minutes, it will be actually 32 minutes before the session is expired. This is needed for some corner-case scenarios in cluster and cross-datacenter environments, in cases where the token was refreshed on one cluster node for a very short time before the expiration and the other cluster nodes would in the meantime incorrectly consider the session as expired, because they had not yet received the message about successful refresh from the node which did the refresh.
				</p></div></div></section><section class="section" id="offline-access"><div class="titlepage"><div><div><h2 class="title">13.4. Offline Access</h2></div></div></div><p>
				Offline access is a feature described in <a class="link" href="https://openid.net/specs/openid-connect-core-1_0.html#OfflineAccess">OpenID Connect specification</a> . The idea is that during login, your client application will request an Offline token instead of a classic Refresh token. The application can save this offline token in a database or on disk and can use it later even if user is logged out. This is useful if your application needs to do some "offline" actions on behalf of user even when the user is not online. An example is a periodic backup of some data every night.
			</p><p>
				Your application is responsible for persisting the offline token in some storage (usually a database) and then using it to retrieve new access token from Red Hat Single Sign-On server.
			</p><p>
				The difference between a classic Refresh token and an Offline token is, that an offline token will never expire by default and is not subject of the <code class="literal">SSO Session Idle timeout</code> and <code class="literal">SSO Session Max lifespan</code>. The offline token is valid even after a user logout or server restart. However by default you do need to use the offline token for a refresh token action at least once per 30 days (this value, <code class="literal">Offline Session Idle timeout</code>, can be changed in the administration console in the <code class="literal">Tokens</code> tab under <code class="literal">Realm Settings</code>). Moreover, if you enable the option <code class="literal">Offline Session Max Limited</code>, then the offline token expires after 60 days regardless of using the offline token for a refresh token action (this value, <code class="literal">Offline Session Max</code>, can also be changed in the administration console in the Tokens tab under Realm Settings). Also if you enable the option <code class="literal">Revoke refresh tokens</code>, then each offline token can be used just once. So after refresh, you always need to store the new offline token from refresh response into your DB instead of the previous one.
			</p><p>
				Users can view and revoke offline tokens that have been granted by them in the <a class="link" href="#account-service" title="Chapter 18. User Account Service">User Account Service</a>. The admin user can revoke offline tokens for individual users in admin console in the <code class="literal">Consents</code> tab of a particular user. The admin can also view all the offline tokens issued in the <code class="literal">Offline Access</code> tab of each client. Offline tokens can also be revoked by setting a <a class="link" href="#revocation-policy" title="13.2. Revocation Policies">revocation policy</a>.
			</p><p>
				To be able to issue an offline token, users need to have the role mapping for the realm-level role <code class="literal">offline_access</code>. Clients also need to have that role in their scope. Finally, the client needs to have an <code class="literal">offline_access</code> client scope added as an <code class="literal">Optional client scope</code> to it, which is done by default.
			</p><p>
				The client can request an offline token by adding the parameter <code class="literal">scope=offline_access</code> when sending authorization request to Red Hat Single Sign-On. The Red Hat Single Sign-On OIDC client adapter automatically adds this parameter when you use it to access secured URL of your application (i.e. http://localhost:8080/customer-portal/secured?scope=offline_access). The Direct Access Grant and Service Accounts also support offline tokens if you include <code class="literal">scope=offline_access</code> in the body of the authentication request.
			</p></section></section><section class="chapter" id="user-storage-federation"><div class="titlepage"><div><div><h1 class="title">Chapter 14. User Storage Federation</h1></div></div></div><p>
			Many companies have existing user databases that hold information about users and their passwords or other credentials. In many cases, it is just not possible to migrate off of those existing stores to a pure Red Hat Single Sign-On deployment. Red Hat Single Sign-On can federate existing external user databases. By default, we support LDAP and Active Directory, but you can also code your own extension for any custom user database using our User Storage SPI.
		</p><p>
			The way it works is that when a user logs in, Red Hat Single Sign-On will look into its own internal user store to find the user. If it cannot find it there, it will iterate over every User Storage provider you have configured for the realm until it finds a match. Data from the external store is mapped into a common user model that is consumed by the Red Hat Single Sign-On runtime. This common user model can then be mapped to OIDC token claims and SAML assertion attributes.
		</p><p>
			External user databases rarely have every piece of data needed to support all the features that Red Hat Single Sign-On has. Therefore, the User Storage Provider can opt to store some things locally in the Red Hat Single Sign-On user store. Some providers even import the user locally and sync periodically with the external store. This approach depends on the capabilities of the provider and how it is configured. For example, your external user store may not support OTP. Depending on the provider, this OTP can be handled and stored by Red Hat Single Sign-On.
		</p><section class="section" id="adding_a_provider"><div class="titlepage"><div><div><h2 class="title">14.1. Adding a Provider</h2></div></div></div><p>
				To add a storage provider go to the <code class="literal">User Federation</code> left menu item in the Admin Console.
			</p><div class="formalpara"><p class="title"><strong>User Federation</strong></p><p>
					<span class="inlinemediaobject"><img src="images/rhsso-images/user-federation.png" alt="user federation"/></span>
				</p></div><p>
				On the center, there is an <code class="literal">Add Provider</code> list box. Choose the provider type you want to add and you will be brought to the configuration page of that provider.
			</p></section><section class="section" id="dealing_with_provider_failures"><div class="titlepage"><div><div><h2 class="title">14.2. Dealing with Provider Failures</h2></div></div></div><p>
				If a User Storage Provider fails (for example, your LDAP server is down), you may have trouble logging in and may not be able to view users in the admin console. Red Hat Single Sign-On does not catch failures when using a Storage Provider to lookup a user. It will abort the invocation. So, if you have a Storage Provider with a higher priority that fails during user lookup, the login or user query will fail entirely with an exception and abort. It will not fail over to the next configured provider.
			</p><p>
				The local Red Hat Single Sign-On user database is always searched first to resolve users before any LDAP or custom User Storage Provider. You may want to consider creating an admin account that is stored in the local Red Hat Single Sign-On user database just in case any problems come up in connecting to your LDAP and custom back ends.
			</p><p>
				Each LDAP and custom User Storage Provider has an <code class="literal">enable</code> switch on its admin console page. Disabling the User Storage Provider will skip the provider when doing user queries so that you can view and login with users that might be stored in a different provider with lower priority. If your provider is using an <code class="literal">import</code> strategy and you disable it, imported users are still available for lookup, but only in read only mode. You will not be able to modify these users until you re-enable the provider.
			</p><p>
				The reason why Red Hat Single Sign-On does not fail over if a Storage Provider lookup fails is that user databases often have duplicate usernames or duplicate emails between them. This can cause security issues and unforeseen problems as the user may be loaded from one external store when the admin is expecting the user to be loaded from another.
			</p></section><section class="section" id="ldap"><div class="titlepage"><div><div><h2 class="title">14.3. LDAP and Active Directory</h2></div></div></div><p>
				Red Hat Single Sign-On comes with a built-in LDAP/AD provider. It is possible to federate multiple different LDAP servers in the same Red Hat Single Sign-On realm. You can map LDAP user attributes into the Red Hat Single Sign-On common user model. By default, it maps username, email, first name, and last name, but you are free to configure additional <a class="link" href="#ldap_mappers" title="14.3.6. LDAP Mappers">mappings</a>. The LDAP provider also supports password validation via LDAP/AD protocols and different storage, edit, and synchronization modes.
			</p><p>
				To configure a federated LDAP store go to the Admin Console. Click on the <code class="literal">User Federation</code> left menu option. When you get to this page there is an <code class="literal">Add Provider</code> select box. You should see <span class="emphasis"><em>ldap</em></span> within this list. Selecting <span class="emphasis"><em>ldap</em></span> will bring you to the LDAP configuration page.
			</p><section class="section" id="storage_mode"><div class="titlepage"><div><div><h3 class="title">14.3.1. Storage Mode</h3></div></div></div><p>
					By default, Red Hat Single Sign-On will import users from LDAP into the local Red Hat Single Sign-On user database. This copy of the user is either synchronized on demand, or through a periodic background task. The single exception to this is the synchronization of passwords. Passwords are never imported. Their validation is always delegated to the LDAP server. The benefits of this approach is that all Red Hat Single Sign-On features will work as any extra per-user data that is needed can be stored locally. The downside of this approach is that each time that a specific user is queried for the first time, a corresponding Red Hat Single Sign-On database insert is performed. The import may also have to be synchronized with your LDAP server. However, import synchronization is not necessary in the case that the LDAP mappers are configured to always read particular attributes from the LDAP rather than from the database.
				</p><p>
					Alternatively, you can choose not to import users into the Red Hat Single Sign-On user database. In this case, the common user model that the Red Hat Single Sign-On runtime uses is backed only by the LDAP server. This means that if LDAP doesn’t support a piece of data that a Red Hat Single Sign-On feature needs that feature will not work. The benefit to this approach is that you do not have the overhead of importing and synchronizing a copy of the LDAP user into the Red Hat Single Sign-On user database.
				</p><p>
					This storage mode is controled by the <code class="literal">Import Users</code> switch. Set to <code class="literal">On</code> to import users.
				</p><div class="admonition note"><div class="admonition_header">Note</div><div><p>
						If user import is disabled, you cannot save user profile attributes into the Red Hat Single Sign-On database. Also you cannot save metadata except for user profile metadata that are mapped to the LDAP. The single exception to this are user profile metadata, which are mapped to the LDAP. This possibly includes role mappings, group mappings and other metadata based on the configuration of your LDAP mappers. When the attempt is made to change some of the non-LDAP mapped user data, the update of the user will not be possible. For example you will not be able to disable the LDAP mapped user unless the <code class="literal">enabled</code> flag of the user is mapped to some LDAP attribute (which is usually not the case).
					</p></div></div></section><section class="section" id="edit_mode"><div class="titlepage"><div><div><h3 class="title">14.3.2. Edit Mode</h3></div></div></div><p>
					Users, through the <a class="link" href="#account-service" title="Chapter 18. User Account Service">User Account Service</a>, and admins through the Admin Console have the ability to modify user metadata. Depending on your setup you may or may not have LDAP update privileges. The <code class="literal">Edit Mode</code> configuration option defines the edit policy you have with your LDAP store.
				</p><div class="variablelist"><dl class="variablelist"><dt><span class="term">READONLY</span></dt><dd>
								Username, email, first name, last name, and other mapped attributes will be unchangeable. Red Hat Single Sign-On will show an error anytime anybody tries to update these fields. Also, password updates will not be supported.
							</dd><dt><span class="term">WRITABLE</span></dt><dd>
								Username, email, first name, last name, and other mapped attributes and passwords can all be updated and will be synchronized automatically with your LDAP store.
							</dd><dt><span class="term">UNSYNCED</span></dt><dd>
								Any changes to username, email, first name, last name, and passwords will be stored in Red Hat Single Sign-On local storage. It is up to you to figure out how to synchronize back to LDAP. This allows Red Hat Single Sign-On deployments to support updates of user metadata on a read-only LDAP server. This option only applies when you are importing users from LDAP into the local Red Hat Single Sign-On user database.
							</dd></dl></div><div class="admonition note"><div class="admonition_header">Note</div><div><p>
						When the LDAP provider is created, the set of initial <a class="link" href="#ldap_mappers" title="14.3.6. LDAP Mappers">LDAP mappers</a> is created. The mappers are configured on a "best-effort" basis based on the chosen combination of the <code class="literal">Vendor</code>, <code class="literal">Edit Mode</code>, and <code class="literal">Import Users</code> switches. For example in case of UNSYNCED edit mode, the mappers are pre-configured in a way that a particular user attribute is preferably read from the database instead of from the LDAP. However when you later change the edit mode, the mappers configuration will not be changed as it is not easily possible to detect if they were manually changed in the meantime. This means that it is recommended NOT to update the <code class="literal">Edit Mode</code> switch, but rather always decide on <code class="literal">Edit Mode</code> when creating the LDAP provider. This applies for <code class="literal">Import Users</code> switch as well.
					</p></div></div></section><section class="section" id="other_config_options"><div class="titlepage"><div><div><h3 class="title">14.3.3. Other config options</h3></div></div></div><div class="variablelist"><dl class="variablelist"><dt><span class="term">Console Display Name</span></dt><dd>
								Name used when this provider is referenced in the admin console
							</dd><dt><span class="term">Priority</span></dt><dd>
								The priority of this provider when looking up users or adding a user.
							</dd><dt><span class="term">Sync Registrations</span></dt><dd>
								Does your LDAP support adding new users? Click this switch if you want new users created by Red Hat Single Sign-On in the admin console or the registration page to be added to LDAP.
							</dd><dt><span class="term">Allow Kerberos authentication</span></dt><dd>
								Enable Kerberos/SPNEGO authentication in realm with users data provisioned from LDAP. More info in <a class="link" href="#kerberos" title="6.4. Kerberos">Kerberos section</a>.
							</dd><dt><span class="term">Other options</span></dt><dd>
								The rest of the configuration options should be self explanatory. You can hover the mouse pointer over the tooltips in the Admin Console to see some more details about them.
							</dd></dl></div></section><section class="section" id="connect_to_ldap_over_ssl"><div class="titlepage"><div><div><h3 class="title">14.3.4. Connect to LDAP over SSL</h3></div></div></div><p>
					When you configure a secured connection URL to your LDAP store (for example,`ldaps://myhost.com:636'), Red Hat Single Sign-On will use SSL for communication with the LDAP server. The important thing is to properly configure a truststore on the Red Hat Single Sign-On server side, otherwise Red Hat Single Sign-On can’t trust the SSL connection to LDAP.
				</p><p>
					The global truststore for the Red Hat Single Sign-On can be configured with the Truststore SPI. Please check out the <a class="link" href="https://access.redhat.com/documentation/en-us/red_hat_single_sign-on/7.4/html-single/server_installation_and_configuration_guide/">Server Installation and Configuration Guide</a> for more details. If you do not figure the truststore SPI, the truststore will fall back on the default mechanism provided by Java (either the file provided by system property <code class="literal">javax.net.ssl.trustStore</code> or the cacerts file from the JDK if the system property is not set).
				</p><p>
					There is a configuration property <code class="literal">Use Truststore SPI</code> in the LDAP federation provider configuration, where you can choose whether the Truststore SPI is used. By default, the value is <code class="literal">Only for ldaps</code>, which is fine for most deployments. The Truststore SPI will only be used if the connection URL to LDAP starts with <code class="literal">ldaps</code>.
				</p></section><section class="section" id="sync_of_ldap_users_to_red_hat_single_sign_on"><div class="titlepage"><div><div><h3 class="title">14.3.5. Sync of LDAP users to Red Hat Single Sign-On</h3></div></div></div><p>
					If you enable the Import Users option, the LDAP Provider will automatically take care of synchronization (import) of needed LDAP users into the Red Hat Single Sign-On local database. As users log in, the LDAP provider will import the LDAP user into the Red Hat Single Sign-On database and then authenticate against the LDAP password. This is the only time users will be imported. If you go to the <code class="literal">Users</code> left menu item in the Admin Console and click the <code class="literal">View all users</code> button, you will only see those LDAP users that have been authenticated at least once by Red Hat Single Sign-On. It is implemented this way so that this operation does not trigger an import of the entire LDAP user database.
				</p><p>
					If you want to sync all LDAP users into the Red Hat Single Sign-On database, you may configure and enable the <code class="literal">Sync Settings</code> on the LDAP provider configuration page. Two types of synchronization exist:
				</p><div class="variablelist"><dl class="variablelist"><dt><span class="term">Periodic Full sync</span></dt><dd>
								This type will synchronize all LDAP users into the Red Hat Single Sign-On database. Those LDAP users, which already exist in Red Hat Single Sign-On and were changed in LDAP directly will be updated in the Red Hat Single Sign-On database. For example, the user <code class="literal">Mary Kelly</code> was changed in LDAP to <code class="literal">Mary Smith</code>.
							</dd><dt><span class="term">Periodic Changed users sync</span></dt><dd>
								When syncing occurs, only those users that were created or updated after the last sync will be updated and/or imported.
							</dd></dl></div><p>
					The best way to handle syncing is to click the <code class="literal">Synchronize all users</code> button when you first create the LDAP provider, then set up a periodic sync of changed users.
				</p></section><section class="section" id="ldap_mappers"><div class="titlepage"><div><div><h3 class="title">14.3.6. LDAP Mappers</h3></div></div></div><p>
					LDAP mappers are <code class="literal">listeners</code>, which are triggered by the LDAP Provider at various points and provide another extension point to LDAP integration. They are triggered when a user logs in via LDAP and needs to be imported, during Red Hat Single Sign-On initiated registration, or when a user is queried from the Admin Console. When you create an LDAP Federation provider, Red Hat Single Sign-On will automatically provide set of built-in <code class="literal">mappers</code> for this provider. You are free to change this set and create a new mapper or update/delete existing ones.
				</p><div class="variablelist"><dl class="variablelist"><dt><span class="term">User Attribute Mapper</span></dt><dd>
								This allows you to specify which LDAP attribute is mapped to which attribute of Red Hat Single Sign-On user. So, for example, you can configure that LDAP attribute <code class="literal">mail</code> to the attribute <code class="literal">email</code> in the Red Hat Single Sign-On database. For this mapper implementation, there is always a one-to-one mapping (one LDAP attribute is mapped to one Red Hat Single Sign-On attribute)
							</dd><dt><span class="term">FullName Mapper</span></dt><dd>
								This allows you to specify that the full name of the user, which is saved in some LDAP attribute (usually <code class="literal">cn</code> ) will be mapped to <code class="literal">firstName</code> and <code class="literal">lastname</code> attributes in the Red Hat Single Sign-On database. Having <code class="literal">cn</code> to contain full name of user is a common case for some LDAP deployments.
							</dd></dl></div><div class="admonition note"><div class="admonition_header">Note</div><div><p>
						When registering new users in Red Hat Single Sign-On and <code class="literal">Sync Registrations</code> is ON for the LDAP provider, the fullName mapper allows the possibility of fallback to the username. This fallback is especially useful in case of the Microsoft Active Directory. The common setup for the MSAD is to configure <code class="literal">cn</code> LDAP attribute as fullName and at the same time, the <code class="literal">cn</code> is usually used as <code class="literal">RDN LDAP Attribute</code> in the configuration of the LDAP provider. With this setup, the fallback to the username will be used. For example when you create Red Hat Single Sign-On user "john123" and leave firstName and lastName empty, then fullname mapper will save "john123" as the value of the <code class="literal">cn</code> in LDAP. When you later enter "John Doe" for firstName and lastName, the fullname mapper will update LDAP <code class="literal">cn</code> to the value "John Doe" as fallback to the username will not be needed anymore.
					</p></div></div><div class="variablelist"><dl class="variablelist"><dt><span class="term">Hardcoded Attribute Mapper</span></dt><dd>
								This mapper adds a hardcoded attribute value to each Red Hat Single Sign-On user linked with LDAP. This mapper can also force the values for the <code class="literal">enabled</code> or <code class="literal">emailVerified</code> user properties.
							</dd><dt><span class="term">Role Mapper</span></dt><dd>
								This allows you to configure role mappings from LDAP into Red Hat Single Sign-On role mappings. One Role mapper can be used to map LDAP roles (usually groups from a particular branch of LDAP tree) into roles corresponding to either realm roles or client roles of a specified client. It’s not a problem to configure more Role mappers for the same LDAP provider. So for example you can specify that role mappings from groups under <code class="literal">ou=main,dc=example,dc=org</code> will be mapped to realm role mappings and role mappings from groups under <code class="literal">ou=finance,dc=example,dc=org</code> will be mapped to client role mappings of client <code class="literal">finance</code>.
							</dd><dt><span class="term">Hardcoded Role Mapper</span></dt><dd>
								This mapper will grant a specified Red Hat Single Sign-On role to each Red Hat Single Sign-On user from the LDAP provider.
							</dd><dt><span class="term">Group Mapper</span></dt><dd>
								This allows you to map LDAP groups from a particular branch of an LDAP tree into groups in Red Hat Single Sign-On. It will also propagate user-group mappings from LDAP into user-group mappings in Red Hat Single Sign-On.
							</dd><dt><span class="term">MSAD User Account Mapper</span></dt><dd>
								This mapper is specific to Microsoft Active Directory (MSAD). It’s able to tightly integrate the MSAD user account state into the Red Hat Single Sign-On account state (account enabled, password is expired, and so on). It is using the <code class="literal">userAccountControl</code> and <code class="literal">pwdLastSet</code> LDAP attributes, which are both specific to MSAD and are not LDAP standard. For example if <code class="literal">pwdLastSet</code> is <code class="literal">0</code>, the Red Hat Single Sign-On user is required to update their password and there will be an UPDATE_PASSWORD required action added to the user. If <code class="literal">userAccountControl</code> is <code class="literal">514</code> (disabled account) the Red Hat Single Sign-On user is disabled as well.
							</dd><dt><span class="term">Certificate Mapper</span></dt><dd>
								This mapper is specific for mapping X.509 certificates. It will generally be used in conjunction with X.509 authentication and <code class="literal">Full certificate in PEM format</code> as an identity source. It behaves the same way as the <code class="literal">User Attribute Mapper</code>, but allows Red Hat Single Sign-On to filter for an LDAP attribute which stores a certificate in either PEM or DER format. It is generally advised to enable <code class="literal">Always Read Value From LDAP</code> with this mapper.
							</dd></dl></div><p>
					By default, there are User Attribute mappers that map basic Red Hat Single Sign-On user attributes like username, firstname, lastname, and email to corresponding LDAP attributes. You are free to extend these and provide additional attribute mappings. Admin console provides tooltips, which should help with configuring the corresponding mappers.
				</p></section><section class="section" id="ldap_password_hashing"><div class="titlepage"><div><div><h3 class="title">14.3.7. Password Hashing</h3></div></div></div><p>
					When the password of user is updated from Red Hat Single Sign-On and sent to LDAP, it is always sent in plain-text. This is different from updating the password to built-in Red Hat Single Sign-On database, when the hashing and salting is applied to the password before it is sent to DB. In the case of LDAP, the Red Hat Single Sign-On relies on the LDAP server to provide hashing and salting of passwords.
				</p><p>
					LDAP servers such as Microsoft Active Directory, RHDS or FreeIPA provide this by default. Others such as OpenLDAP or ApacheDS may store the passwords in plain-text by default unless you use the <span class="emphasis"><em>LDAPv3 Password Modify Extended Operation</em></span> as per <span class="strong strong"><strong>RFC3062</strong></span>. The LDAPv3 Password Modify Extended Operation must be enabled explicitly in the LDAP configuration page. See the documentation of your LDAP server for more details.
				</p><div class="admonition warning"><div class="admonition_header">Warning</div><div><p>
						Always verify that user passwords are properly hashed and not stored as plaintext by inspecting a changed directory entry using <code class="literal">ldapsearch</code> and base64 decode the <code class="literal">userPassword</code> attribute value.
					</p></div></div></section></section><section class="section" id="sssd"><div class="titlepage"><div><div><h2 class="title">14.4. SSSD and FreeIPA Identity Management Integration</h2></div></div></div><p>
				Red Hat Single Sign-On also comes with a built-in <a class="link" href="https://fedoraproject.org/wiki/Features/SSSD">SSSD</a> (System Security Services Daemon) plugin. SSSD is part of the latest Fedora or Red Hat Enterprise Linux and provides access to multiple identity and authentication providers. It provides benefits such as failover and offline support. To see configuration options and for more information see <a class="link" href="https://access.redhat.com/documentation/en-us/red_hat_enterprise_linux/7/html/system-level_authentication_guide/sssd">the Red Hat Enterprise Linux Identity Management documentation</a>.
			</p><p>
				SSSD also integrates with the FreeIPA identity management (IdM) server, providing authentication and access control. For Red Hat Single Sign-On, we benefit from this integration authenticating against PAM services and retrieving user data from SSSD. For more information about using Red Hat Identity Management in Linux environments, see <a class="link" href="https://access.redhat.com/documentation/en-us/red_hat_enterprise_linux/7/html/linux_domain_identity_authentication_and_policy_guide/index">the Red Hat Enterprise Linux Identity Management documentation</a>.
			</p><p>
				<span class="inlinemediaobject"><img src="images/rhsso-images/keycloak-sssd-freeipa-integration-overview.png" alt="keycloak sssd freeipa integration overview"/></span>
			</p><p>
				Most of the communication between Red Hat Single Sign-On and SSSD occurs through read-only D-Bus interfaces. For this reason, the only way to provision and update users is to use the FreeIPA/IdM administration interface. By default, like the LDAP federation provider, it is set up only to import username, email, first name, and last name.
			</p><div class="admonition note"><div class="admonition_header">Note</div><div><p>
					Groups and roles are automatically registered, but not synchronized, so any changes made by the Red Hat Single Sign-On administrator directly in Red Hat Single Sign-On are not synchronized with SSSD.
				</p></div></div><p>
				Information on how to configure the FreeIPA/IdM server follows.
			</p><section class="section" id="freeipa_idm_server"><div class="titlepage"><div><div><h3 class="title">14.4.1. FreeIPA/IdM Server</h3></div></div></div><p>
					For the sake of simplicity, a <a class="link" href="https://hub.docker.com/r/freeipa/freeipa-server/">FreeIPA Docker image</a> already available is used. To set up a server, see the <a class="link" href="https://www.freeipa.org/page/Quick_Start_Guide">FreeIPA documentation</a>.
				</p><p>
					Running a FreeIPA server with Docker requires this command:
				</p><pre class="literallayout">docker run --name freeipa-server-container -it \
-h server.freeipa.local -e PASSWORD=YOUR_PASSWORD \
-v /sys/fs/cgroup:/sys/fs/cgroup:ro \
-v /var/lib/ipa-data:/data:Z freeipa/freeipa-server</pre><p>
					The parameter <code class="literal">-h</code> with <code class="literal">server.freeipa.local</code> represents the FreeIPA/IdM server hostname. Be sure to change <code class="literal">YOUR_PASSWORD</code> to a password of your choosing.
				</p><p>
					After the container starts, change <code class="literal">/etc/hosts</code> to:
				</p><pre class="literallayout">x.x.x.x     server.freeipa.local</pre><p>
					If you do not make this change, you must set up a DNS server.
				</p><p>
					You must enroll your Linux machine in the IPA domain so that the SSSD federation provider is started and running on Red Hat Single Sign-On:
				</p><pre class="literallayout">ipa-client-install --mkhomedir -p admin -w password</pre><p>
					To ensure that everything is working as expected, on the client machine, run:
				</p><pre class="literallayout">kinit admin</pre><p>
					You should be prompted for the password. After that, you can add users to the IPA server using this command:
				</p><pre class="literallayout">$ ipa user-add john --first=John --last=Smith --email=john@smith.com --phone=042424242 --street="Testing street" \      --city="Testing city" --state="Testing State" --postalcode=0000000000 --password</pre><p>
					To force setting the user’s password, use kinit. Given the user john, you would enter this command:
				</p><pre class="literallayout">kinit john</pre><p>
					To restore normal IPA operation, you would enter these commands:
				</p><pre class="literallayout">kdestroy -A
kinit admin</pre></section><section class="section" id="sssd_and_d_bus"><div class="titlepage"><div><div><h3 class="title">14.4.2. SSSD and D-Bus</h3></div></div></div><p>
					As mentioned previously, the federation provider obtains the data from SSSD using D-BUS and authentication occurs using PAM.
				</p><p>
					First, you have to install the sssd-dbus RPM, which allows information from SSSD to be transmitted over the system bus.
				</p><pre class="literallayout">$ sudo yum install sssd-dbus</pre><p>
					You must run this provisioning script:
				</p><pre class="screen">$ .../bin/federation-sssd-setup.sh</pre><p>
					This script makes the necessary changes to <code class="literal">/etc/sssd/sssd.conf</code>:
				</p><pre class="literallayout">[domain/your-hostname.local]
...
ldap_user_extra_attrs = mail:mail, sn:sn, givenname:givenname, telephoneNumber:telephoneNumber
...
[sssd]
services = nss, sudo, pam, ssh, ifp
...
[ifp]
allowed_uids = root, yourOSUsername
user_attributes = +mail, +telephoneNumber, +givenname, +sn</pre><p>
					Also, a <code class="literal">keycloak</code> file is included under <code class="literal">/etc/pam.d/</code>:
				</p><pre class="literallayout">auth    required   pam_sss.so
account required   pam_sss.so</pre><p>
					Ensure everything is working as expected by running <code class="literal">dbus-send</code>:
				</p><pre class="literallayout">sudo dbus-send --print-reply --system --dest=org.freedesktop.sssd.infopipe /org/freedesktop/sssd/infopipe org.freedesktop.sssd.infopipe.GetUserGroups string:john</pre><p>
					You should be able to see the user’s group. If this command returns a timeout or an error, it means that the federation provider running on Red Hat Single Sign-On will also be unable to retrieve anything.
				</p><p>
					Most of the time this occurs because the machine was not enrolled in the FreeIPA IdM server or you do not have permission to access the SSSD service.
				</p><p>
					If you do not have permission, ensure that the user running the Red Hat Single Sign-On server is included in the <code class="literal">/etc/sssd/sssd.conf</code> file in the following section:
				</p><pre class="literallayout">[ifp]
allowed_uids = root, your_username</pre></section><section class="section" id="enabling_the_sssd_federation_provider"><div class="titlepage"><div><div><h3 class="title">14.4.3. Enabling the SSSD Federation Provider</h3></div></div></div><p>
					Red Hat Single Sign-On uses DBus-Java to communicate at a low level with D-Bus, which depends on the <a class="link" href="http://www.matthew.ath.cx/projects/java/">Unix Sockets Library</a>.
				</p><p>
					Before enabling the SSSD Federation provider, you must install the RPM for this library:
				</p><pre class="literallayout">$ sudo yum install rh-sso7-libunix-dbus-java</pre><p>
					For authentication with PAM Red Hat Single Sign-On uses JNA. Be sure you have this package installed:
				</p><pre class="literallayout">$ sudo yum install jna</pre><p>
					Use <code class="literal">sssctl user-checks</code> command to validate your setup:
				</p><pre class="literallayout">$ sudo sssctl user-checks admin -s keycloak</pre></section></section><section class="section" id="configuring_a_federated_sssd_store"><div class="titlepage"><div><div><h2 class="title">14.5. Configuring a Federated SSSD Store</h2></div></div></div><p>
				After the installation, you need to configure a federated SSSD store.
			</p><p>
				To configure a federated SSSD store, complete the following steps:
			</p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem">
						Navigate to the Administration Console.
					</li><li class="listitem">
						From the left menu, select <span class="strong strong"><strong>User Federation.</strong></span>
					</li><li class="listitem">
						From the <span class="strong strong"><strong>Add Provider</strong></span> dropdown list, select <span class="strong strong"><strong>sssd.</strong></span> The sssd configuration page opens.
					</li><li class="listitem">
						Click <span class="strong strong"><strong>Save</strong></span>.
					</li></ol></div><p>
				Now you can authenticate against Red Hat Single Sign-On using FreeIPA/IdM credentials.
			</p></section><section class="section" id="custom_providers"><div class="titlepage"><div><div><h2 class="title">14.6. Custom Providers</h2></div></div></div><p>
				Red Hat Single Sign-On does have an SPI for User Storage Federation that you can use to write your own custom providers. You can find documentation for this in our <a class="link" href="https://access.redhat.com/documentation/en-us/red_hat_single_sign-on/7.4/html-single/server_developer_guide/">Server Developer Guide</a>.
			</p></section></section><section class="chapter" id="auditing_and_events"><div class="titlepage"><div><div><h1 class="title">Chapter 15. Auditing and Events</h1></div></div></div><p>
			Red Hat Single Sign-On provides a rich set of auditing capabilities. Every single login action can be recorded and stored in the database and reviewed in the Admin Console. All admin actions can also be recorded and reviewed. There is also a Listener SPI with which plugins can listen for these events and perform some action. Built-in listeners include a simple log file and the ability to send an email if an event occurs.
		</p><section class="section" id="login_events"><div class="titlepage"><div><div><h2 class="title">15.1. Login Events</h2></div></div></div><p>
				Login events occur for things like when a user logs in successfully, when somebody enters in a bad password, or when a user account is updated. Every single event that happens to a user can be recorded and viewed. By default, no events are stored or viewed in the Admin Console. Only error events are logged to the console and the server’s log file. To start persisting you’ll need to enable storage. Go to the <code class="literal">Events</code> left menu item and select the <code class="literal">Config</code> tab.
			</p><div class="formalpara"><p class="title"><strong>Event Configuration</strong></p><p>
					<span class="inlinemediaobject"><img src="images/rhsso-images/login-events-config.png" alt="login events config"/></span>
				</p></div><p>
				To start storing events you’ll need to turn the <code class="literal">Save Events</code> switch to on under the <code class="literal">Login Events Settings</code>.
			</p><div class="formalpara"><p class="title"><strong>Save Events</strong></p><p>
					<span class="inlinemediaobject"><img src="images/rhsso-images/login-events-settings.png" alt="login events settings"/></span>
				</p></div><p>
				The <code class="literal">Saved Types</code> field allows you to specify which event types you want to store in the event store. The <code class="literal">Clear events</code> button allows you to delete all the events in the database. The <code class="literal">Expiration</code> field allows you to specify how long you want to keep events stored. Once you’ve enabled storage of login events and decided on your settings, don’t forget to click the <code class="literal">Save</code> button on the bottom of this page.
			</p><p>
				To view events, go to the <code class="literal">Login Events</code> tab.
			</p><div class="formalpara"><p class="title"><strong>Login Events</strong></p><p>
					<span class="inlinemediaobject"><img src="images/rhsso-images/login-events.png" alt="login events"/></span>
				</p></div><p>
				As you can see, there’s a lot of information stored and, if you are storing every event, there are a lot of events stored for each login action. The <code class="literal">Filter</code> button on this page allows you to filter which events you are actually interested in.
			</p><div class="formalpara"><p class="title"><strong>Login Event Filter</strong></p><p>
					<span class="inlinemediaobject"><img src="images/rhsso-images/login-events-filter.png" alt="login events filter"/></span>
				</p></div><p>
				In this screenshot, we’re filtering only <code class="literal">Login</code> events. Clicking the <code class="literal">Update</code> button runs the filter.
			</p><section class="section" id="event_types"><div class="titlepage"><div><div><h3 class="title">15.1.1. Event Types</h3></div></div></div><p>
					Login events:
				</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">
							Login - A user has logged in.
						</li><li class="listitem">
							Register - A user has registered.
						</li><li class="listitem">
							Logout - A user has logged out.
						</li><li class="listitem">
							Code to Token - An application/client has exchanged a code for a token.
						</li><li class="listitem">
							Refresh Token - An application/client has refreshed a token.
						</li></ul></div><p>
					Account events:
				</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">
							Social Link - An account has been linked to a social provider.
						</li><li class="listitem">
							Remove Social Link - A social provider has been removed from an account.
						</li><li class="listitem">
							Update Email - The email address for an account has changed.
						</li><li class="listitem">
							Update Profile - The profile for an account has changed.
						</li><li class="listitem">
							Send Password Reset - A password reset email has been sent.
						</li><li class="listitem">
							Update Password - The password for an account has changed.
						</li><li class="listitem">
							Update TOTP - The TOTP settings for an account have changed.
						</li><li class="listitem">
							Remove TOTP - TOTP has been removed from an account.
						</li><li class="listitem">
							Send Verify Email - An email verification email has been sent.
						</li><li class="listitem">
							Verify Email - The email address for an account has been verified.
						</li></ul></div><p>
					For all events there is a corresponding error event.
				</p></section><section class="section" id="event_listener"><div class="titlepage"><div><div><h3 class="title">15.1.2. Event Listener</h3></div></div></div><p>
					Event listeners listen for events and perform an action based on that event. There are two built-in listeners that come with Red Hat Single Sign-On: Logging Event Listener and Email Event Listener.
				</p><p>
					The Logging Event Listener writes to a log file whenever an error event occurs and is enabled by default. Here’s an example log message:
				</p><pre class="screen">11:36:09,965 WARN  [org.keycloak.events] (default task-51) type=LOGIN_ERROR, realmId=master,
                    clientId=myapp,
                    userId=19aeb848-96fc-44f6-b0a3-59a17570d374, ipAddress=127.0.0.1,
                    error=invalid_user_credentials, auth_method=openid-connect, auth_type=code,
                    redirect_uri=http://localhost:8180/myapp,
                    code_id=b669da14-cdbb-41d0-b055-0810a0334607, username=admin</pre><p>
					This logging is very useful if you want to use a tool like Fail2Ban to detect if there is a hacker bot somewhere that is trying to guess user passwords. You can parse the log file for <code class="literal">LOGIN_ERROR</code> and pull out the IP Address. Then feed this information into Fail2Ban so that it can help prevent attacks.
				</p><p>
					The Logging Event Listener logs events to the <code class="literal">org.keycloak.events</code> logger category. By default debug log events are not included in server logs.
				</p><p>
					To include debug log events in server logs, edit the <code class="literal">standalone.xml</code> file and change the log level used by the Logging Event listener. Alternately, you can configure the log level for <code class="literal">org.keycloak.events</code>.
				</p><p>
					For example, to change the log level add the following:
				</p><pre class="programlisting language-xml">&lt;subsystem xmlns="urn:jboss:domain:logging:..."&gt;
    ...
    &lt;logger category="org.keycloak.events"&gt;
        &lt;level name="DEBUG"/&gt;
    &lt;/logger&gt;
&lt;/subsystem&gt;</pre><p>
					To change the log level used by the Logging Event listener, add the following:
				</p><pre class="programlisting language-xml">&lt;subsystem xmlns="urn:jboss:domain:keycloak-server:..."&gt;
    ...
    &lt;spi name="eventsListener"&gt;
      &lt;provider name="jboss-logging" enabled="true"&gt;
        &lt;properties&gt;
          &lt;property name="success-level" value="info"/&gt;
          &lt;property name="error-level" value="error"/&gt;
        &lt;/properties&gt;
      &lt;/provider&gt;
    &lt;/spi&gt;
&lt;/subsystem&gt;</pre><p>
					Valid values for the log levels are <code class="literal">debug</code>, <code class="literal">info</code>, <code class="literal">warn</code>, <code class="literal">error</code>, and <code class="literal">fatal</code>.
				</p><p>
					The Email Event Listener sends an email to the user’s account when an event occurs.
				</p><p>
					Currently, the Email Event Listener supports the following events:
				</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">
							Login Error
						</li><li class="listitem">
							Update Password
						</li><li class="listitem">
							Update TOTP
						</li><li class="listitem">
							Remove TOTP
						</li></ul></div><p>
					To enable the Email Listener go to the <code class="literal">Config</code> tab and click on the <code class="literal">Event Listeners</code> field. This will show a drop down list box where you can select email.
				</p><p>
					You can exclude one or more events by editing the <code class="literal">standalone.xml</code>, <code class="literal">standalone-ha.xml</code>, or <code class="literal">domain.xml</code> that comes with your distribution and adding for example:
				</p><pre class="programlisting language-xml">&lt;spi name="eventsListener"&gt;
  &lt;provider name="email" enabled="true"&gt;
    &lt;properties&gt;
      &lt;property name="exclude-events" value="[&amp;quot;UPDATE_TOTP&amp;quot;,&amp;quot;REMOVE_TOTP&amp;quot;]"/&gt;
    &lt;/properties&gt;
  &lt;/provider&gt;
&lt;/spi&gt;</pre><p>
					You can also set up a maximum length of the Event detail stored in the database by editing <code class="literal">standalone.xml</code>, <code class="literal">standalone-ha.xml</code>, or <code class="literal">domain.xml</code>. This setting can be useful in case some field (e.g. redirect_uri) is very long. Here is an example of defining the maximum length.:
				</p><pre class="programlisting language-xml">&lt;spi name="eventsStore"&gt;
    &lt;provider name="jpa" enabled="true"&gt;
        &lt;properties&gt;
            &lt;property name="max-detail-length" value="1000"/&gt;
        &lt;/properties&gt;
    &lt;/provider&gt;
&lt;/spi&gt;</pre><p>
					See the <a class="link" href="https://access.redhat.com/documentation/en-us/red_hat_single_sign-on/7.4/html-single/server_installation_and_configuration_guide/">Server Installation and Configuration Guide</a> for more details on where the <code class="literal">standalone.xml</code>, <code class="literal">standalone-ha.xml</code>, or <code class="literal">domain.xml</code> file lives.
				</p></section></section><section class="section" id="admin_events"><div class="titlepage"><div><div><h2 class="title">15.2. Admin Events</h2></div></div></div><p>
				Any action an admin performs within the admin console can be recorded for auditing purposes. The Admin Console performs administrative functions by invoking on the Red Hat Single Sign-On REST interface. Red Hat Single Sign-On audits these REST invocations. The resulting events can then be viewed in the Admin Console.
			</p><p>
				To enable auditing of Admin actions, go to the <code class="literal">Events</code> left menu item and select the <code class="literal">Config</code> tab.
			</p><div class="formalpara"><p class="title"><strong>Event Configuration</strong></p><p>
					<span class="inlinemediaobject"><img src="images/rhsso-images/login-events-config.png" alt="login events config"/></span>
				</p></div><p>
				In the <code class="literal">Admin Events Settings</code> section, turn on the <code class="literal">Save Events</code> switch.
			</p><div class="formalpara"><p class="title"><strong>Admin Event Configuration</strong></p><p>
					<span class="inlinemediaobject"><img src="images/rhsso-images/admin-events-settings.png" alt="admin events settings"/></span>
				</p></div><p>
				The <code class="literal">Include Representation</code> switch will include any JSON document that is sent through the admin REST API. This allows you to view exactly what an admin has done, but can lead to a lot of information stored in the database. The <code class="literal">Clear admin events</code> button allows you to wipe out the current information stored.
			</p><p>
				To view the admin events go to the <code class="literal">Admin Events</code> tab.
			</p><div class="formalpara"><p class="title"><strong>Admin Events</strong></p><p>
					<span class="inlinemediaobject"><img src="images/rhsso-images/admin-events.png" alt="admin events"/></span>
				</p></div><p>
				If the <code class="literal">Details</code> column has a <code class="literal">Representation</code> box, you can click on that to view the JSON that was sent with that operation.
			</p><div class="formalpara"><p class="title"><strong>Admin Representation</strong></p><p>
					<span class="inlinemediaobject"><img src="images/rhsso-images/admin-events-representation.png" alt="admin events representation"/></span>
				</p></div><p>
				You can also filter for the events you are interested in by clicking the <code class="literal">Filter</code> button.
			</p><div class="formalpara"><p class="title"><strong>Admin Event Filter</strong></p><p>
					<span class="inlinemediaobject"><img src="images/rhsso-images/admin-events-filter.png" alt="admin events filter"/></span>
				</p></div></section></section><section class="chapter" id="export_import"><div class="titlepage"><div><div><h1 class="title">Chapter 16. Export and Import</h1></div></div></div><p>
			Red Hat Single Sign-On has the ability to export and import the entire database. This can be especially useful if you want to migrate your whole Red Hat Single Sign-On database from one environment to another or migrate to a different database (for example from MySQL to Oracle). Export and import is triggered at server boot time and its parameters are passed in via Java system properties. It is important to note that because import and export happens at server startup, no other actions should be taken on the server or the database while this happens.
		</p><p>
			You can export/import your database either to:
		</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">
					Directory on local filesystem
				</li><li class="listitem">
					Single JSON file on your filesystem
				</li></ul></div><p>
			When importing using the directory strategy, note that the files need to follow the naming convention specified below. If you are importing files which were previously exported, the files already follow this convention.
		</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">
					&lt;REALM_NAME&gt;-realm.json, such as "acme-roadrunner-affairs-realm.json" for the realm named "acme-roadrunner-affairs"
				</li><li class="listitem">
					&lt;REALM_NAME&gt;-users-&lt;INDEX&gt;.json, such as "acme-roadrunner-affairs-users-0.json" for the first users file of the realm named "acme-roadrunner-affairs"
				</li></ul></div><p>
			If you export to a directory, you can also specify the number of users that will be stored in each JSON file.
		</p><div class="admonition note"><div class="admonition_header">Note</div><div><p>
				If you have bigger amount of users in your database (500 or more), it’s highly recommended to export into directory rather than to single file. Exporting into single file may lead to the very big file. Also the directory provider is using separate transaction for each "page" (file with users), which leads to much better performance. Default count of users per file (and transaction) is 50, which showed us best performance, but you have possibility to override (See below). Exporting to single file is using one transaction per whole export and one per whole import, which results in bad performance with large amount of users.
			</p></div></div><p>
			To export into unencrypted directory you can use:
		</p><pre class="screen">bin/standalone.sh -Dkeycloak.migration.action=export
-Dkeycloak.migration.provider=dir -Dkeycloak.migration.dir=&lt;DIR TO EXPORT TO&gt;</pre><p>
			To export into single JSON file you can use:
		</p><pre class="screen">bin/standalone.sh -Dkeycloak.migration.action=export
-Dkeycloak.migration.provider=singleFile -Dkeycloak.migration.file=&lt;FILE TO EXPORT TO&gt;</pre><p>
			And similarly for import just use <code class="literal">-Dkeycloak.migration.action=import</code> instead of <code class="literal">export</code> . Here’s an example of importing:
		</p><pre class="screen">bin/standalone.sh -Dkeycloak.migration.action=import
-Dkeycloak.migration.provider=singleFile -Dkeycloak.migration.file=&lt;FILE TO IMPORT&gt;
-Dkeycloak.migration.strategy=OVERWRITE_EXISTING</pre><p>
			Other available options are:
		</p><div class="variablelist"><dl class="variablelist"><dt><span class="term">-Dkeycloak.migration.realmName</span></dt><dd>
						This property is used if you want to export just one specified realm instead of all. If not specified, then all realms will be exported.
					</dd><dt><span class="term">-Dkeycloak.migration.usersExportStrategy</span></dt><dd><p class="simpara">
						This property is used to specify where users are exported. Possible values are:
					</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">
								DIFFERENT_FILES - Users will be exported into different files according to the maximum number of users per file. This is default value.
							</li><li class="listitem">
								SKIP - Exporting of users will be skipped completely.
							</li><li class="listitem">
								REALM_FILE - All users will be exported to same file with the realm settings. (The result will be a file like "foo-realm.json" with both realm data and users.)
							</li><li class="listitem">
								SAME_FILE - All users will be exported to same file but different from the realm file. (The result will be a file like "foo-realm.json" with realm data and "foo-users.json" with users.)
							</li></ul></div></dd><dt><span class="term">-Dkeycloak.migration.usersPerFile</span></dt><dd>
						This property is used to specify the number of users per file (and also per DB transaction). It’s 50 by default. It’s used only if usersExportStrategy is DIFFERENT_FILES
					</dd><dt><span class="term">-Dkeycloak.migration.strategy</span></dt><dd><p class="simpara">
						This property is used during import. It can be used to specify how to proceed if a realm with same name already exists in the database where you are going to import data. Possible values are:
					</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">
								IGNORE_EXISTING - Ignore importing if a realm of this name already exists.
							</li><li class="listitem">
								OVERWRITE_EXISTING - Remove existing realm and import it again with new data from the JSON file. If you want to fully migrate one environment to another and ensure that the new environment will contain the same data as the old one, you can specify this.
							</li></ul></div></dd></dl></div><p>
			When importing realm files that weren’t exported before, the option <code class="literal">keycloak.import</code> can be used. If more than one realm file needs to be imported, a comma separated list of file names can be specified. This is more appropriate than the cases before, as this will happen only after the master realm has been initialized. Examples:
		</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">
					-Dkeycloak.import=/tmp/realm1.json
				</li><li class="listitem">
					-Dkeycloak.import=/tmp/realm1.json,/tmp/realm2.json
				</li></ul></div><section class="section" id="admin_console_export_import"><div class="titlepage"><div><div><h2 class="title">16.1. Admin console export/import</h2></div></div></div><p>
				Import of most resources can be performed from the admin console as well as export of most resources. Export of users is not supported.
			</p><div class="admonition note"><div class="admonition_header">Note</div><div><p>
					Attributes containing secrets or private information will be masked in export file. Export files obtained via Admin Console are thus not appropriate for backups or data transfer between servers. Only boot-time exports are appropriate for that.
				</p></div></div><p>
				The files created during a "startup" export can also be used to import from the admin UI. This way, you can export from one realm and import to another realm. Or, you can export from one server and import to another.
			</p><div class="admonition note"><div class="admonition_header">Note</div><div><p>
					The admin console export/import allows just one realm per file.
				</p></div></div><div class="admonition warning"><div class="admonition_header">Warning</div><div><p>
					The admin console import allows you to "overwrite" resources if you choose. Use this feature with caution, especially on a production system. Export .json files from Admin Console Export operation are generally not appropriate for data import since they contain invalid values for secrets.
				</p></div></div><div class="admonition warning"><div class="admonition_header">Warning</div><div><p>
					The admin console export allows you to export clients, groups, and roles. If there is a great number of any of these assets in your realm, the operation may take some time to complete. During that time server may not be responsive to user requests. Use this feature with caution, especially on a production system.
				</p></div></div></section></section><section class="chapter" id="vault-administration"><div class="titlepage"><div><div><h1 class="title">Chapter 17. Using Vault to Obtain Secrets</h1></div></div></div><p>
			Several fields in the administration support obtaining the value of a secret from an external vault.
		</p><p>
			To obtain a secret from a vault instead of entering it directly, enter the following specially crafted string into the appropriate field: <code class="literal"><span class="strong strong"><strong>${vault.</strong></span><span class="emphasis"><em>key</em></span><span class="strong strong"><strong>}</strong></span></code> where you replace the <code class="literal"><span class="emphasis"><em>key</em></span></code> with the name of the secret as recognized by the vault.
		</p><p>
			In order to prevent secrets from leaking across realms, implementations may combine the realm name with the <code class="literal"><span class="emphasis"><em>key</em></span></code> obtained from the vault expression. This means that the <code class="literal"><span class="emphasis"><em>key</em></span></code> won’t directly map to an entry in the vault, but rather be used to create the final entry name according to the algorithm used to combine it with the realm name.
		</p><p>
			Currently, the secret can be obtained from the vault in the following fields:
		</p><div class="variablelist"><dl class="variablelist"><dt><span class="term">SMTP password</span></dt><dd>
						In realm <a class="link" href="#email" title="3.5. Email Settings">SMTP settings</a>
					</dd><dt><span class="term">LDAP bind credential</span></dt><dd>
						In <a class="link" href="#ldap" title="14.3. LDAP and Active Directory">LDAP settings</a> of LDAP-based user federation.
					</dd><dt><span class="term">OIDC identity provider secret</span></dt><dd>
						In <span class="emphasis"><em>Client Secret</em></span> inside identity provider <a class="link" href="#identity_broker_oidc" title="12.5. OpenID Connect v1.0 Identity Providers">OpenID Connect Config</a>
					</dd></dl></div><p>
			To use a vault, a vault provider must be registered within Red Hat Single Sign-On. It is possible to either use a built-in provider described below or implement your own provider. See the <a class="link" href="https://access.redhat.com/documentation/en-us/red_hat_single_sign-on/7.4/html-single/server_developer_guide/">Server Developer Guide</a> for more information.
		</p><div class="admonition note"><div class="admonition_header">Note</div><div><p>
				There is at most one vault provider active per Red Hat Single Sign-On instance at any given time, and the vault provider in each instance within the cluster has to be configured consistently.
			</p></div></div><section class="section" id="kubernetes_openshift_files_plaintext_vault_provider"><div class="titlepage"><div><div><h2 class="title">17.1. Kubernetes / OpenShift Files Plaintext Vault Provider</h2></div></div></div><p>
				Red Hat Single Sign-On supports vault implementation for <a class="link" href="https://kubernetes.io/docs/concepts/configuration/secret/">Kubernetes secrets</a>. These secrets can be mounted as data volumes, and they appear as a directory with a flat file structure, where each secret is represented by a file whose name is the secret name, and contents of that file is the secret value.
			</p><p>
				The files within this directory have to be named as secret name prefixed by realm name and an underscore. All underscores within the secret name or the realm name have to be doubled in the file name. For example, for a field within a realm called <code class="literal">sso_realm</code>, a reference to a secret with name <code class="literal">secret-name</code> would be written as <code class="literal">${vault.secret-name}</code>, and the file name looked up would be <code class="literal">sso__realm_secret-name</code> (note the underscore doubled in realm name).
			</p><p>
				To use this type of secret store, you have to declare the <code class="literal">files-plaintext</code> vault provider in standalone.xml, and set its parameter for the directory that contains the mounted volume. The following example shows the <code class="literal">files-plaintext</code> provider with the directory where vault files are searched for set to <code class="literal">standalone/configuration/vault</code> relative to Red Hat Single Sign-On base directory:
			</p><pre class="programlisting language-xml">&lt;spi name="vault"&gt;
    &lt;default-provider&gt;files-plaintext&lt;/default-provider&gt;
    &lt;provider name="files-plaintext" enabled="true"&gt;
        &lt;properties&gt;
            &lt;property name="dir" value="${jboss.home.dir}/standalone/configuration/vault/" /&gt;
        &lt;/properties&gt;
    &lt;/provider&gt;
&lt;/spi&gt;</pre><p>
				Here is the equivalent configuration using CLI commands:
			</p><pre class="programlisting language-bash">/subsystem=keycloak-server/spi=vault/:add
/subsystem=keycloak-server/spi=vault/provider=files-plaintext/:add(enabled=true,properties={dir =&gt; "${jboss.home.dir}/standalone/configuration/vault"})</pre></section><section class="section" id="elytron_credential_store_vault_provider"><div class="titlepage"><div><div><h2 class="title">17.2. Elytron Credential Store Vault Provider</h2></div></div></div><p>
				Red Hat Single Sign-On also provides support for reading secrets stored in an Elytron credential store. The <code class="literal">elytron-cs-keystore</code> vault provider is capable of retrieving secrets from the keystore-based implementation of the credential store, which is also the default implementation provided by Elytron.
			</p><p>
				This credential store is backed by a keystore (<code class="literal">JCEKS</code> is the default format, but it is possible to use other formats such as <code class="literal">PKCS12</code>) and users can create and manage the store contents using either the <code class="literal">elytron</code> subsystem in WildFly/JBoss EAP, or using the <code class="literal">elytron-tool.sh</code> script.
			</p><p>
				To use this provider, you have to declare the <code class="literal">elytron-cs-keystore</code> in the <code class="literal">keycloak-server</code> subsystem and set the location and master secret of the keystore that was created by Elytron. An example of the minimal configuration for the provider follows:
			</p><pre class="programlisting language-xml">&lt;spi name="vault"&gt;
    &lt;default-provider&gt;elytron-cs-keystore&lt;/default-provider&gt;
    &lt;provider name="elytron-cs-keystore" enabled="true"&gt;
        &lt;properties&gt;
            &lt;property name="location" value="${jboss.home.dir}/standalone/configuration/vault/credential-store.jceks" /&gt;
            &lt;property name="secret" value="secretpw1!"/&gt;
        &lt;/properties&gt;
    &lt;/provider&gt;
&lt;/spi&gt;</pre><p>
				If the underlying keystore has a format other than <code class="literal">JCEKS</code>, this format has to be informed using the <code class="literal">keyStoreType</code>:
			</p><pre class="programlisting language-xml">&lt;spi name="vault"&gt;
    &lt;default-provider&gt;elytron-cs-keystore&lt;/default-provider&gt;
    &lt;provider name="elytron-cs-keystore" enabled="true"&gt;
        &lt;properties&gt;
            &lt;property name="location" value="${jboss.home.dir}/standalone/configuration/vault/credential-store.p12" /&gt;
            &lt;property name="secret" value="secretpw1!"/&gt;
            &lt;property name="keyStoreType" value="PKCS12"/&gt;
        &lt;/properties&gt;
    &lt;/provider&gt;
&lt;/spi&gt;</pre><p>
				For the secret, the <code class="literal">elytron-cs-keystore</code> provider supports both clear-text values (as shown above) and also values that were masked using the <code class="literal">elytron-tool.sh</code> script:
			</p><pre class="programlisting language-xml">&lt;spi name="vault"&gt;
   ...
            &lt;property name="secret" value="MASK-3u2HNQaMogJJ8VP7J6gRIl;12345678;321"/&gt;
   ...
&lt;/spi&gt;</pre><p>
				For more detailed information on how to create/manage elytron credential stores, as well as how to mask keystore secrets, please refer to the Elytron documentation.
			</p><div class="admonition note"><div class="admonition_header">Note</div><div><p>
					The <code class="literal">elytron-cs-keystore</code> vault provider has been implemented as a WildFly extension and as such is only available if the Red Hat Single Sign-On server runs on WildFly/JBoss EAP.
				</p></div></div></section><section class="section" id="key_resolvers"><div class="titlepage"><div><div><h2 class="title">17.3. Key Resolvers</h2></div></div></div><p>
				All built-in providers support the configuration of one or more key resolvers. A key resolver essentially implements the algorithm or strategy for combining the realm name with the key (as obtained from the <code class="literal">${vault.key}</code> expression) into the final entry name that will be used to retrieve the secret from the vault. The <code class="literal">keyResolvers</code> property is used to configure the resolvers that are to be used by the provider. The value is a comma-separated list of resolver names. An example of configuration for the <code class="literal">files-plaintext</code> provider follows:
			</p><pre class="programlisting language-xml">&lt;spi name="vault"&gt;
    &lt;default-provider&gt;files-plaintext&lt;/default-provider&gt;
    &lt;provider name="files-plaintext" enabled="true"&gt;
        &lt;properties&gt;
            &lt;property name="dir" value="${jboss.home.dir}/standalone/configuration/vault/" /&gt;
            &lt;property name="keyResolvers" value="REALM_UNDERSCORE_KEY, KEY_ONLY"/&gt;
        &lt;/properties&gt;
    &lt;/provider&gt;
&lt;/spi&gt;</pre><p>
				The resolvers are executed in the same order that they are declared in the configuration. For each resolver, the final entry name produced by the resolver that combines the realm with the vault key is used to search for the secret in the vault. If a secret is found, it is immediately returned. If not, the next resolver is used and this continues until a non-empty secret is found or all resolvers have been tried, in which case an empty secret is returned. In the example above, first the <code class="literal">REALM_UNDERSCORE_KEY</code> resolver is used. If an entry is found in the vault with the name it produces, it is returned. If not, then the <code class="literal">KEY_ONLY</code> resolver is used. Again, if an entry is found in the vault with the name it produces, it is returned. If not, an empty secret is returned since there are no more resolvers to be used.
			</p><p>
				A list of the currently available resolvers follows:
			</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">
						<code class="literal">KEY_ONLY</code>: the realm name is ignored and the key from the vault expression is used as is.
					</li><li class="listitem">
						<code class="literal">REALM_UNDERSCORE_KEY</code>: the realm and key are combined using an underscore <code class="literal">_</code> character. Occurrences of underscore in either the realm or key are escaped by another underscore character. So if the realm is called <code class="literal">master_realm</code> and the key is <code class="literal">smtp_key</code>, the combined key will be <code class="literal">master__realm_smtp__key</code>.
					</li><li class="listitem">
						<code class="literal">REALM_FILESEPARATOR_KEY</code>: the realm and key are combined using the platform file separator character. This is useful in situations where the keys are grouped by realm using a directory structure.
					</li></ul></div><p>
				If no resolver is configured for the built-in providers, the <code class="literal">REALM_UNDERSCORE_KEY</code> is selected by default.
			</p></section></section><section class="chapter" id="account-service"><div class="titlepage"><div><div><h1 class="title">Chapter 18. User Account Service</h1></div></div></div><p>
			Red Hat Single Sign-On has a built-in User Account Service which every user has access to. This service allows users to manage their account, change their credentials, update their profile, and view their login sessions. The URL to this service is <code class="literal">&lt;server-root&gt;/auth/realms/{realm-name}/account</code>.
		</p><div class="formalpara"><p class="title"><strong>Account Service</strong></p><p>
				<span class="inlinemediaobject"><img src="images/rhsso-images/account-service-profile.png" alt="account service profile"/></span>
			</p></div><p>
			The initial page is the user’s profile, which is the <code class="literal">Account</code> left menu item. This is where they specify basic data about themselves. This screen can be extended to allow the user to manage additional attributes. See the <a class="link" href="https://access.redhat.com/documentation/en-us/red_hat_single_sign-on/7.4/html-single/server_developer_guide/">Server Developer Guide</a> for more details.
		</p><p>
			The <code class="literal">Password</code> left menu item allows the user to change their password.
		</p><div class="formalpara"><p class="title"><strong>Password Update</strong></p><p>
				<span class="inlinemediaobject"><img src="images/rhsso-images/account-service-password.png" alt="account service password"/></span>
			</p></div><p>
			The <code class="literal">Authenticator</code> menu item allows the user to set up OTP if they desire. This will only show up if OTP is a valid authentication mechanism for your realm. Users are given directions to install <a class="link" href="https://freeotp.github.io/">FreeOTP</a> or <a class="link" href="https://play.google.com/store/apps/details?id=com.google.android.apps.authenticator2">Google Authenticator</a> on their mobile device to be their OTP generator. The QR code you see in the screen shot can be scanned into the FreeOTP or Google Authenticator mobile application for nice and easy setup.
		</p><div class="formalpara"><p class="title"><strong>OTP Authenticator</strong></p><p>
				<span class="inlinemediaobject"><img src="images/rhsso-images/account-service-authenticator.png" alt="account service authenticator"/></span>
			</p></div><p>
			The <code class="literal">Federated Identity</code> menu item allows the user to link their account with an <a class="link" href="#identity_broker" title="Chapter 12. Identity Brokering">identity broker</a> (this is usually used to link social provider accounts together). This will show the list of external identity providers you have configured for your realm.
		</p><div class="formalpara"><p class="title"><strong>Federated Identity</strong></p><p>
				<span class="inlinemediaobject"><img src="images/rhsso-images/account-service-federated-identity.png" alt="account service federated identity"/></span>
			</p></div><p>
			The <code class="literal">Sessions</code> menu item allows the user to view and manage which devices are logged in and from where. They can perform logout of these sessions from this screen too.
		</p><div class="formalpara"><p class="title"><strong>Sessions</strong></p><p>
				<span class="inlinemediaobject"><img src="images/rhsso-images/account-service-sessions.png" alt="account service sessions"/></span>
			</p></div><p>
			The <code class="literal">Applications</code> menu item shows users which applications they have access to.
		</p><div class="formalpara"><p class="title"><strong>Applications</strong></p><p>
				<span class="inlinemediaobject"><img src="images/rhsso-images/account-service-apps.png" alt="account service apps"/></span>
			</p></div><section class="section" id="themeable"><div class="titlepage"><div><div><h2 class="title">18.1. Themeable</h2></div></div></div><p>
				Like all UIs in Red Hat Single Sign-On, the User Account Service is completely themeable and internationalizable. See the <a class="link" href="https://access.redhat.com/documentation/en-us/red_hat_single_sign-on/7.4/html-single/server_developer_guide/">Server Developer Guide</a> for more details.
			</p></section></section><section class="chapter" id="threat_model_mitigation"><div class="titlepage"><div><div><h1 class="title">Chapter 19. Threat Model Mitigation</h1></div></div></div><p>
			This chapter discusses possible security vulnerabilities any authentication server could have and how Red Hat Single Sign-On mitigates those vulnerabilities. A good list of potential vulnerabilities and what security implementations should do to mitigate them can be found in the <a class="link" href="https://tools.ietf.org/html/rfc6819">OAuth 2.0 Threat Model</a> document put out by the IETF. Many of those vulnerabilities are discussed here.
		</p><section class="section" id="host"><div class="titlepage"><div><div><h2 class="title">19.1. Host</h2></div></div></div><p>
				Red Hat Single Sign-On uses the public hostname for a number of things. For example, in the token issuer fields and URLs sent in password reset emails.
			</p><p>
				By default, the hostname is based on the request headers and there is no check to make sure this hostname is valid.
			</p><p>
				If you are not using a load balancer or proxy in front of Red Hat Single Sign-On that prevents invalid host headers, you must explicitly configure what hostnames should be accepted.
			</p><p>
				The Hostname SPI provides a way to configure the hostname for a request. The out of the box provider allows setting a fixed URL for frontend requests, while allowing backend requests to be based on the request URI. It is also possible to develop your own provider in the case the built-in provider does not provide the functionality needed.
			</p></section><section class="section" id="admin_endpoints_and_console"><div class="titlepage"><div><div><h2 class="title">19.2. Admin Endpoints and Console</h2></div></div></div><p>
				The Red Hat Single Sign-On administrative REST API and the web console are exposed by default on the same port as non-admin usage. If access to the admin console is not needed externally, we recommend not exposing the admin endpoints on the Internet.
			</p><p>
				This can be achieved either directly in Red Hat Single Sign-On or with a proxy such as Apache or nginx.
			</p><p>
				For the proxy option please follow the documentation for the proxy. You need to control access to any requests to <code class="literal">/auth/admin</code>.
			</p><p>
				To achieve this directly in Red Hat Single Sign-On there are a few options. This document covers two options, IP restriction and separate ports.
			</p><p>
				Once the admin console is no longer accessible on the frontend URL of Keycloak, you need to configure a fixed admin URL in the default hostname provider.
			</p><section class="section" id="ip_restriction"><div class="titlepage"><div><div><h3 class="title">19.2.1. IP Restriction</h3></div></div></div><p>
					It is possible to restrict access to <code class="literal">/auth/admin</code> to only specific IP addresses.
				</p><p>
					The following example restricts access to <code class="literal">/auth/admin</code> to IP addresses in the range <code class="literal">10.0.0.1</code> to <code class="literal">10.0.0.255</code>.
				</p><pre class="programlisting language-xml">&lt;subsystem xmlns="urn:jboss:domain:undertow:10.0"&gt;
    ...
    &lt;server name="default-server"&gt;
        ...
        &lt;host name="default-host" alias="localhost"&gt;
            ...
            &lt;filter-ref name="ipAccess"/&gt;
        &lt;/host&gt;
    &lt;/server&gt;
    &lt;filters&gt;
        &lt;expression-filter name="ipAccess" expression="path-prefix('/auth/admin') -&gt; ip-access-control(acl={'10.0.0.0/24 allow'})"/&gt;
    &lt;/filters&gt;
    ...
&lt;/subsystem&gt;</pre><p>
					Equivalent configuration using CLI commands:
				</p><pre class="programlisting language-bash">/subsystem=undertow/configuration=filter/expression-filter=ipAccess:add(,expression="path-prefix[/auth/admin] -&gt; ip-access-control(acl={'10.0.0.0/24 allow'})")
/subsystem=undertow/server=default-server/host=default-host/filter-ref=ipAccess:add()</pre><div class="admonition note"><div class="admonition_header">Note</div><div><p>
						For IP restriction if you are using a proxy it is important to configure it correctly to make sure Red Hat Single Sign-On receives the client IP address and not the proxy IP address
					</p></div></div></section><section class="section" id="port_restriction"><div class="titlepage"><div><div><h3 class="title">19.2.2. Port Restriction</h3></div></div></div><p>
					It is possible to expose <code class="literal">/auth/admin</code> to a different port that is not exposed on the Internet.
				</p><p>
					The following example exposes <code class="literal">/auth/admin</code> on port <code class="literal">8444</code> while not permitting access with the default port <code class="literal">8443</code>.
				</p><pre class="programlisting language-xml">&lt;subsystem xmlns="urn:jboss:domain:undertow:10.0"&gt;
    ...
    &lt;server name="default-server"&gt;
        ...
        &lt;https-listener name="https" socket-binding="https" security-realm="ApplicationRealm" enable-http2="true"/&gt;
        &lt;https-listener name="https-admin" socket-binding="https-admin" security-realm="ApplicationRealm" enable-http2="true"/&gt;
        &lt;host name="default-host" alias="localhost"&gt;
            ...
            &lt;filter-ref name="portAccess"/&gt;
        &lt;/host&gt;
    &lt;/server&gt;
    &lt;filters&gt;
        &lt;expression-filter name="portAccess" expression="path-prefix('/auth/admin') and not equals(%p, 8444) -&gt; response-code(403)"/&gt;
    &lt;/filters&gt;
    ...
&lt;/subsystem&gt;

...

&lt;socket-binding-group name="standard-sockets" default-interface="public" port-offset="${jboss.socket.binding.port-offset:0}"&gt;
    ...
    &lt;socket-binding name="https" port="${jboss.https.port:8443}"/&gt;
    &lt;socket-binding name="https-admin" port="${jboss.https.port:8444}"/&gt;
    ...
&lt;/socket-binding-group&gt;</pre><p>
					Equivalent configuration using CLI commands:
				</p><pre class="programlisting language-bash">/socket-binding-group=standard-sockets/socket-binding=https-admin/:add(port=8444)

/subsystem=undertow/server=default-server/https-listener=https-admin:add(socket-binding=https-admin, security-realm=ApplicationRealm, enable-http2=true)

/subsystem=undertow/configuration=filter/expression-filter=portAccess:add(,expression="path-prefix('/auth/admin') and not equals(%p, 8444) -&gt; response-code(403)")
/subsystem=undertow/server=default-server/host=default-host/filter-ref=portAccess:add()</pre></section></section><section class="section" id="password_guess_brute_force_attacks"><div class="titlepage"><div><div><h2 class="title">19.3. Password guess: brute force attacks</h2></div></div></div><p>
				A brute force attack happens when an attacker is trying to guess a user’s password. Red Hat Single Sign-On has some limited brute force detection capabilities. If turned on, a user account will be temporarily disabled if a threshold of login failures is reached. To enable this feature go to the <code class="literal">Realm Settings</code> left menu item, click on the <code class="literal">Security Defenses</code> tab, then additional go to the <code class="literal">Brute Force Detection</code> sub-tab.
			</p><div class="admonition note"><div class="admonition_header">Note</div><div><p>
					Brute Force Detection is disabled by default. Enabling this feature is highly recommended to protect against this type of attack.
				</p></div></div><div class="formalpara"><p class="title"><strong>Brute Force Detection</strong></p><p>
					<span class="inlinemediaobject"><img src="images/rhsso-images/brute-force.png" alt="brute force"/></span>
				</p></div><p>
				There are 2 different configurations for brute force detection; permanent lockout and temporary lockout. Permanent lockout will disable a user’s account after an attack is detected; the account will be disabled until an administrator renables it. Temporary lockout will disable a user’s account for a time period after an attack is detected; the time period for which the account is disabled increases the longer the attack continues.
			</p><p>
				<span class="strong strong"><strong>Common Parameters</strong></span>
			</p><div class="informalexample"><div class="variablelist"><dl class="variablelist"><dt><span class="term">Max Login Failures</span></dt><dd>
							Maximum number of login failures permitted. Default value is 30.
						</dd><dt><span class="term">Quick Login Check Milli Seconds</span></dt><dd>
							Minimum time required between login attempts. Default is 1000.
						</dd><dt><span class="term">Minimum Quick Login Wait</span></dt><dd>
							Minimum amount of time the user will be temporarily disabled if logins attempts are quicker than <span class="emphasis"><em>Quick Login Check Milli Seconds</em></span>. Default is 1 minute.
						</dd></dl></div></div><p>
				<span class="strong strong"><strong>Temporary Lockout Parameters</strong></span>
			</p><div class="informalexample"><div class="variablelist"><dl class="variablelist"><dt><span class="term">Wait Increment</span></dt><dd>
							Amount of time added to the time a user is temporarily disabled after each time <span class="emphasis"><em>Max Login Failures</em></span> is reached. Default is 1 minute.
						</dd><dt><span class="term">Max Wait</span></dt><dd>
							The maximum amount of time for which a user will be temporarily disabled. Default is 15 minutes.
						</dd><dt><span class="term">Failure Reset Time</span></dt><dd>
							Time after which the failure count will be reset; timer runs from the last failed login. Default is 12 hours.
						</dd></dl></div></div><p>
				<span class="strong strong"><strong>Permanent Lockout Algorithm</strong></span>
			</p><div class="informalexample"><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p class="simpara">
						On successful login
					</p><div class="orderedlist"><ol class="orderedlist" type="a"><li class="listitem">
								Reset <code class="literal">count</code>
							</li></ol></div></li><li class="listitem"><p class="simpara">
						On failed login
					</p><div class="orderedlist"><ol class="orderedlist" type="a"><li class="listitem">
								Increment <code class="literal">count</code>
							</li><li class="listitem"><p class="simpara">
								If <code class="literal">count</code> greater than <span class="emphasis"><em>Max Login Failures</em></span>
							</p><div class="orderedlist"><ol class="orderedlist" type="i"><li class="listitem">
										Permanently disable user
									</li></ol></div></li><li class="listitem"><p class="simpara">
								Else if time between this failure and the last failure is less than <span class="emphasis"><em>Quick Login Check Milli Seconds</em></span>
							</p><div class="orderedlist"><ol class="orderedlist" type="i"><li class="listitem">
										Temporarily disable user for <span class="emphasis"><em>Minimum Quick Login Wait</em></span>
									</li></ol></div></li></ol></div></li></ol></div><p>
				When a user is disabled they can not login until an administrator enables the user; enabling an account resets <code class="literal">count</code>.
			</p></div><p>
				<span class="strong strong"><strong>Temporary Lockout Algorithm</strong></span>
			</p><div class="informalexample"><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p class="simpara">
						On successful login
					</p><div class="orderedlist"><ol class="orderedlist" type="a"><li class="listitem">
								Reset <code class="literal">count</code>
							</li></ol></div></li><li class="listitem"><p class="simpara">
						On failed login
					</p><div class="orderedlist"><ol class="orderedlist" type="a"><li class="listitem"><p class="simpara">
								If time between this failure and the last failure is greater than <span class="emphasis"><em>Failure Reset Time</em></span>
							</p><div class="orderedlist"><ol class="orderedlist" type="i"><li class="listitem">
										Reset <code class="literal">count</code>
									</li></ol></div></li><li class="listitem">
								Increment <code class="literal">count</code>
							</li><li class="listitem">
								Calculate <code class="literal">wait</code> using <span class="emphasis"><em>Wait Increment</em></span> * (<code class="literal">count</code> / <span class="emphasis"><em>Max Login Failures</em></span>). The division is an integer division so will always be rounded down to a whole number
							</li><li class="listitem"><p class="simpara">
								If <code class="literal">wait</code> equals 0 and time between this failure and the last failure is less than <span class="emphasis"><em>Quick Login Check Milli Seconds</em></span> then set <code class="literal">wait</code> to <span class="emphasis"><em>Minimum Quick Login Wait</em></span> instead
							</p><div class="orderedlist"><ol class="orderedlist" type="i"><li class="listitem">
										Temporarily disable the user for the smaller of <code class="literal">wait</code> and <span class="emphasis"><em>Max Wait</em></span> seconds
									</li></ol></div></li></ol></div></li></ol></div><p>
				Login failures when a user is temporarily disabled do not increment <code class="literal">count</code>.
			</p></div><p>
				The downside of Red Hat Single Sign-On brute force detection is that the server becomes vulnerable to denial of service attacks. An attacker can simply try to guess passwords for any accounts it knows and these account will be disabled. Eventually we will expand this functionality to take client IP address into account when deciding whether to block a user.
			</p><p>
				A better option might be a tool like <a class="link" href="http://www.fail2ban.org/wiki/index.php/Main_Page">Fail2Ban</a>. You can point this service at the Red Hat Single Sign-On server’s log file. Red Hat Single Sign-On logs every login failure and client IP address that had the failure. Fail2Ban can be used to modify firewalls after it detects an attack to block connections from specific IP addresses.
			</p><section class="section" id="password_policies"><div class="titlepage"><div><div><h3 class="title">19.3.1. Password Policies</h3></div></div></div><p>
					Another thing you should do to prevent password guess is to have a complex enough password policy to ensure that users pick hard to guess passwords. See the <a class="link" href="#password-policies" title="6.1. Password Policies">Password Policies</a> chapter for more details.
				</p><p>
					The best way to prevent password guessing though is to set up the server to use a one-time-password (OTP).
				</p></section></section><section class="section" id="clickjacking"><div class="titlepage"><div><div><h2 class="title">19.4. Clickjacking</h2></div></div></div><p>
				With clickjacking, a malicious site loads the target site in a transparent iFrame overlaid on top of a set of dummy buttons that are carefully constructed to be placed directly under important buttons on the target site. When a user clicks a visible button, they are actually clicking a button (such as a "login" button) on the hidden page. An attacker can steal a user’s authentication credentials and access their resources.
			</p><p>
				By default, every response by Red Hat Single Sign-On sets some specific browser headers that can prevent this from happening. Specifically, it sets <a class="link" href="https://tools.ietf.org/html/rfc7034">X-FRAME_OPTIONS</a> and <a class="link" href="http://www.w3.org/TR/CSP/">Content-Security-Policy</a>. You should take a look at the definition of both of these headers as there is a lot of fine-grain browser access you can control. In the admin console you can specify the values these headers will have. Go to the <code class="literal">Realm Settings</code> left menu item and click the <code class="literal">Security Defenses</code> tab and make sure you are on the <code class="literal">Headers</code> sub-tab.
			</p><p>
				<span class="inlinemediaobject"><img src="images/rhsso-images/security-headers.png" alt="security headers"/></span>
			</p><p>
				By default, Red Hat Single Sign-On only sets up a <span class="emphasis"><em>same-origin</em></span> policy for iframes.
			</p></section><section class="section" id="ssl_https_requirement"><div class="titlepage"><div><div><h2 class="title">19.5. SSL/HTTPS Requirement</h2></div></div></div><p>
				If you do not use SSL/HTTPS for all communication between the Red Hat Single Sign-On auth server and the clients it secures, you will be very vulnerable to man in the middle attacks. OAuth 2.0/OpenID Connect uses access tokens for security. Without SSL/HTTPS, attackers can sniff your network and obtain an access token. Once they have an access token they can do any operation that the token has been given permission for.
			</p><p>
				Red Hat Single Sign-On has <a class="link" href="#ssl_modes" title="3.3. SSL Mode">three modes for SSL/HTTPS</a>. SSL can be hard to set up, so out of the box, Red Hat Single Sign-On allows non-HTTPS communication over private IP addresses like localhost, 192.168.x.x, and other private IP addresses. In production, you should make sure SSL is enabled and required across the board.
			</p><p>
				On the adapter/client side, Red Hat Single Sign-On allows you to turn off the SSL trust manager. The trust manager ensures identity the client is talking to. It checks the DNS domain name against the server’s certificate. In production you should make sure that each of your client adapters is configured to use a truststore. Otherwise you are vulnerable to DNS man in the middle attacks.
			</p></section><section class="section" id="csrf_attacks"><div class="titlepage"><div><div><h2 class="title">19.6. CSRF Attacks</h2></div></div></div><p>
				Cross-site request forgery (CSRF) is a web-based attack whereby HTTP requests are transmitted from a user that the web site trusts or has authenticated with(e.g. via HTTP redirects or HTML forms). Any site that uses cookie based authentication is vulnerable to these types of attacks. These attacks are mitigated by matching a state cookie against a posted form or query parameter.
			</p><p>
				The OAuth 2.0 login specification requires that a state cookie be used and matched against a transmitted state parameter. Red Hat Single Sign-On fully implements this part of the specification so all logins are protected.
			</p><p>
				The Red Hat Single Sign-On Admin Console is a pure JavaScript/HTML5 application that makes REST calls to the backend Red Hat Single Sign-On admin REST API. These calls all require bearer token authentication and are made via JavaScript Ajax calls. CSRF does not apply here. The admin REST API can also be configured to validate the CORS origins as well.
			</p><p>
				The only part of Red Hat Single Sign-On that really falls into CSRF is the user account management pages. To mitigate this Red Hat Single Sign-On sets a state cookie and also embeds the value of this state cookie within hidden form fields or query parameters in action links. This query or form parameter is checked against the state cookie to verify that the call was made by the user.
			</p></section><section class="section" id="unspecific-redirect-uris"><div class="titlepage"><div><div><h2 class="title">19.7. Unspecific Redirect URIs</h2></div></div></div><p>
				For the <a class="link" href="#oidc-auth-flows" title="7.1.1. OIDC Auth Flows">Authorization Code Flow</a>, if you register redirect URIs that are too general, then it would be possible for a rogue client to impersonate a different client that has a broader scope of access. This could happen for instance if two clients live under the same domain. So, it’s a good idea to make your registered redirect URIs as specific as feasible.
			</p></section><section class="section" id="compromised_access_and_refresh_tokens"><div class="titlepage"><div><div><h2 class="title">19.8. Compromised Access and Refresh Tokens</h2></div></div></div><p>
				There are a few things you can do to mitigate access tokens and refresh tokens from being stolen. The most important thing is to enforce SSL/HTTPS communication between Red Hat Single Sign-On and its clients and applications. It might seem obvious, but since Red Hat Single Sign-On does not have SSL enabled by default, an administrator might not realize that it is necessary.
			</p><p>
				Another thing you can do to mitigate leaked access tokens is to shorten their lifespans. You can specify this within the <a class="link" href="#timeouts" title="13.3. Session and Token Timeouts">timeouts page</a>. Short lifespans (minutes) for access tokens for clients and applications to refresh their access tokens after a short amount of time. If an admin detects a leak, they can logout all user sessions to invalidate these refresh tokens or set up a revocation policy. Making sure refresh tokens always stay private to the client and are never transmitted ever is very important as well.
			</p><p>
				You can also mitigate against leaked access tokens and refresh tokens by issuing these tokens as holder-of-key tokens. See <a class="link" href="#mtls-client-certificate-bound-tokens">OAuth 2.0 Mutual TLS Client Certificate Bound Access Token</a> to learn how.
			</p><p>
				If an access token or refresh token is compromised, the first thing you should do is go to the admin console and push a not-before revocation policy to all applications. This will enforce that any tokens issued prior to that date are now invalid. Pushing new not-before policy will also ensure that application will be forced to download new public keys from Red Hat Single Sign-On, hence it is also useful for the case, when you think that realm signing key was compromised. More info in the <a class="link" href="#realm_keys" title="11.4. Realm Keys">keys chapter</a>.
			</p><p>
				You can also disable specific applications, clients, and users if you feel that any one of those entities is completely compromised.
			</p></section><section class="section" id="compromised_authorization_code"><div class="titlepage"><div><div><h2 class="title">19.9. Compromised Authorization Code</h2></div></div></div><p>
				For the <a class="link" href="#oidc-auth-flows" title="7.1.1. OIDC Auth Flows">OIDC Auth Code Flow</a>, it would be very hard for an attacker to compromise Red Hat Single Sign-On authorization codes. Red Hat Single Sign-On generates a cryptographically strong random value for its authorization codes so it would be very hard to guess an access token. An authorization code can only be used once to obtain an access token. In the admin console you can specify how long an authorization code is valid for on the <a class="link" href="#timeouts" title="13.3. Session and Token Timeouts">timeouts page</a>. This value should be really short, as short as a few seconds and just long enough for the client to make the request to obtain a token from the code.
			</p><p>
				You can also mitigate against leaked autorization codes by applying PKCE to clients. See <a class="link" href="#proof-key-for-code-exchange">Proof Key for Code Exchange (PKCE)</a> to learn how.
			</p></section><section class="section" id="open_redirectors"><div class="titlepage"><div><div><h2 class="title">19.10. Open redirectors</h2></div></div></div><p>
				An attacker could use the end-user authorization endpoint and the redirect URI parameter to abuse the authorization server as an open redirector. An open redirector is an endpoint using a parameter to automatically redirect a user agent to the location specified by the parameter value without any validation. An attacker could utilize a user’s trust in an authorization server to launch a phishing attack.
			</p><p>
				Red Hat Single Sign-On requires that all registered applications and clients register at least one redirection URI pattern. Any time a client asks Red Hat Single Sign-On to perform a redirect (on login or logout for example), Red Hat Single Sign-On will check the redirect URI vs. the list of valid registered URI patterns. It is important that clients and applications register as specific a URI pattern as possible to mitigate open redirector attacks.
			</p></section><section class="section" id="password_database_compromised"><div class="titlepage"><div><div><h2 class="title">19.11. Password database compromised</h2></div></div></div><p>
				Red Hat Single Sign-On does not store passwords in raw text. It stores a hash of them using the PBKDF2 algorithm. It actually uses a default of 20,000 hashing iterations! This is the security community’s recommended number of iterations. This can be a rather large performance hit on your system as PBKDF2, by design, gobbles up a significant amount of CPU. It is up to you to decide how serious you want to be to protect your password database.
			</p></section><section class="section" id="limiting_scope"><div class="titlepage"><div><div><h2 class="title">19.12. Limiting Scope</h2></div></div></div><p>
				By default, each new client application has an unlimited <code class="literal">role scope mappings</code>. This means that every access token that is created for that client will contain all the permissions the user has. If the client gets compromised and the access token is leaked, then each system that the user has permission to access is now also compromised. It is highly suggested that you limit the roles an access token is assigned by using the <a class="link" href="#role_scope_mappings" title="9.5. Role Scope Mappings">Scope menu</a> for each client. Or alternatively, you can set role scope mappings at the Client Scope level and assign Client Scopes to your client by using the <a class="link" href="#client_scopes_linking" title="8.6.3. Link Client Scope with the Client">Client Scope menu</a>.
			</p></section><section class="section" id="limit_token_audience"><div class="titlepage"><div><div><h2 class="title">19.13. Limit Token Audience</h2></div></div></div><p>
				In environments where the level of trust among services is low, it is a good practice to limit the audiences on the token. The motivation behind this is described in the <a class="link" href="https://tools.ietf.org/html/rfc6819#section-5.1.5.5">OAuth2 Threat Model</a> document and more details are in the <a class="link" href="#audience" title="8.1.4. Audience Support">Audience Support section</a>.
			</p></section><section class="section" id="sql_injection_attacks"><div class="titlepage"><div><div><h2 class="title">19.14. SQL Injection Attacks</h2></div></div></div><p>
				At this point in time, there is no knowledge of any SQL injection vulnerabilities in Red Hat Single Sign-On.
			</p></section></section><section class="chapter" id="the_admin_cli"><div class="titlepage"><div><div><h1 class="title">Chapter 20. The Admin CLI</h1></div></div></div><p>
			In previous chapters, we described how to use the Red Hat Single Sign-On Admin Console to perform administrative tasks. You can also perform those tasks from the command-line interface (CLI) by using the Admin CLI command-line tool.
		</p><section class="section" id="installing_the_admin_cli"><div class="titlepage"><div><div><h2 class="title">20.1. Installing the Admin CLI</h2></div></div></div><p>
				The Admin CLI is packaged inside Red Hat Single Sign-On Server distribution. You can find execution scripts inside the <code class="literal filename">bin</code> directory.
			</p><p>
				The Linux script is called <code class="literal filename">kcadm.sh</code>, and the script for Windows is called <code class="literal filename">kcadm.bat</code>.
			</p><p>
				You can add the Red Hat Single Sign-On server directory to your <code class="literal filename">PATH</code> to use the client from any location on your file system.
			</p><p>
				For example, on:
			</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">
						Linux:
					</li></ul></div><pre class="screen">$ export PATH=$PATH:$KEYCLOAK_HOME/bin
$ kcadm.sh</pre><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">
						Windows:
					</li></ul></div><pre class="screen">c:\&gt; set PATH=%PATH%;%KEYCLOAK_HOME%\bin
c:\&gt; kcadm</pre><p>
				We assume the <code class="literal">KEYCLOAK_HOME</code> environment (env) variable is set to the path where you extracted the Red Hat Single Sign-On Server distribution.
			</p><div class="admonition note"><div class="admonition_header">Note</div><div><p>
					To avoid repetition, the rest of this document only gives Windows examples in places where the difference in the CLI is more than just in the <code class="literal command">kcadm</code> command name.
				</p></div></div></section><section class="section" id="using_the_admin_cli"><div class="titlepage"><div><div><h2 class="title">20.2. Using the Admin CLI</h2></div></div></div><p>
				The Admin CLI works by making HTTP requests to Admin REST endpoints. Access to them is protected and requires authentication.
			</p><div class="admonition note"><div class="admonition_header">Note</div><div><p>
					Consult the Admin REST API documentation for details about JSON attributes for specific endpoints.
				</p></div></div><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p class="simpara">
						Start an authenticated session by providing credentials, that is, logging in. You are ready to perform create, read, update, and delete (CRUD) operations.
					</p><p class="simpara">
						For example, on
					</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p class="simpara">
								Linux:
							</p><pre class="screen">$ kcadm.sh config credentials --server http://localhost:8080/auth --realm demo --user admin --client admin
$ kcadm.sh create realms -s realm=demorealm -s enabled=true -o
$ CID=$(kcadm.sh create clients -r demorealm -s clientId=my_client -s 'redirectUris=["http://localhost:8980/myapp/*"]' -i)
$ kcadm.sh get clients/$CID/installation/providers/keycloak-oidc-keycloak-json</pre></li><li class="listitem"><p class="simpara">
								Windows:
							</p><pre class="screen">c:\&gt; kcadm config credentials --server http://localhost:8080/auth --realm demo --user admin --client admin
c:\&gt; kcadm create realms -s realm=demorealm -s enabled=true -o
c:\&gt; kcadm create clients -r demorealm -s clientId=my_client -s "redirectUris=[\"http://localhost:8980/myapp/*\"]" -i &gt; clientid.txt
c:\&gt; set /p CID=&lt;clientid.txt
c:\&gt; kcadm get clients/%CID%/installation/providers/keycloak-oidc-keycloak-json</pre></li></ul></div></li><li class="listitem"><p class="simpara">
						In a production environment, you must access Red Hat Single Sign-On with <code class="literal">https:</code> to avoid exposing tokens to network sniffers. If a server’s certificate is not issued by one of the trusted certificate authorities (CAs) that are included in Java’s default certificate truststore, prepare a <code class="literal filename">truststore.jks</code> file and instruct the Admin CLI to use it.
					</p><p class="simpara">
						For example, on:
					</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p class="simpara">
								Linux:
							</p><pre class="screen">$ kcadm.sh config truststore --trustpass $PASSWORD ~/.keycloak/truststore.jks</pre></li><li class="listitem"><p class="simpara">
								Windows:
							</p><pre class="screen">c:\&gt; kcadm config truststore --trustpass %PASSWORD% %HOMEPATH%\.keycloak\truststore.jks</pre></li></ul></div></li></ol></div></section><section class="section" id="authenticating"><div class="titlepage"><div><div><h2 class="title">20.3. Authenticating</h2></div></div></div><p>
				When you log in with the Admin CLI, you specify a server endpoint URL and a realm, and then you specify a user name. Another option is to specify only a clientId, which results in using a special "service account". When you log in using a user name, you must use a password for the specified user. When you log in using a clientId, you only need the client secret, not the user password. You could also use <code class="literal command">Signed JWT</code> instead of the client secret.
			</p><p>
				Make sure the account used for the session has the proper permissions to invoke Admin REST API operations. For example, the <code class="literal">realm-admin</code> role of the <code class="literal">realm-management</code> client allows the user to administer the realm within which the user is defined.
			</p><p>
				There are two primary mechanisms for authentication. One mechanism uses <code class="literal command">kcadm config credentials</code> to start an authenticated session.
			</p><pre class="screen">$ kcadm.sh config credentials --server http://localhost:8080/auth --realm master --user admin --password admin</pre><p>
				This approach maintains an authenticated session between the <code class="literal command">kcadm</code> command invocations by saving the obtained access token and the associated refresh token. It may also maintain other secrets in a private configuration file. See <a class="link" href="#working_with_alternative_configurations" title="20.4. Working with alternative configurations">next chapter</a> for more information on the configuration file.
			</p><p>
				The second approach only authenticates each command invocation for the duration of that invocation. This approach increases the load on the server and the time spent with roundtrips obtaining tokens. The benefit of this approach is not needing to save any tokens between invocations, which means nothing is saved to disk. This mode is used when the <code class="literal command">--no-config</code> argument is specified.
			</p><p>
				For example, when performing an operation, we specify all the information required for authentication.
			</p><pre class="screen">$ kcadm.sh get realms --no-config --server http://localhost:8080/auth --realm master --user admin --password admin</pre><p>
				Run the <code class="literal command">kcadm.sh help</code> command for more information on using the Admin CLI.
			</p><p>
				Run the <code class="literal command">kcadm.sh config credentials --help</code> command for more information about starting an authenticated session.
			</p></section><section class="section" id="working_with_alternative_configurations"><div class="titlepage"><div><div><h2 class="title">20.4. Working with alternative configurations</h2></div></div></div><p>
				By default, the Admin CLI automatically maintains a configuration file called <code class="literal filename">kcadm.config</code> located under the user’s home directory. In Linux-based systems, the full path name is <code class="literal filename">$HOME/.keycloak/kcadm.config</code>. On Windows, the full path name is <code class="literal filename">%HOMEPATH%\.keycloak\kcadm.config</code>. You can use the <code class="literal command">--config</code> option to point to a different file or location so you can maintain multiple authenticated sessions in parallel.
			</p><div class="admonition note"><div class="admonition_header">Note</div><div><p>
					It is best to perform operations tied to a single configuration file from a single thread.
				</p></div></div><p>
				Make sure you do not make the configuration file visible to other users on the system. It contains access tokens and secrets that should be kept private. By default, the <code class="literal filename">~/.keycloak</code> directory and its content are created automatically with proper access limits. If the directory already exists, its permissions are not updated.
			</p><p>
				If your unique circumstances require you to avoid storing secrets inside a configuration file, you can do so. It will be less convenient and you will have to make more token requests. To not store secrets, use the <code class="literal command">--no-config</code> option with all your commands and specify all the authentication information needed by the <code class="literal command">config credentials</code> command with each <code class="literal command">kcadm</code> invocation.
			</p></section><section class="section" id="basic_operations_and_resource_uris"><div class="titlepage"><div><div><h2 class="title">20.5. Basic operations and resource URIs</h2></div></div></div><p>
				The Admin CLI allows you to generically perform CRUD operations against Admin REST API endpoints with additional commands that simplify performing certain tasks.
			</p><p>
				The main usage pattern is listed below, where the <code class="literal command">create</code>, <code class="literal command">get</code>, <code class="literal command">update</code>, and <code class="literal command">delete</code> commands are mapped to the HTTP verbs <code class="literal">POST</code>, <code class="literal">GET</code>, <code class="literal">PUT</code>, and <code class="literal">DELETE</code>, respectively.
			</p><pre class="screen">$ kcadm.sh create ENDPOINT [ARGUMENTS]
$ kcadm.sh get ENDPOINT [ARGUMENTS]
$ kcadm.sh update ENDPOINT [ARGUMENTS]
$ kcadm.sh delete ENDPOINT [ARGUMENTS]</pre><p>
				ENDPOINT is a target resource URI and can either be absolute (starting with <code class="literal">http:</code> or <code class="literal">https:</code>) or relative, used to compose an absolute URL of the following format:
			</p><pre class="screen">SERVER_URI/admin/realms/REALM/ENDPOINT</pre><p>
				For example, if you authenticate against the server <a class="link" href="http://localhost:8080/auth">http://localhost:8080/auth</a> and realm is <code class="literal filename">master</code>, then using <code class="literal filename">users</code> as ENDPOINT results in the resource URL <a class="link" href="http://localhost:8080/auth/admin/realms/master/users">http://localhost:8080/auth/admin/realms/master/users</a>.
			</p><p>
				If you set ENDPOINT to <code class="literal filename">clients</code>, the effective resource URI would be <a class="link" href="http://localhost:8080/auth/admin/realms/master/clients">http://localhost:8080/auth/admin/realms/master/clients</a>.
			</p><p>
				There is a <code class="literal filename">realms</code> endpoint that is treated slightly differently because it is the container for realms. It resolves to:
			</p><pre class="screen">SERVER_URI/admin/realms</pre><p>
				There is also a <code class="literal filename">serverinfo</code> endpoint, which is treated the same way because it is independent of realms.
			</p><p>
				When you authenticate as a user with realm-admin powers, you might need to perform commands on multiple realms. In that case, specify the <code class="literal command">-r</code> option to tell explicitly which realm the command should be executed against. Instead of using <code class="literal filename">REALM</code> as specified via the <code class="literal command">--realm</code> option of <code class="literal command">kcadm.sh config credentials</code>, the <code class="literal filename">TARGET_REALM</code> is used.
			</p><pre class="screen">SERVER_URI/admin/realms/TARGET_REALM/ENDPOINT</pre><p>
				For example,
			</p><pre class="screen">$ kcadm.sh config credentials --server http://localhost:8080/auth --realm master --user admin --password admin
$ kcadm.sh create users -s username=testuser -s enabled=true -r demorealm</pre><p>
				In this example, you start a session authenticated as the <code class="literal filename">admin</code> user in the <code class="literal filename">master</code> realm. You then perform a POST call against the resource URL <code class="literal filename"><a class="link" href="http://localhost:8080/auth/admin/realms/demorealm/users">http://localhost:8080/auth/admin/realms/demorealm/users</a></code>.
			</p><p>
				The <code class="literal command">create</code> and <code class="literal command">update</code> commands send a JSON body to the server by default. You can use <code class="literal filename">-f FILENAME</code> to read a premade document from a file. When you can use <code class="literal command">-f -</code> option, the message body is read from standard input. You can also specify individual attributes and their values as seen in the previous <code class="literal command">create users</code> example. They are composed into a JSON body and sent to the server.
			</p><p>
				There are several ways to update a resource using the <code class="literal command">update</code> command. You can first determine the current state of a resource and save it to a file, and then edit that file and send it to the server for updating.
			</p><p>
				For example:
			</p><pre class="screen">$ kcadm.sh get realms/demorealm &gt; demorealm.json
$ vi demorealm.json
$ kcadm.sh update realms/demorealm -f demorealm.json</pre><p>
				This method updates the resource on the server with all the attributes in the sent JSON document.
			</p><p>
				Another option is to perform an on-the-fly update using the <code class="literal command">-s, --set</code> options to set new values.
			</p><p>
				For example:
			</p><pre class="screen">$ kcadm.sh update realms/demorealm -s enabled=false</pre><p>
				That method only updates the <code class="literal command">enabled</code> attribute to <code class="literal">false</code>.
			</p><p>
				By default, the <code class="literal commamd">update</code> command first performs a <code class="literal command">get</code> and then merges the new attribute values with existing values. This is the preferred behavior. In some cases, the endpoint may support the <code class="literal command">PUT</code> command but not the <code class="literal command">GET</code> command. You can use the <code class="literal command">-n</code> option to perform a "no-merge" update, which performs a <code class="literal command">PUT</code> command without first running a <code class="literal command">GET</code> command.
			</p></section><section class="section" id="realm_operations"><div class="titlepage"><div><div><h2 class="title">20.6. Realm operations</h2></div></div></div><h4 id="creating_a_new_realm">Creating a new realm</h4><p>
				Use the <code class="literal command">create</code> command on the <code class="literal">realms</code> endpoint to create a new enabled realm, and set the attributes to <code class="literal">realm</code> and <code class="literal">enabled</code>.
			</p><pre class="screen">$ kcadm.sh create realms -s realm=demorealm -s enabled=true</pre><p>
				A realm is not enabled by default. By enabling it, you can use a realm immediately for authentication.
			</p><p>
				A description for a new object can also be in a JSON format.
			</p><pre class="screen">$ kcadm.sh create realms -f demorealm.json</pre><p>
				You can send a JSON document with realm attributes directly from a file or piped to a standard input.
			</p><p>
				For example, on:
			</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">
						Linux:
					</li></ul></div><pre class="screen">$ kcadm.sh create realms -f - &lt;&lt; EOF
{ "realm": "demorealm", "enabled": true }
EOF</pre><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">
						Windows:
					</li></ul></div><pre class="screen">c:\&gt; echo { "realm": "demorealm", "enabled": true } | kcadm create realms -f -</pre><h4 id="listing_existing_realms">Listing existing realms</h4><p>
				The following command returns a list of all realms.
			</p><pre class="screen">$ kcadm.sh get realms</pre><div class="admonition note"><div class="admonition_header">Note</div><div><p>
					A list of realms is additionally filtered on the server to return only realms a user can see.
				</p></div></div><p>
				Returning the entire realm description often provides too much information. Most users are interested only in a subset of attributes, such as realm name and whether the realm is enabled. You can specify which attributes to return by using the <code class="literal command">--fields</code> option.
			</p><pre class="screen">$ kcadm.sh get realms --fields realm,enabled</pre><p>
				You can also display the result as comma separated values.
			</p><pre class="screen">$ kcadm.sh get realms --fields realm --format csv --noquotes</pre><h4 id="getting_a_specific_realm">Getting a specific realm</h4><p>
				You append a realm name to a collection URI to get an individual realm.
			</p><pre class="screen">$ kcadm.sh get realms/master</pre><h4 id="updating_a_realm">Updating a realm</h4><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p class="simpara">
						Use the <code class="literal command">-s</code> option to set new values for the attributes when you want to change only some of the realm’s attributes.
					</p><p class="simpara">
						For example:
					</p><pre class="screen">$ kcadm.sh update realms/demorealm -s enabled=false</pre></li><li class="listitem"><p class="simpara">
						If you want to set all writable attributes with new values, run a <code class="literal command">get</code> command, edit the current values in the JSON file, and resubmit.
					</p><p class="simpara">
						For example:
					</p><pre class="screen">$ kcadm.sh get realms/demorealm &gt; demorealm.json
$ vi demorealm.json
$ kcadm.sh update realms/demorealm -f demorealm.json</pre></li></ol></div><h4 id="deleting_a_realm">Deleting a realm</h4><p>
				Run the following command to delete a realm.
			</p><pre class="screen">$ kcadm.sh delete realms/demorealm</pre><h4 id="turning_on_all_login_page_options_for_the_realm">Turning on all login page options for the realm</h4><p>
				Set the attributes controlling specific capabilities to <code class="literal">true</code>.
			</p><p>
				For example:
			</p><pre class="screen">$ kcadm.sh update realms/demorealm -s registrationAllowed=true -s registrationEmailAsUsername=true -s rememberMe=true -s verifyEmail=true -s resetPasswordAllowed=true -s editUsernameAllowed=true</pre><h4 id="listing_the_realm_keys">Listing the realm keys</h4><p>
				Use the <code class="literal command">get</code> operation on the <code class="literal filename">keys</code> endpoint of the target realm.
			</p><pre class="screen">$ kcadm.sh get keys -r demorealm</pre><h4 id="generating_new_realm_keys">Generating new realm keys</h4><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p class="simpara">
						Get the ID of the target realm before adding a new RSA-generated key pair.
					</p><p class="simpara">
						For example:
					</p><pre class="screen">$ kcadm.sh get realms/demorealm --fields id --format csv --noquotes</pre></li><li class="listitem"><p class="simpara">
						Add a new key provider with a higher priority than the existing providers as revealed by <code class="literal command">kcadm.sh get keys -r demorealm</code>.
					</p><p class="simpara">
						For example, on:
					</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p class="simpara">
								Linux:
							</p><pre class="screen">$ kcadm.sh create components -r demorealm -s name=rsa-generated -s providerId=rsa-generated -s providerType=org.keycloak.keys.KeyProvider -s parentId=959844c1-d149-41d7-8359-6aa527fca0b0 -s 'config.priority=["101"]' -s 'config.enabled=["true"]' -s 'config.active=["true"]' -s 'config.keySize=["2048"]'</pre></li><li class="listitem"><p class="simpara">
								Windows:
							</p><pre class="screen">c:\&gt; kcadm create components -r demorealm -s name=rsa-generated -s providerId=rsa-generated -s providerType=org.keycloak.keys.KeyProvider -s parentId=959844c1-d149-41d7-8359-6aa527fca0b0 -s "config.priority=[\"101\"]" -s "config.enabled=[\"true\"]" -s "config.active=[\"true\"]" -s "config.keySize=[\"2048\"]"</pre></li></ul></div></li><li class="listitem"><p class="simpara">
						Set the <code class="literal">parentId</code> attribute to the value of the target realm’s ID.
					</p><p class="simpara">
						The newly added key should now become the active key as revealed by <code class="literal command">kcadm.sh get keys -r demorealm</code>.
					</p></li></ol></div><h4 id="adding_new_realm_keys_from_a_java_key_store_file">Adding new realm keys from a Java Key Store file</h4><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p class="simpara">
						Add a new key provider to add a new key pair already prepared as a JKS file on the server.
					</p><p class="simpara">
						For example, on:
					</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p class="simpara">
								Linux:
							</p><pre class="screen">$ kcadm.sh create components -r demorealm -s name=java-keystore -s providerId=java-keystore -s providerType=org.keycloak.keys.KeyProvider -s parentId=959844c1-d149-41d7-8359-6aa527fca0b0 -s 'config.priority=["101"]' -s 'config.enabled=["true"]' -s 'config.active=["true"]' -s 'config.keystore=["/opt/keycloak/keystore.jks"]' -s 'config.keystorePassword=["secret"]' -s 'config.keyPassword=["secret"]' -s 'config.alias=["localhost"]'</pre></li><li class="listitem"><p class="simpara">
								Windows:
							</p><pre class="screen">c:\&gt; kcadm create components -r demorealm -s name=java-keystore -s providerId=java-keystore -s providerType=org.keycloak.keys.KeyProvider -s parentId=959844c1-d149-41d7-8359-6aa527fca0b0 -s "config.priority=[\"101\"]" -s "config.enabled=[\"true\"]" -s "config.active=[\"true\"]" -s "config.keystore=[\"/opt/keycloak/keystore.jks\"]" -s "config.keystorePassword=[\"secret\"]" -s "config.keyPassword=[\"secret\"]" -s "config.alias=[\"localhost\"]"</pre></li></ul></div></li><li class="listitem">
						Make sure to change the attribute values for <code class="literal">keystore</code>, <code class="literal">keystorePassword</code>, <code class="literal">keyPassword</code>, and <code class="literal">alias</code> to match your specific keystore.
					</li><li class="listitem">
						Set the <code class="literal">parentId</code> attribute to the value of the target realm’s ID.
					</li></ol></div><h4 id="making_the_key_passive_or_disabling_the_key">Making the key passive or disabling the key</h4><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p class="simpara">
						Identify the key you want to make passive
					</p><pre class="screen">$ kcadm.sh get keys -r demorealm</pre></li><li class="listitem">
						Use the key’s <code class="literal">providerId</code> attribute to construct an endpoint URI, such as <code class="literal filename">components/PROVIDER_ID</code>.
					</li><li class="listitem"><p class="simpara">
						Perform an <code class="literal command">update</code>.
					</p><p class="simpara">
						For example, on:
					</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p class="simpara">
								Linux:
							</p><pre class="screen">$ kcadm.sh update components/PROVIDER_ID -r demorealm -s 'config.active=["false"]'</pre></li><li class="listitem"><p class="simpara">
								Windows:
							</p><pre class="screen">c:\&gt; kcadm update components/PROVIDER_ID -r demorealm -s "config.active=[\"false\"]"</pre><p class="simpara">
								You can update other key attributes.
							</p></li></ul></div></li><li class="listitem">
						Set a new <code class="literal">enabled</code> value to disable the key, for example, <code class="literal">config.enabled=["false"]</code>.
					</li><li class="listitem">
						Set a new <code class="literal">priority</code> value to change the key’s priority, for example, <code class="literal">config.priority=["110"]</code>.
					</li></ol></div><h4 id="deleting_an_old_key">Deleting an old key</h4><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem">
						Make sure the key you are deleting has been passive and disabled to prevent any existing tokens held by applications and users from abruptly failing to work.
					</li><li class="listitem"><p class="simpara">
						Identify the key you want to make passive.
					</p><pre class="screen">$ kcadm.sh get keys -r demorealm</pre></li><li class="listitem"><p class="simpara">
						Use the <code class="literal">providerId</code> of that key to perform a delete.
					</p><pre class="screen">$ kcadm.sh delete components/PROVIDER_ID -r demorealm</pre></li></ol></div><h4 id="configuring_event_logging_for_a_realm">Configuring event logging for a realm</h4><p>
				Use the <code class="literal command">update</code> command on the <code class="literal filename">events/config</code> endpoint.
			</p><p>
				The <code class="literal">eventsListeners</code> attribute contains a list of EventListenerProviderFactory IDs that specify all event listeners receiving events. Separately, there are attributes that control a built-in event storage, which allows querying past events via the Admin REST API. There is separate control over logging of service calls (<code class="literal">eventsEnabled</code>) and auditing events triggered during Admin Console or Admin REST API (<code class="literal">adminEventsEnabled</code>). You may want to set up expiry of old events so that your database does not fill up; <code class="literal">eventsExpiration</code> is set to time-to-live expressed in seconds.
			</p><p>
				Here is an example of setting up a built-in event listener that receives all the events and logs them through jboss-logging. (Using a logger called <code class="literal">org.keycloak.events</code>, error events are logged as <code class="literal">WARN</code>, and others are logged as <code class="literal">DEBUG</code>.)
			</p><p>
				For example, on:
			</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">
						Linux:
					</li></ul></div><pre class="screen">$ kcadm.sh update events/config -r demorealm -s 'eventsListeners=["jboss-logging"]'</pre><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">
						Windows:
					</li></ul></div><pre class="screen">c:\&gt; kcadm update events/config -r demorealm -s "eventsListeners=[\"jboss-logging\"]"</pre><p>
				Here is an example of turning on storage of all available ERROR events—not including auditing events—for 2 days so they can be retrieved via Admin REST.
			</p><p>
				For example, on:
			</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">
						Linux:
					</li></ul></div><pre class="screen">$ kcadm.sh update events/config -r demorealm -s eventsEnabled=true -s 'enabledEventTypes=["LOGIN_ERROR","REGISTER_ERROR","LOGOUT_ERROR","CODE_TO_TOKEN_ERROR","CLIENT_LOGIN_ERROR","FEDERATED_IDENTITY_LINK_ERROR","REMOVE_FEDERATED_IDENTITY_ERROR","UPDATE_EMAIL_ERROR","UPDATE_PROFILE_ERROR","UPDATE_PASSWORD_ERROR","UPDATE_TOTP_ERROR","VERIFY_EMAIL_ERROR","REMOVE_TOTP_ERROR","SEND_VERIFY_EMAIL_ERROR","SEND_RESET_PASSWORD_ERROR","SEND_IDENTITY_PROVIDER_LINK_ERROR","RESET_PASSWORD_ERROR","IDENTITY_PROVIDER_FIRST_LOGIN_ERROR","IDENTITY_PROVIDER_POST_LOGIN_ERROR","CUSTOM_REQUIRED_ACTION_ERROR","EXECUTE_ACTIONS_ERROR","CLIENT_REGISTER_ERROR","CLIENT_UPDATE_ERROR","CLIENT_DELETE_ERROR"]' -s eventsExpiration=172800</pre><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">
						Windows:
					</li></ul></div><pre class="screen">c:\&gt; kcadm update events/config -r demorealm -s eventsEnabled=true -s "enabledEventTypes=[\"LOGIN_ERROR\",\"REGISTER_ERROR\",\"LOGOUT_ERROR\",\"CODE_TO_TOKEN_ERROR\",\"CLIENT_LOGIN_ERROR\",\"FEDERATED_IDENTITY_LINK_ERROR\",\"REMOVE_FEDERATED_IDENTITY_ERROR\",\"UPDATE_EMAIL_ERROR\",\"UPDATE_PROFILE_ERROR\",\"UPDATE_PASSWORD_ERROR\",\"UPDATE_TOTP_ERROR\",\"VERIFY_EMAIL_ERROR\",\"REMOVE_TOTP_ERROR\",\"SEND_VERIFY_EMAIL_ERROR\",\"SEND_RESET_PASSWORD_ERROR\",\"SEND_IDENTITY_PROVIDER_LINK_ERROR\",\"RESET_PASSWORD_ERROR\",\"IDENTITY_PROVIDER_FIRST_LOGIN_ERROR\",\"IDENTITY_PROVIDER_POST_LOGIN_ERROR\",\"CUSTOM_REQUIRED_ACTION_ERROR\",\"EXECUTE_ACTIONS_ERROR\",\"CLIENT_REGISTER_ERROR\",\"CLIENT_UPDATE_ERROR\",\"CLIENT_DELETE_ERROR\"]" -s eventsExpiration=172800</pre><p>
				Here is an example of how to reset stored event types to <span class="strong strong"><strong>all available event types</strong></span>; setting to empty list is the same as enumerating all.
			</p><pre class="screen">$ kcadm.sh update events/config -r demorealm -s enabledEventTypes=[]</pre><p>
				Here is an example of how to enable storage of auditing events.
			</p><pre class="screen">$ kcadm.sh update events/config -r demorealm -s adminEventsEnabled=true -s adminEventsDetailsEnabled=true</pre><p>
				Here is an example of how to get the last 100 events; they are ordered from newest to oldest.
			</p><pre class="screen">$ kcadm.sh get events --offset 0 --limit 100</pre><p>
				Here is an example of how to delete all saved events.
			</p><pre class="screen">$ kcadm delete events</pre><h4 id="flushing_the_caches">Flushing the caches</h4><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem">
						Use the <code class="literal command">create</code> command and one of the following endpoints: <code class="literal filename">clear-realm-cache</code>, <code class="literal filename">clear-user-cache</code>, or <code class="literal filename">clear-keys-cache</code>.
					</li><li class="listitem"><p class="simpara">
						Set <code class="literal">realm</code> to the same value as the target realm.
					</p><p class="simpara">
						For example:
					</p><pre class="screen">$ kcadm.sh create clear-realm-cache -r demorealm -s realm=demorealm
$ kcadm.sh create clear-user-cache -r demorealm -s realm=demorealm
$ kcadm.sh create clear-keys-cache -r demorealm -s realm=demorealm</pre></li></ol></div><h4 id="importing_a_realm_from_exported_json_file">Importing a realm from exported .json file</h4><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem">
						Use the <code class="literal command">create</code> command on the <code class="literal filename">partialImport</code> endpoint.
					</li><li class="listitem">
						Set <code class="literal">ifResourceExists</code> to one of <code class="literal">FAIL</code>, <code class="literal">SKIP</code>, <code class="literal">OVERWRITE</code>.
					</li><li class="listitem"><p class="simpara">
						Use <code class="literal">-f</code> to submit the exported realm <code class="literal">.json</code> file
					</p><p class="simpara">
						For example:
					</p><pre class="screen">$ kcadm.sh create partialImport -r demorealm2 -s ifResourceExists=FAIL -o -f demorealm.json</pre><p class="simpara">
						If realm does not yet exist, you first have to create it.
					</p><p class="simpara">
						For example:
					</p><pre class="screen">$ kcadm.sh create realms -s realm=demorealm2 -s enabled=true</pre></li></ol></div></section><section class="section" id="role_operations"><div class="titlepage"><div><div><h2 class="title">20.7. Role operations</h2></div></div></div><h4 id="creating_a_realm_role">Creating a realm role</h4><p>
				Use the <code class="literal filename">roles</code> endpoint to create a realm role.
			</p><pre class="screen">$ kcadm.sh create roles -r demorealm -s name=user -s 'description=Regular user with limited set of permissions'</pre><h4 id="creating_a_client_role">Creating a client role</h4><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p class="simpara">
						Identify the client first and then use the <code class="literal command">get</code> command to list available clients when creating a client role.
					</p><pre class="screen">$ kcadm.sh get clients -r demorealm --fields id,clientId</pre></li><li class="listitem"><p class="simpara">
						Create a new role by using the <code class="literal command">clientId</code> attribute to construct an endpoint URI, such as <code class="literal filename">clients/ID/roles</code>.
					</p><p class="simpara">
						For example:
					</p><pre class="screen">$ kcadm.sh create clients/a95b6af3-0bdc-4878-ae2e-6d61a4eca9a0/roles -r demorealm -s name=editor -s 'description=Editor can edit, and publish any article'</pre></li></ol></div><h4 id="listing_realm_roles">Listing realm roles</h4><p>
				Use the <code class="literal command">get</code> command on the <code class="literal filename">roles</code> endpoint to list existing realm roles.
			</p><pre class="screen">$ kcadm.sh get roles -r demorealm</pre><p>
				You can also use the <code class="literal command">get-roles</code> command.
			</p><pre class="screen">$ kcadm.sh get-roles -r demorealm</pre><h4 id="listing_client_roles">Listing client roles</h4><p>
				There is a dedicated <code class="literal command">get-roles</code> command to simplify listing realm and client roles. It is an extension of the <code class="literal command">get</code> command and behaves the same with additional semantics for listing roles.
			</p><p>
				Use the <code class="literal command">get-roles</code> command, passing it either the clientId attribute (via the <code class="literal command">--cclientid</code> option) or <code class="literal command">id</code> (via the <code class="literal command">--cid</code> option) to identify the client to list client roles.
			</p><p>
				For example:
			</p><pre class="screen">$ kcadm.sh get-roles -r demorealm --cclientid realm-management</pre><h4 id="getting_a_specific_realm_role">Getting a specific realm role</h4><p>
				Use the <code class="literal command">get</code> command and the role <code class="literal filename">name</code> to construct an endpoint URI for a specific realm role: <code class="literal filename">roles/ROLE_NAME</code>, where <code class="literal filename">user</code> is the name of the existing role.
			</p><p>
				For example:
			</p><pre class="screen">$ kcadm.sh get roles/user -r demorealm</pre><p>
				You can also use the special <code class="literal command">get-roles</code> command, passing it a role name (via the <code class="literal command">--rolename</code> option) or ID (via the <code class="literal command">--roleid</code> option).
			</p><p>
				For example:
			</p><pre class="screen">$ kcadm.sh get-roles -r demorealm --rolename user</pre><h4 id="getting_a_specific_client_role">Getting a specific client role</h4><p>
				Use a dedicated <code class="literal command">get-roles</code> command, passing it either the clientId attribute (via the <code class="literal command">--cclientid</code> option) or ID (via the <code class="literal command">--cid</code> option) to identify the client, and passing it either the role name (via the <code class="literal command">--rolename</code> option) or ID (via the <code class="literal command">--roleid</code>) to identify a specific client role.
			</p><p>
				For example:
			</p><pre class="screen">$ kcadm.sh get-roles -r demorealm --cclientid realm-management --rolename manage-clients</pre><h4 id="updating_a_realm_role">Updating a realm role</h4><p>
				Use the <code class="literal command">update</code> command with the same endpoint URI that you used to get a specific realm role.
			</p><p>
				For example:
			</p><pre class="screen">$ kcadm.sh update roles/user -r demorealm -s 'description=Role representing a regular user'</pre><h4 id="updating_a_client_role">Updating a client role</h4><p>
				Use the <code class="literal command">update</code> command with the same endpoint URI that you used to get a specific client role.
			</p><p>
				For example:
			</p><pre class="screen">$ kcadm.sh update clients/a95b6af3-0bdc-4878-ae2e-6d61a4eca9a0/roles/editor -r demorealm -s 'description=User that can edit, and publish articles'</pre><h4 id="deleting_a_realm_role">Deleting a realm role</h4><p>
				Use the <code class="literal command">delete</code> command with the same endpoint URI that you used to get a specific realm role.
			</p><p>
				For example:
			</p><pre class="screen">$ kcadm.sh delete roles/user -r demorealm</pre><h4 id="deleting_a_client_role">Deleting a client role</h4><p>
				Use the <code class="literal command">delete</code> command with the same endpoint URI that you used to get a specific client role.
			</p><p>
				For example:
			</p><pre class="screen">$ kcadm.sh delete clients/a95b6af3-0bdc-4878-ae2e-6d61a4eca9a0/roles/editor -r demorealm</pre><h4 id="listing_assigned_available_and_effective_realm_roles_for_a_composite_role">Listing assigned, available, and effective realm roles for a composite role</h4><p>
				Use a dedicated <code class="literal command">get-roles</code> command to list assigned, available, and effective realm roles for a composite role.
			</p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p class="simpara">
						To list <span class="strong strong"><strong>assigned</strong></span> realm roles for the composite role, you can specify the target composite role by either name (via the <code class="literal command">--rname</code> option) or ID (via the <code class="literal command">--rid</code> option).
					</p><p class="simpara">
						For example:
					</p><pre class="screen">$ kcadm.sh get-roles -r demorealm --rname testrole</pre></li><li class="listitem"><p class="simpara">
						Use the additional <code class="literal command">--effective</code> option to list <span class="strong strong"><strong>effective</strong></span> realm roles.
					</p><p class="simpara">
						For example:
					</p><pre class="screen">$ kcadm.sh get-roles -r demorealm --rname testrole --effective</pre></li><li class="listitem"><p class="simpara">
						Use the <code class="literal command">--available</code> option to list realm roles that can still be added to the composite role.
					</p><p class="simpara">
						For example:
					</p><pre class="screen">$ kcadm.sh get-roles -r demorealm --rname testrole --available</pre></li></ol></div><h4 id="listing_assigned_available_and_effective_client_roles_for_a_composite_role">Listing assigned, available, and effective client roles for a composite role</h4><p>
				Use a dedicated <code class="literal command">get-roles</code> command to list assigned, available, and effective client roles for a composite role.
			</p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p class="simpara">
						To list <span class="strong strong"><strong>assigned</strong></span> client roles for the composite role, you can specify the target composite role by either name (via the <code class="literal command">--rname</code> option) or ID (via the <code class="literal command">--rid</code> option) and client by either the clientId attribute (via the <code class="literal command">--cclientid</code> option) or ID (via the <code class="literal command">--cid</code> option).
					</p><p class="simpara">
						For example:
					</p><pre class="screen">$ kcadm.sh get-roles -r demorealm --rname testrole --cclientid realm-management</pre></li><li class="listitem"><p class="simpara">
						Use the additional <code class="literal command">--effective</code> option to list <span class="strong strong"><strong>effective</strong></span> realm roles.
					</p><p class="simpara">
						For example:
					</p><pre class="screen">$ kcadm.sh get-roles -r demorealm --rname testrole --cclientid realm-management --effective</pre></li><li class="listitem"><p class="simpara">
						Use the <code class="literal command">--available</code> option to list realm roles that can still be added to the target composite role.
					</p><p class="simpara">
						For example:
					</p><pre class="screen">$ kcadm.sh get-roles -r demorealm --rname testrole --cclientid realm-management --available</pre></li></ol></div><h4 id="adding_realm_roles_to_a_composite_role">Adding realm roles to a composite role</h4><p>
				There is a dedicated <code class="literal command">add-roles</code> command that can be used for adding realm roles and client roles.
			</p><p>
				The following example adds the <code class="literal command">user</code> role to the composite role <code class="literal command">testrole</code>.
			</p><pre class="screen">$ kcadm.sh add-roles --rname testrole --rolename user -r demorealm</pre><h4 id="removing_realm_roles_from_a_composite_role">Removing realm roles from a composite role</h4><p>
				There is a dedicated <code class="literal command">remove-roles</code> command that can be used to remove realm roles and client roles.
			</p><p>
				The following example removes the <code class="literal command">user</code> role from the target composite role <code class="literal command">testrole</code>.
			</p><pre class="screen">$ kcadm.sh remove-roles --rname testrole --rolename user -r demorealm</pre><h4 id="adding_client_roles_to_a_realm_role">Adding client roles to a realm role</h4><p>
				Use a dedicated <code class="literal command">add-roles</code> command that can be used for adding realm roles and client roles.
			</p><p>
				The following example adds the roles defined on the client <code class="literal command">realm-management</code> - <code class="literal">create-client</code> role and the <code class="literal command">view-users</code> role to the <code class="literal command">testrole</code> composite role.
			</p><pre class="screen">$ kcadm.sh add-roles -r demorealm --rname testrole --cclientid realm-management --rolename create-client --rolename view-users</pre><h4 id="adding_client_roles_to_a_client_role">Adding client roles to a client role</h4><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p class="simpara">
						Determine the ID of the composite client role by using the <code class="literal command">get-roles</code> command.
					</p><p class="simpara">
						For example:
					</p><pre class="screen">$ kcadm.sh get-roles -r demorealm --cclientid test-client --rolename operations</pre></li><li class="listitem">
						Assume that there is a client with a clientId attribute of <code class="literal filename">test-client</code>, a client role called <code class="literal filename">support</code>, and another client role called <code class="literal filename">operations</code>, which becomes a composite role, that has an ID of "fc400897-ef6a-4e8c-872b-1581b7fa8a71".
					</li><li class="listitem"><p class="simpara">
						Use the following example to add another role to the composite role.
					</p><pre class="screen">$ kcadm.sh add-roles -r demorealm --cclientid test-client --rid fc400897-ef6a-4e8c-872b-1581b7fa8a71 --rolename support</pre></li><li class="listitem"><p class="simpara">
						List the roles of a composite role by using the <code class="literal command">get-roles --all</code> command.
					</p><p class="simpara">
						For example:
					</p><pre class="screen">$ kcadm.sh get-roles --rid fc400897-ef6a-4e8c-872b-1581b7fa8a71 --all</pre></li></ol></div><h4 id="removing_client_roles_from_a_composite_role">Removing client roles from a composite role</h4><p>
				Use a dedicated <code class="literal command">remove-roles</code> command to remove client roles from a composite role.
			</p><p>
				Use the following example to remove two roles defined on the client <code class="literal command">realm-management</code> - <code class="literal">create-client</code> role and the <code class="literal command">view-users</code> role from the <code class="literal command">testrole</code> composite role.
			</p><pre class="screen">$ kcadm.sh remove-roles -r demorealm --rname testrole --cclientid realm-management --rolename create-client --rolename view-users</pre><h4 id="adding_client_roles_to_a_group">Adding client roles to a group</h4><p>
				Use a dedicated <code class="literal command">add-roles</code> command that can be used for adding realm roles and client roles.
			</p><p>
				The following example adds the roles defined on the client <code class="literal command">realm-management</code> - <code class="literal">create-client</code> role and the <code class="literal command">view-users</code> role to the <code class="literal command">Group</code> group (via the <code class="literal command">--gname</code> option). The group can alternatively be specified by ID (via the <code class="literal command">--gid</code> option).
			</p><p>
				See <a class="link" href="#group_operations" title="20.10. Group operations">Group operations</a> for more operations that can be performed to groups.
			</p><pre class="screen">$ kcadm.sh add-roles -r demorealm --gname Group --cclientid realm-management --rolename create-client --rolename view-users</pre><h4 id="removing_client_roles_from_a_group">Removing client roles from a group</h4><p>
				Use a dedicated <code class="literal command">remove-roles</code> command to remove client roles from a group.
			</p><p>
				Use the following example to remove two roles defined on the client <code class="literal command">realm management</code> - <code class="literal">create-client</code> role and the <code class="literal command">view-users</code> role from the <code class="literal command">Group</code> group.
			</p><p>
				See <a class="link" href="#group_operations" title="20.10. Group operations">Group operations</a> for more operations that can be performed to groups.
			</p><pre class="screen">$ kcadm.sh remove-roles -r demorealm --gname Group --cclientid realm-management --rolename create-client --rolename view-users</pre></section><section class="section" id="client_operations"><div class="titlepage"><div><div><h2 class="title">20.8. Client operations</h2></div></div></div><h4 id="creating_a_client">Creating a client</h4><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p class="simpara">
						Run the <code class="literal command">create</code> command on a <code class="literal filename">clients</code> endpoint to create a new client.
					</p><p class="simpara">
						For example:
					</p><pre class="screen">$ kcadm.sh create clients -r demorealm -s clientId=myapp -s enabled=true</pre></li><li class="listitem"><p class="simpara">
						Specify a secret if you want to set a secret for adapters to authenticate.
					</p><p class="simpara">
						For example:
					</p><pre class="screen">$ kcadm.sh create clients -r demorealm -s clientId=myapp -s enabled=true -s clientAuthenticatorType=client-secret -s secret=d0b8122f-8dfb-46b7-b68a-f5cc4e25d000</pre></li></ol></div><h4 id="listing_clients">Listing clients</h4><p>
				Use the <code class="literal command">get</code> command on the <code class="literal filename">clients</code> endpoint to list clients.
			</p><p>
				For example:
			</p><pre class="screen">$ kcadm.sh get clients -r demorealm --fields id,clientId</pre><p>
				This example filters the output to list only the <code class="literal filename">id</code> and <code class="literal filename">clientId</code> attributes.
			</p><h4 id="getting_a_specific_client">Getting a specific client</h4><p>
				Use a client’s ID to construct an endpoint URI that targets a specific client, such as <code class="literal filename">clients/ID</code>.
			</p><p>
				For example:
			</p><pre class="screen">$ kcadm.sh get clients/c7b8547f-e748-4333-95d0-410b76b3f4a3 -r demorealm</pre><h4 id="getting_the_current_secret_for_a_specific_client">Getting the current secret for a specific client</h4><p>
				Use a client’s ID to construct an endpoint URI, such as <code class="literal filename">clients/ID/client-secret</code>.
			</p><p>
				For example:
			</p><pre class="screen">$ kcadm.sh get clients/$CID/client-secret</pre><h4 id="generate_a_new_secret_for_a_specific_client">Generate a new secret for a specific client</h4><p>
				Use a client’s ID to construct an endpoint URI, such as <code class="literal filename">clients/ID/client-secret</code>.
			</p><p>
				For example:
			</p><pre class="screen">$ kcadm.sh create clients/$CID/client-secret</pre><h4 id="updating_the_current_secret_for_a_specific_client">Updating the current secret for a specific client</h4><p>
				Use a client’s ID to construct an endpoint URI, such as <code class="literal filename">clients/ID</code>.
			</p><p>
				For example:
			</p><pre class="screen">$ kcadm.sh update clients/$CID -s "secret=newSecret"</pre><h4 id="getting_an_adapter_configuration_file_keycloak_json_for_a_specific_client">Getting an adapter configuration file (keycloak.json) for a specific client</h4><p>
				Use a client’s ID to construct an endpoint URI that targets a specific client, such as <code class="literal filename">clients/ID/installation/providers/keycloak-oidc-keycloak-json</code>.
			</p><p>
				For example:
			</p><pre class="screen">$ kcadm.sh get clients/c7b8547f-e748-4333-95d0-410b76b3f4a3/installation/providers/keycloak-oidc-keycloak-json -r demorealm</pre><h4 id="getting_a_wildfly_subsystem_adapter_configuration_for_a_specific_client">Getting a WildFly subsystem adapter configuration for a specific client</h4><p>
				Use a client’s ID to construct an endpoint URI that targets a specific client, such as <code class="literal filename">clients/ID/installation/providers/keycloak-oidc-jboss-subsystem</code>.
			</p><p>
				For example:
			</p><pre class="screen">$ kcadm.sh get clients/c7b8547f-e748-4333-95d0-410b76b3f4a3/installation/providers/keycloak-oidc-jboss-subsystem -r demorealm</pre><h4 id="getting_a_docker_v2_example_configuration_for_a_specific_client">Getting a Docker-v2 example configuration for a specific client</h4><p>
				Use a client’s ID to construct an endpoint URI that targets a specific client, such as <code class="literal filename">clients/ID/installation/providers/docker-v2-compose-yaml</code>.
			</p><p>
				Note that response will be in <code class="literal">.zip</code> format.
			</p><p>
				For example:
			</p><pre class="screen">$ kcadm.sh get http://localhost:8080/auth/admin/realms/demorealm/clients/8f271c35-44e3-446f-8953-b0893810ebe7/installation/providers/docker-v2-compose-yaml -r demorealm &gt; keycloak-docker-compose-yaml.zip</pre><h4 id="updating_a_client">Updating a client</h4><p>
				Use the <code class="literal command">update</code> command with the same endpoint URI that you used to get a specific client.
			</p><p>
				For example, on:
			</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">
						Linux:
					</li></ul></div><pre class="screen">$ kcadm.sh update clients/c7b8547f-e748-4333-95d0-410b76b3f4a3 -r demorealm -s enabled=false -s publicClient=true -s 'redirectUris=["http://localhost:8080/myapp/*"]' -s baseUrl=http://localhost:8080/myapp -s adminUrl=http://localhost:8080/myapp</pre><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">
						Windows:
					</li></ul></div><pre class="screen">c:\&gt; kcadm update clients/c7b8547f-e748-4333-95d0-410b76b3f4a3 -r demorealm -s enabled=false -s publicClient=true -s "redirectUris=[\"http://localhost:8080/myapp/*\"]" -s baseUrl=http://localhost:8080/myapp -s adminUrl=http://localhost:8080/myapp</pre><h4 id="deleting_a_client">Deleting a client</h4><p>
				Use the <code class="literal command">delete</code> command with the same endpoint URI that you used to get a specific client.
			</p><p>
				For example:
			</p><pre class="screen">$ kcadm.sh delete clients/c7b8547f-e748-4333-95d0-410b76b3f4a3 -r demorealm</pre><h4 id="adding_or_removing_roles_for_client_s_service_account">Adding or removing roles for client’s service account</h4><p>
				Service account for the client is just a special kind of user account with username <code class="literal filename">service-account-CLIENT_ID</code>. You can perform user operations on this account as if it was a regular user.
			</p></section><section class="section" id="user_operations"><div class="titlepage"><div><div><h2 class="title">20.9. User operations</h2></div></div></div><h4 id="creating_a_user">Creating a user</h4><p>
				Run the <code class="literal command">create</code> command on the <code class="literal filename">users</code> endpoint to create a new user.
			</p><p>
				For example:
			</p><pre class="screen">$ kcadm.sh create users -r demorealm -s username=testuser -s enabled=true</pre><h4 id="listing_users">Listing users</h4><p>
				Use the <code class="literal filename">users</code> endpoint to list users. The target user will have to change the password the next time they log in.
			</p><p>
				For example:
			</p><pre class="screen">$ kcadm.sh get users -r demorealm --offset 0 --limit 1000</pre><p>
				You can filter users by <code class="literal filename">username</code>, <code class="literal filename">firstName</code>, <code class="literal filename">lastName</code>, or <code class="literal filename">email</code>.
			</p><p>
				For example:
			</p><pre class="screen">$ kcadm.sh get users -r demorealm -q email=google.com
$ kcadm.sh get users -r demorealm -q username=testuser</pre><div class="admonition note"><div class="admonition_header">Note</div><div><p>
					Filtering does not use exact matching. For example, the above example would match the value of the <code class="literal filename">username</code> attribute against the <code class="literal filename">*testuser*</code> pattern.
				</p></div></div><p>
				You can also filter across multiple attributes by specifying multiple <code class="literal command">-q</code> options, which return only users that match the condition for all the attributes.
			</p><h4 id="getting_a_specific_user">Getting a specific user</h4><p>
				Use a user’s ID to compose an endpoint URI, such as <code class="literal filename">users/USER_ID</code>.
			</p><p>
				For example:
			</p><pre class="screen">$ kcadm.sh get users/0ba7a3fd-6fd8-48cd-a60b-2e8fd82d56e2 -r demorealm</pre><h4 id="updating_a_user">Updating a user</h4><p>
				Use the <code class="literal command">update</code> command with the same endpoint URI that you used to get a specific user.
			</p><p>
				For example, on:
			</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">
						Linux:
					</li></ul></div><pre class="screen">$ kcadm.sh update users/0ba7a3fd-6fd8-48cd-a60b-2e8fd82d56e2 -r demorealm -s 'requiredActions=["VERIFY_EMAIL","UPDATE_PROFILE","CONFIGURE_TOTP","UPDATE_PASSWORD"]'</pre><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">
						Windows:
					</li></ul></div><pre class="screen">c:\&gt; kcadm update users/0ba7a3fd-6fd8-48cd-a60b-2e8fd82d56e2 -r demorealm -s "requiredActions=[\"VERIFY_EMAIL\",\"UPDATE_PROFILE\",\"CONFIGURE_TOTP\",\"UPDATE_PASSWORD\"]"</pre><h4 id="deleting_a_user">Deleting a user</h4><p>
				Use the <code class="literal command">delete</code> command with the same endpoint URI that you used to get a specific user.
			</p><p>
				For example:
			</p><pre class="screen">$ kcadm.sh delete users/0ba7a3fd-6fd8-48cd-a60b-2e8fd82d56e2 -r demorealm</pre><h4 id="resetting_a_user_s_password">Resetting a user’s password</h4><p>
				Use the dedicated <code class="literal command">set-password</code> command to reset a user’s password.
			</p><p>
				For example:
			</p><pre class="screen">$ kcadm.sh set-password -r demorealm --username testuser --new-password NEWPASSWORD --temporary</pre><p>
				That command sets a temporary password for the user. The target user will have to change the password the next time they log in.
			</p><p>
				You can use <code class="literal command">--userid</code> if you want to specify the user by using the <code class="literal filename">id</code> attribute.
			</p><p>
				You can achieve the same result using the <code class="literal command">update</code> command on an endpoint constructed from the one you used to get a specific user, such as <code class="literal filename">users/USER_ID/reset-password</code>.
			</p><p>
				For example:
			</p><pre class="screen">$ kcadm.sh update users/0ba7a3fd-6fd8-48cd-a60b-2e8fd82d56e2/reset-password -r demorealm -s type=password -s value=NEWPASSWORD -s temporary=true -n</pre><p>
				The last parameter (<code class="literal command">-n</code>) ensures that only the <code class="literal command">PUT</code> command is performed without a prior <code class="literal command">GET</code> command. It is necessary in this instance because the <code class="literal command">reset-password</code> endpoint does not support <code class="literal command">GET</code>.
			</p><h4 id="listing_assigned_available_and_effective_realm_roles_for_a_user">Listing assigned, available, and effective realm roles for a user</h4><p>
				You can use a dedicated <code class="literal command">get-roles</code> command to list assigned, available, and effective realm roles for a user.
			</p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p class="simpara">
						Specify the target user by either user name or ID to list <span class="strong strong"><strong>assigned</strong></span> realm roles for the user.
					</p><p class="simpara">
						For example:
					</p><pre class="screen">$ kcadm.sh get-roles -r demorealm --uusername testuser</pre></li><li class="listitem"><p class="simpara">
						Use the additional <code class="literal command">--effective</code> option to list <span class="strong strong"><strong>effective</strong></span> realm roles.
					</p><p class="simpara">
						For example:
					</p><pre class="screen">$ kcadm.sh get-roles -r demorealm --uusername testuser --effective</pre></li><li class="listitem"><p class="simpara">
						Use the <code class="literal command">--available</code> option to list realm roles that can still be added to the user.
					</p><p class="simpara">
						For example:
					</p><pre class="screen">$ kcadm.sh get-roles -r demorealm --uusername testuser --available</pre></li></ol></div><h4 id="listing_assigned_available_and_effective_client_roles_for_a_user">Listing assigned, available, and effective client roles for a user</h4><p>
				Use a dedicated <code class="literal command">get-roles</code> command to list assigned, available, and effective client roles for a user.
			</p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p class="simpara">
						Specify the target user by either a user name (via the <code class="literal command">--uusername</code> option) or an ID (via the <code class="literal command">--uid</code> option) and client by either a clientId attribute (via the <code class="literal command">--cclientid</code> option) or an ID (via the <code class="literal command">--cid</code> option) to list <span class="strong strong"><strong>assigned</strong></span> client roles for the user.
					</p><p class="simpara">
						For example:
					</p><pre class="screen">$ kcadm.sh get-roles -r demorealm --uusername testuser --cclientid realm-management</pre></li><li class="listitem"><p class="simpara">
						Use the additional <code class="literal command">--effective</code> option to list <span class="strong strong"><strong>effective</strong></span> realm roles.
					</p><p class="simpara">
						For example:
					</p><pre class="screen">$ kcadm.sh get-roles -r demorealm --uusername testuser --cclientid realm-management --effective</pre></li><li class="listitem"><p class="simpara">
						Use the <code class="literal command">--available</code> option to list realm roles that can still be added to the user.
					</p><p class="simpara">
						For example:
					</p><pre class="screen">$ kcadm.sh get-roles -r demorealm --uusername testuser --cclientid realm-management --available</pre></li></ol></div><h4 id="adding_realm_roles_to_a_user">Adding realm roles to a user</h4><p>
				Use a dedicated <code class="literal command">add-roles</code> command to add realm roles to a user.
			</p><p>
				Use the following example to add the <code class="literal command">user</code> role to user <code class="literal command">testuser</code>.
			</p><pre class="screen">$ kcadm.sh add-roles --uusername testuser --rolename user -r demorealm</pre><h4 id="removing_realm_roles_from_a_user">Removing realm roles from a user</h4><p>
				Use a dedicated <code class="literal command">remove-roles</code> command to remove realm roles from a user.
			</p><p>
				Use the following example to remove the <code class="literal command">user</code> role from the user <code class="literal command">testuser</code>.
			</p><pre class="screen">$ kcadm.sh remove-roles --uusername testuser --rolename user -r demorealm</pre><h4 id="adding_client_roles_to_a_user">Adding client roles to a user</h4><p>
				Use a dedicated <code class="literal command">add-roles</code> command to add client roles to a user.
			</p><p>
				Use the following example to add two roles defined on the client <code class="literal command">realm management</code> - <code class="literal">create-client</code> role and the <code class="literal command">view-users</code> role to the user <code class="literal">testuser</code>.
			</p><pre class="screen">$ kcadm.sh add-roles -r demorealm --uusername testuser --cclientid realm-management --rolename create-client --rolename view-users</pre><h4 id="removing_client_roles_from_a_user">Removing client roles from a user</h4><p>
				Use a dedicated <code class="literal command">remove-roles</code> command to remove client roles from a user.
			</p><p>
				Use the following example to remove two roles defined on the realm management client.
			</p><pre class="screen">$ kcadm.sh remove-roles -r demorealm --uusername testuser --cclientid realm-management --rolename create-client --rolename view-users</pre><h4 id="listing_a_user_s_sessions">Listing a user’s sessions</h4><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem">
						Identify the user’s ID, and then use it to compose an endpoint URI, such as <code class="literal filename">users/ID/sessions</code>.
					</li><li class="listitem"><p class="simpara">
						Use the <code class="literal command">get</code> command to retrieve a list of the user’s sessions.
					</p><p class="simpara">
						For example:
					</p><pre class="screen">$kcadm get users/6da5ab89-3397-4205-afaa-e201ff638f9e/sessions</pre></li></ol></div><h4 id="logging_out_a_user_from_a_specific_session">Logging out a user from a specific session</h4><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem">
						Determine the session’s ID as described above.
					</li><li class="listitem">
						Use the session’s ID to compose an endpoint URI, such as <code class="literal filename">sessions/ID</code>.
					</li><li class="listitem"><p class="simpara">
						Use the <code class="literal command">delete</code> command to invalidate the session.
					</p><p class="simpara">
						For example:
					</p><pre class="screen">$ kcadm.sh delete sessions/d0eaa7cc-8c5d-489d-811a-69d3c4ec84d1</pre></li></ol></div><h4 id="logging_out_a_user_from_all_sessions">Logging out a user from all sessions</h4><p>
				You need a user’s ID to construct an endpoint URI, such as <code class="literal filename">users/ID/logout</code>.
			</p><p>
				Use the <code class="literal command">create</code> command to perform <code class="literal command">POST</code> on that endpoint URI.
			</p><p>
				For example:
			</p><pre class="screen">$ kcadm.sh create users/6da5ab89-3397-4205-afaa-e201ff638f9e/logout -r demorealm -s realm=demorealm -s user=6da5ab89-3397-4205-afaa-e201ff638f9e</pre></section><section class="section" id="group_operations"><div class="titlepage"><div><div><h2 class="title">20.10. Group operations</h2></div></div></div><h4 id="creating_a_group">Creating a group</h4><p>
				Use the <code class="literal command">create</code> command on the <code class="literal filename">groups</code> endpoint to create a new group.
			</p><p>
				For example:
			</p><pre class="screen">$ kcadm.sh create groups -r demorealm -s name=Group</pre><h4 id="listing_groups">Listing groups</h4><p>
				Use the <code class="literal command">get</code> command on the <code class="literal filename">groups</code> endpoint to list groups.
			</p><p>
				For example:
			</p><pre class="screen">$ kcadm.sh get groups -r demorealm</pre><h4 id="getting_a_specific_group">Getting a specific group</h4><p>
				Use the group’s ID to construct an endpoint URI, such as <code class="literal">groups/GROUP_ID</code>.
			</p><p>
				For example:
			</p><pre class="screen">$ kcadm.sh get groups/51204821-0580-46db-8f2d-27106c6b5ded -r demorealm</pre><h4 id="updating_a_group">Updating a group</h4><p>
				Use the <code class="literal command">update</code> command with the same endpoint URI that you used to get a specific group.
			</p><p>
				For example:
			</p><pre class="screen">$ kcadm.sh update groups/51204821-0580-46db-8f2d-27106c6b5ded -s 'attributes.email=["group@example.com"]' -r demorealm</pre><h4 id="deleting_a_group">Deleting a group</h4><p>
				Use the <code class="literal command">delete</code> command with the same endpoint URI that you used to get a specific group.
			</p><p>
				For example:
			</p><pre class="screen">$ kcadm.sh delete groups/51204821-0580-46db-8f2d-27106c6b5ded -r demorealm</pre><h4 id="creating_a_subgroup">Creating a subgroup</h4><p>
				Find the ID of the parent group by listing groups, and then use that ID to construct an endpoint URI, such as <code class="literal filename">groups/GROUP_ID/children</code>.
			</p><p>
				For example:
			</p><pre class="screen">$ kcadm.sh create groups/51204821-0580-46db-8f2d-27106c6b5ded/children -r demorealm -s name=SubGroup</pre><h4 id="moving_a_group_under_another_group">Moving a group under another group</h4><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem">
						Find the ID of an existing parent group and of an existing child group.
					</li><li class="listitem">
						Use the parent group’s ID to construct an endpoint URI, such as <code class="literal filename">groups/PARENT_GROUP_ID/children</code>.
					</li><li class="listitem">
						Run the <code class="literal command">create</code> command on this endpoint and pass the child group’s ID as a JSON body.
					</li></ol></div><p>
				For example:
			</p><pre class="screen">$ kcadm.sh create groups/51204821-0580-46db-8f2d-27106c6b5ded/children -r demorealm -s id=08d410c6-d585-4059-bb07-54dcb92c5094</pre><h4 id="get_groups_for_a_specific_user">Get groups for a specific user</h4><p>
				Use a user’s ID to determine a user’s membership in groups to compose an endpoint URI, such as <code class="literal filename">users/USER_ID/groups</code>.
			</p><p>
				For example:
			</p><pre class="screen">$ kcadm.sh get users/b544f379-5fc4-49e5-8a8d-5cfb71f46f53/groups -r demorealm</pre><h4 id="adding_a_user_to_a_group">Adding a user to a group</h4><p>
				Use the <code class="literal command">update</code> command with an endpoint URI composed from user’s ID and a group’s ID, such as <code class="literal filename">users/USER_ID/groups/GROUP_ID</code>, to add a user to a group.
			</p><p>
				For example:
			</p><pre class="screen">$ kcadm.sh update users/b544f379-5fc4-49e5-8a8d-5cfb71f46f53/groups/ce01117a-7426-4670-a29a-5c118056fe20 -r demorealm -s realm=demorealm -s userId=b544f379-5fc4-49e5-8a8d-5cfb71f46f53 -s groupId=ce01117a-7426-4670-a29a-5c118056fe20 -n</pre><h4 id="removing_a_user_from_a_group">Removing a user from a group</h4><p>
				Use the <code class="literal command">delete</code> command on the same endpoint URI as used for adding a user to a group, such as <code class="literal filename">users/USER_ID/groups/GROUP_ID</code>, to remove a user from a group.
			</p><p>
				For example:
			</p><pre class="screen">$ kcadm.sh delete users/b544f379-5fc4-49e5-8a8d-5cfb71f46f53/groups/ce01117a-7426-4670-a29a-5c118056fe20 -r demorealm</pre><h4 id="listing_assigned_available_and_effective_realm_roles_for_a_group">Listing assigned, available, and effective realm roles for a group</h4><p>
				Use a dedicated <code class="literal command">get-roles</code> command to list assigned, available, and effective realm roles for a group.
			</p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p class="simpara">
						Specify the target group by name (via the <code class="literal command">--gname</code> option), path (via the [command] <code class="literal">--gpath</code> option), or ID (via the <code class="literal command">--gid</code> option) to list <span class="strong strong"><strong>assigned</strong></span> realm roles for the group.
					</p><p class="simpara">
						For example:
					</p><pre class="screen">$ kcadm.sh get-roles -r demorealm --gname Group</pre></li><li class="listitem"><p class="simpara">
						Use the additional <code class="literal command">--effective</code> option to list <span class="strong strong"><strong>effective</strong></span> realm roles.
					</p><p class="simpara">
						For example:
					</p><pre class="screen">$ kcadm.sh get-roles -r demorealm --gname Group --effective</pre></li><li class="listitem"><p class="simpara">
						Use the <code class="literal command">--available</code> option to list realm roles that can still be added to the group.
					</p><p class="simpara">
						For example:
					</p><pre class="screen">$ kcadm.sh get-roles -r demorealm --gname Group --available</pre></li></ol></div><h4 id="listing_assigned_available_and_effective_client_roles_for_a_group">Listing assigned, available, and effective client roles for a group</h4><p>
				Use a dedicated <code class="literal command">get-roles</code> command to list assigned, available, and effective client roles for a group.
			</p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p class="simpara">
						Specify the target group by either name (via the <code class="literal command">--gname</code> option) or ID (via the <code class="literal command">--gid</code> option), and client by either the clientId attribute (via the [command] <code class="literal">--cclientid</code> option) or ID (via the <code class="literal command">--id</code> option) to list <span class="strong strong"><strong>assigned</strong></span> client roles for the user.
					</p><p class="simpara">
						For example:
					</p><pre class="screen">$ kcadm.sh get-roles -r demorealm --gname Group --cclientid realm-management</pre></li><li class="listitem"><p class="simpara">
						Use the additional <code class="literal command">--effective</code> option to list <span class="strong strong"><strong>effective</strong></span> realm roles.
					</p><p class="simpara">
						For example:
					</p><pre class="screen">$ kcadm.sh get-roles -r demorealm --gname Group --cclientid realm-management --effective</pre></li><li class="listitem"><p class="simpara">
						Use the <code class="literal command">--available</code> option to list realm roles that can still be added to the group.
					</p><p class="simpara">
						For example:
					</p><pre class="screen">$ kcadm.sh get-roles -r demorealm --gname Group --cclientid realm-management --available</pre></li></ol></div></section><section class="section" id="identity_provider_operations"><div class="titlepage"><div><div><h2 class="title">20.11. Identity provider operations</h2></div></div></div><h4 id="listing_available_identity_providers">Listing available identity providers</h4><p>
				Use the <code class="literal filename">serverinfo</code> endpoint to list available identity providers.
			</p><p>
				For example:
			</p><pre class="screen">$ kcadm.sh get serverinfo -r demorealm --fields 'identityProviders(*)'</pre><div class="admonition note"><div class="admonition_header">Note</div><div><p>
					The <code class="literal filename">serverinfo</code> endpoint is handled similarly to the <code class="literal filename">realms</code> endpoint in that it is not resolved relative to a target realm because it exists outside any specific realm.
				</p></div></div><h4 id="listing_configured_identity_providers">Listing configured identity providers</h4><p>
				Use the <code class="literal filename">identity-provider/instances</code> endpoint.
			</p><p>
				For example:
			</p><pre class="screen">$ kcadm.sh get identity-provider/instances -r demorealm --fields alias,providerId,enabled</pre><h4 id="getting_a_specific_configured_identity_provider">Getting a specific configured identity provider</h4><p>
				Use the <code class="literal command">alias</code> attribute of the identity provider to construct an endpoint URI, such as <code class="literal filename">identity-provider/instances/ALIAS</code>, to get a specific identity provider.
			</p><p>
				For example:
			</p><pre class="screen">$ kcadm.sh get identity-provider/instances/facebook -r demorealm</pre><h4 id="removing_a_specific_configured_identity_provider">Removing a specific configured identity provider</h4><p>
				Use the <code class="literal command">delete</code> command with the same endpoint URI that you used to get a specific configured identity provider to remove a specific configured identity provider.
			</p><p>
				For example:
			</p><pre class="screen">$ kcadm.sh delete identity-provider/instances/facebook -r demorealm</pre><h4 id="configuring_a_keycloak_openid_connect_identity_provider">Configuring a Keycloak OpenID Connect identity provider</h4><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem">
						Use <code class="literal command">keycloak-oidc</code> as the <code class="literal command">providerId</code> when creating a new identity provider instance.
					</li><li class="listitem"><p class="simpara">
						Provide the <code class="literal command">config</code> attributes: <code class="literal command">authorizationUrl</code>, <code class="literal command">tokenUrl</code>, <code class="literal command">clientId</code>, and <code class="literal command">clientSecret</code>.
					</p><p class="simpara">
						For example:
					</p><pre class="screen">$ kcadm.sh create identity-provider/instances -r demorealm -s alias=keycloak-oidc -s providerId=keycloak-oidc -s enabled=true -s 'config.useJwksUrl="true"' -s config.authorizationUrl=http://localhost:8180/auth/realms/demorealm/protocol/openid-connect/auth -s config.tokenUrl=http://localhost:8180/auth/realms/demorealm/protocol/openid-connect/token -s config.clientId=demo-oidc-provider -s config.clientSecret=secret</pre></li></ol></div><h4 id="configuring_an_openid_connect_identity_provider">Configuring an OpenID Connect identity provider</h4><p>
				Configure the generic OpenID Connect provider the same way you configure the Keycloak OpenID Connect provider, except that you set the <code class="literal command">providerId</code> attribute value to <code class="literal command">oidc</code>.
			</p><h4 id="configuring_a_saml_2_identity_provider">Configuring a SAML 2 identity provider</h4><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem">
						Use <code class="literal command">saml</code> as the <code class="literal command">providerId</code>.
					</li><li class="listitem">
						Provide the <code class="literal command">config</code> attributes: <code class="literal command">singleSignOnServiceUrl</code>, <code class="literal command">nameIDPolicyFormat</code>, and <code class="literal command">signatureAlgorithm</code>.
					</li></ol></div><p>
				For example:
			</p><pre class="screen">$ kcadm.sh create identity-provider/instances -r demorealm -s alias=saml -s providerId=saml -s enabled=true -s 'config.useJwksUrl="true"' -s config.singleSignOnServiceUrl=http://localhost:8180/auth/realms/saml-broker-realm/protocol/saml -s config.nameIDPolicyFormat=urn:oasis:names:tc:SAML:2.0:nameid-format:persistent -s config.signatureAlgorithm=RSA_SHA256</pre><h4 id="configuring_a_facebook_identity_provider">Configuring a Facebook identity provider</h4><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem">
						Use <code class="literal command">facebook</code> as the <code class="literal command">providerId</code>.
					</li><li class="listitem"><p class="simpara">
						Provide the <code class="literal command">config</code> attributes: <code class="literal command">clientId</code> and <code class="literal command">clientSecret</code>. You can find these attributes in the Facebook Developers application configuration page for your application.
					</p><p class="simpara">
						For example:
					</p><pre class="screen">$ kcadm.sh create identity-provider/instances -r demorealm -s alias=facebook -s providerId=facebook -s enabled=true  -s 'config.useJwksUrl="true"' -s config.clientId=FACEBOOK_CLIENT_ID -s config.clientSecret=FACEBOOK_CLIENT_SECRET</pre></li></ol></div><h4 id="configuring_a_google_identity_provider">Configuring a Google identity provider</h4><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem">
						Use <code class="literal command">google</code> as the <code class="literal command">providerId</code>.
					</li><li class="listitem"><p class="simpara">
						Provide the <code class="literal command">config</code> attributes: <code class="literal command">clientId</code> and <code class="literal command">clientSecret</code>. You can find these attributes in the Google Developers application configuration page for your application.
					</p><p class="simpara">
						For example:
					</p><pre class="screen">$ kcadm.sh create identity-provider/instances -r demorealm -s alias=google -s providerId=google -s enabled=true  -s 'config.useJwksUrl="true"' -s config.clientId=GOOGLE_CLIENT_ID -s config.clientSecret=GOOGLE_CLIENT_SECRET</pre></li></ol></div><h4 id="configuring_a_twitter_identity_provider">Configuring a Twitter identity provider</h4><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem">
						Use <code class="literal command">twitter</code> as the <code class="literal command">providerId</code>.
					</li><li class="listitem"><p class="simpara">
						Provide the <code class="literal command">config</code> attributes <code class="literal command">clientId</code> and <code class="literal command">clientSecret</code>. You can find these attributes in the Twitter Application Management application configuration page for your application.
					</p><p class="simpara">
						For example:
					</p><pre class="screen">$ kcadm.sh create identity-provider/instances -r demorealm -s alias=google -s providerId=google -s enabled=true  -s 'config.useJwksUrl="true"' -s config.clientId=TWITTER_API_KEY -s config.clientSecret=TWITTER_API_SECRET</pre></li></ol></div><h4 id="configuring_a_github_identity_provider">Configuring a GitHub identity provider</h4><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem">
						Use <code class="literal command">github</code> as the <code class="literal command">providerId</code>.
					</li><li class="listitem"><p class="simpara">
						Provide the <code class="literal command">config</code> attributes <code class="literal command">clientId</code> and <code class="literal command">clientSecret</code>. You can find these attributes in the GitHub Developer Application Settings page for your application.
					</p><p class="simpara">
						For example:
					</p><pre class="screen">$ kcadm.sh create identity-provider/instances -r demorealm -s alias=github -s providerId=github -s enabled=true  -s 'config.useJwksUrl="true"' -s config.clientId=GITHUB_CLIENT_ID -s config.clientSecret=GITHUB_CLIENT_SECRET</pre></li></ol></div><h4 id="configuring_a_linkedin_identity_provider">Configuring a LinkedIn identity provider</h4><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem">
						Use <code class="literal command">linkedin</code> as the <code class="literal command">providerId</code>.
					</li><li class="listitem"><p class="simpara">
						Provide the <code class="literal command">config</code> attributes <code class="literal command">clientId</code> and <code class="literal command">clientSecret</code>. You can find these attributes in the LinkedIn Developer Console application page for your application.
					</p><p class="simpara">
						For example:
					</p><pre class="screen">$ kcadm.sh create identity-provider/instances -r demorealm -s alias=linkedin -s providerId=linkedin -s enabled=true  -s 'config.useJwksUrl="true"' -s config.clientId=LINKEDIN_CLIENT_ID -s config.clientSecret=LINKEDIN_CLIENT_SECRET</pre></li></ol></div><h4 id="configuring_a_microsoft_live_identity_provider">Configuring a Microsoft Live identity provider</h4><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem">
						Use <code class="literal command">microsoft</code> as the <code class="literal command">providerId</code>.
					</li><li class="listitem"><p class="simpara">
						Provide the <code class="literal command">config</code> attributes <code class="literal">clientId</code> and <code class="literal">clientSecret</code>. You can find these attributes in the Microsoft Application Registration Portal page for your application.
					</p><p class="simpara">
						For example:
					</p><pre class="screen">$ kcadm.sh create identity-provider/instances -r demorealm -s alias=microsoft -s providerId=microsoft -s enabled=true  -s 'config.useJwksUrl="true"' -s config.clientId=MICROSOFT_APP_ID -s config.clientSecret=MICROSOFT_PASSWORD</pre></li></ol></div><h4 id="configuring_a_stack_overflow_identity_provider">Configuring a Stack Overflow identity provider</h4><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem">
						Use <code class="literal">stackoverflow</code> command as the <code class="literal command">providerId</code>.
					</li><li class="listitem"><p class="simpara">
						Provide the <code class="literal command">config</code> attributes <code class="literal command">clientId</code>, <code class="literal command">clientSecret</code>, and <code class="literal command">key</code>. You can find these attributes in the Stack Apps OAuth page for your application.
					</p><p class="simpara">
						For example:
					</p><pre class="screen">$ kcadm.sh create identity-provider/instances -r demorealm -s alias=stackoverflow -s providerId=stackoverflow -s enabled=true  -s 'config.useJwksUrl="true"' -s config.clientId=STACKAPPS_CLIENT_ID -s config.clientSecret=STACKAPPS_CLIENT_SECRET -s config.key=STACKAPPS_KEY</pre></li></ol></div></section><section class="section" id="storage_provider_operations"><div class="titlepage"><div><div><h2 class="title">20.12. Storage provider operations</h2></div></div></div><h4 id="configuring_a_kerberos_storage_provider">Configuring a Kerberos storage provider</h4><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem">
						Use the <code class="literal command">create</code> command against the <code class="literal filename">components</code> endpoint.
					</li><li class="listitem">
						Specify realm id as a value of the <code class="literal command">parentId</code> attribute.
					</li><li class="listitem">
						Specify <code class="literal command">kerberos</code> as the value of the <code class="literal command">providerId</code> attribute, and <code class="literal command">org.keycloak.storage.UserStorageProvider</code> as the value of the <code class="literal command">providerType</code> attribute.
					</li><li class="listitem"><p class="simpara">
						For example:
					</p><pre class="screen">$ kcadm.sh create components -r demorealm -s parentId=demorealmId -s id=demokerberos -s name=demokerberos -s providerId=kerberos -s providerType=org.keycloak.storage.UserStorageProvider -s 'config.priority=["0"]' -s 'config.debug=["false"]' -s 'config.allowPasswordAuthentication=["true"]' -s 'config.editMode=["UNSYNCED"]' -s 'config.updateProfileFirstLogin=["true"]' -s 'config.allowKerberosAuthentication=["true"]' -s 'config.kerberosRealm=["KEYCLOAK.ORG"]' -s 'config.keyTab=["http.keytab"]' -s 'config.serverPrincipal=["HTTP/localhost@KEYCLOAK.ORG"]' -s 'config.cachePolicy=["DEFAULT"]'</pre></li></ol></div><h4 id="configuring_an_ldap_user_storage_provider">Configuring an LDAP user storage provider</h4><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem">
						Use the <code class="literal command">create</code> command against the <code class="literal filename">components</code> endpoint.
					</li><li class="listitem">
						Specify <code class="literal command">ldap</code> as a value of the <code class="literal command">providerId</code> attribute, and <code class="literal command">org.keycloak.storage.UserStorageProvider</code> as the value of the <code class="literal command">providerType</code> attribute.
					</li><li class="listitem">
						Provide the realm ID as the value of the <code class="literal command">parentId</code> attribute.
					</li><li class="listitem"><p class="simpara">
						Use the following example to create a Kerberos-integrated LDAP provider.
					</p><pre class="screen">$ kcadm.sh create components -r demorealm -s name=kerberos-ldap-provider -s providerId=ldap -s providerType=org.keycloak.storage.UserStorageProvider -s parentId=3d9c572b-8f33-483f-98a6-8bb421667867  -s 'config.priority=["1"]' -s 'config.fullSyncPeriod=["-1"]' -s 'config.changedSyncPeriod=["-1"]' -s 'config.cachePolicy=["DEFAULT"]' -s config.evictionDay=[] -s config.evictionHour=[] -s config.evictionMinute=[] -s config.maxLifespan=[] -s 'config.batchSizeForSync=["1000"]' -s 'config.editMode=["WRITABLE"]' -s 'config.syncRegistrations=["false"]' -s 'config.vendor=["other"]' -s 'config.usernameLDAPAttribute=["uid"]' -s 'config.rdnLDAPAttribute=["uid"]' -s 'config.uuidLDAPAttribute=["entryUUID"]' -s 'config.userObjectClasses=["inetOrgPerson, organizationalPerson"]' -s 'config.connectionUrl=["ldap://localhost:10389"]'  -s 'config.usersDn=["ou=People,dc=keycloak,dc=org"]' -s 'config.authType=["simple"]' -s 'config.bindDn=["uid=admin,ou=system"]' -s 'config.bindCredential=["secret"]' -s 'config.searchScope=["1"]' -s 'config.useTruststoreSpi=["ldapsOnly"]' -s 'config.connectionPooling=["true"]' -s 'config.pagination=["true"]' -s 'config.allowKerberosAuthentication=["true"]' -s 'config.serverPrincipal=["HTTP/localhost@KEYCLOAK.ORG"]' -s 'config.keyTab=["http.keytab"]' -s 'config.kerberosRealm=["KEYCLOAK.ORG"]' -s 'config.debug=["true"]' -s 'config.useKerberosForPasswordAuthentication=["true"]'</pre></li></ol></div><h4 id="removing_a_user_storage_provider_instance">Removing a user storage provider instance</h4><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem">
						Use the storage provider instance’s <code class="literal command">id</code> attribute to compose an endpoint URI, such as <code class="literal filename">components/ID</code>.
					</li><li class="listitem"><p class="simpara">
						Run the <code class="literal command">delete</code> command against this endpoint.
					</p><p class="simpara">
						For example:
					</p><pre class="screen">$ kcadm.sh delete components/3d9c572b-8f33-483f-98a6-8bb421667867 -r demorealm</pre></li></ol></div><h4 id="triggering_synchronization_of_all_users_for_a_specific_user_storage_provider">Triggering synchronization of all users for a specific user storage provider</h4><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem">
						Use the storage provider’s <code class="literal command">id</code> attribute to compose an endpoint URI, such as <code class="literal filename">user-storage/ID_OF_USER_STORAGE_INSTANCE/sync</code>.
					</li><li class="listitem"><p class="simpara">
						Add the <code class="literal command">action=triggerFullSync</code> query parameter and run the <code class="literal command">create</code> command.
					</p><p class="simpara">
						For example:
					</p><pre class="screen">$ kcadm.sh create user-storage/b7c63d02-b62a-4fc1-977c-947d6a09e1ea/sync?action=triggerFullSync</pre></li></ol></div><h4 id="triggering_synchronization_of_changed_users_for_a_specific_user_storage_provider">Triggering synchronization of changed users for a specific user storage provider</h4><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem">
						Use the storage provider’s <code class="literal command">id</code> attribute to compose an endpoint URI, such as <code class="literal filename">user-storage/ID_OF_USER_STORAGE_INSTANCE/sync</code>.
					</li><li class="listitem"><p class="simpara">
						Add the <code class="literal command">action=triggerChangedUsersSync</code> query parameter and run the <code class="literal command">create</code> command.
					</p><p class="simpara">
						For example:
					</p><pre class="screen">$ kcadm.sh create user-storage/b7c63d02-b62a-4fc1-977c-947d6a09e1ea/sync?action=triggerChangedUsersSync</pre></li></ol></div><h4 id="test_ldap_user_storage_connectivity">Test LDAP user storage connectivity</h4><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem">
						Run the <code class="literal command">get</code> command on the <code class="literal filename">testLDAPConnection</code> endpoint.
					</li><li class="listitem"><p class="simpara">
						Provide query parameters <code class="literal command">bindCredential</code>, <code class="literal command">bindDn</code>, <code class="literal command">connectionUrl</code>, and <code class="literal command">useTruststoreSpi</code>, and then set the <code class="literal command">action</code> query parameter to <code class="literal command">testConnection</code>.
					</p><p class="simpara">
						For example:
					</p><pre class="screen">$ kcadm.sh create testLDAPConnection -s action=testConnection -s bindCredential=secret -s bindDn=uid=admin,ou=system -s connectionUrl=ldap://localhost:10389 -s useTruststoreSpi=ldapsOnly</pre></li></ol></div><h4 id="test_ldap_user_storage_authentication">Test LDAP user storage authentication</h4><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem">
						Run the <code class="literal command">get</code> command on the <code class="literal filename">testLDAPConnection</code> endpoint.
					</li><li class="listitem"><p class="simpara">
						Provide the query parameters <code class="literal command">bindCredential</code>, <code class="literal command">bindDn</code>, <code class="literal command">connectionUrl</code>, and <code class="literal command">useTruststoreSpi</code>, and then set the <code class="literal command">action</code> query parameter to <code class="literal command">testAuthentication</code>.
					</p><p class="simpara">
						For example:
					</p><pre class="screen">$ kcadm.sh create testLDAPConnection -s action=testAuthentication -s bindCredential=secret -s bindDn=uid=admin,ou=system -s connectionUrl=ldap://localhost:10389 -s useTruststoreSpi=ldapsOnly</pre></li></ol></div></section><section class="section" id="adding_mappers"><div class="titlepage"><div><div><h2 class="title">20.13. Adding mappers</h2></div></div></div><h4 id="adding_a_hardcoded_role_ldap_mapper">Adding a hardcoded role LDAP mapper</h4><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem">
						Run the <code class="literal command">create</code> command on the <code class="literal filename">components</code> endpoint.
					</li><li class="listitem">
						Set the <code class="literal command">providerType</code> attribute to <code class="literal filename">org.keycloak.storage.ldap.mappers.LDAPStorageMapper</code>.
					</li><li class="listitem">
						Set the <code class="literal command">parentId</code> attribute to the ID of the LDAP provider instance.
					</li><li class="listitem"><p class="simpara">
						Set the <code class="literal command">providerId</code> attribute to <code class="literal command">hardcoded-ldap-role-mapper</code>. Make sure to provide a value of <code class="literal command">role</code> configuration parameter.
					</p><p class="simpara">
						For example:
					</p><pre class="screen">$ kcadm.sh create components -r demorealm -s name=hardcoded-ldap-role-mapper -s providerId=hardcoded-ldap-role-mapper -s providerType=org.keycloak.storage.ldap.mappers.LDAPStorageMapper -s parentId=b7c63d02-b62a-4fc1-977c-947d6a09e1ea -s 'config.role=["realm-management.create-client"]'</pre></li></ol></div><h4 id="adding_an_ms_active_directory_mapper">Adding an MS Active Directory mapper</h4><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem">
						Run the <code class="literal command">create</code> command on the <code class="literal filename">components</code> endpoint.
					</li><li class="listitem">
						Set the <code class="literal command">providerType</code> attribute to <code class="literal filename">org.keycloak.storage.ldap.mappers.LDAPStorageMapper</code>.
					</li><li class="listitem">
						Set the <code class="literal command">parentId</code> attribute to the ID of the LDAP provider instance.
					</li><li class="listitem"><p class="simpara">
						Set the <code class="literal command">providerId</code> attribute to <code class="literal filename">msad-user-account-control-mapper</code>.
					</p><p class="simpara">
						For example:
					</p><pre class="screen">$ kcadm.sh create components -r demorealm -s name=msad-user-account-control-mapper -s providerId=msad-user-account-control-mapper -s providerType=org.keycloak.storage.ldap.mappers.LDAPStorageMapper -s parentId=b7c63d02-b62a-4fc1-977c-947d6a09e1ea</pre></li></ol></div><h4 id="adding_a_user_attribute_ldap_mapper">Adding a user attribute LDAP mapper</h4><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem">
						Run the <code class="literal command">create</code> command on the <code class="literal filename">components</code> endpoint.
					</li><li class="listitem">
						Set the <code class="literal command">providerType</code> attribute to <code class="literal filename">org.keycloak.storage.ldap.mappers.LDAPStorageMapper</code>.
					</li><li class="listitem">
						Set the <code class="literal command">parentId</code> attribute to the ID of the LDAP provider instance.
					</li><li class="listitem"><p class="simpara">
						Set the <code class="literal command">providerId</code> attribute to <code class="literal filename">user-attribute-ldap-mapper</code>.
					</p><p class="simpara">
						For example:
					</p><pre class="screen">$ kcadm.sh create components -r demorealm -s name=user-attribute-ldap-mapper -s providerId=user-attribute-ldap-mapper -s providerType=org.keycloak.storage.ldap.mappers.LDAPStorageMapper -s parentId=b7c63d02-b62a-4fc1-977c-947d6a09e1ea -s 'config."user.model.attribute"=["email"]' -s 'config."ldap.attribute"=["mail"]' -s 'config."read.only"=["false"]' -s 'config."always.read.value.from.ldap"=["false"]' -s 'config."is.mandatory.in.ldap"=["false"]'</pre></li></ol></div><h4 id="adding_a_group_ldap_mapper">Adding a group LDAP mapper</h4><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem">
						Run the <code class="literal command">create</code> command on the <code class="literal filename">components</code> endpoint.
					</li><li class="listitem">
						Set the <code class="literal command">providerType</code> attribute to <code class="literal filename">org.keycloak.storage.ldap.mappers.LDAPStorageMapper</code>.
					</li><li class="listitem">
						Set the <code class="literal command">parentId</code> attribute to the ID of the LDAP provider instance.
					</li><li class="listitem"><p class="simpara">
						Set the <code class="literal command">providerId</code> attribute to <code class="literal filename">group-ldap-mapper</code>.
					</p><p class="simpara">
						For example:
					</p><pre class="screen">$ kcadm.sh create components -r demorealm -s name=group-ldap-mapper -s providerId=group-ldap-mapper -s providerType=org.keycloak.storage.ldap.mappers.LDAPStorageMapper -s parentId=b7c63d02-b62a-4fc1-977c-947d6a09e1ea -s 'config."groups.dn"=[]' -s 'config."group.name.ldap.attribute"=["cn"]' -s 'config."group.object.classes"=["groupOfNames"]' -s 'config."preserve.group.inheritance"=["true"]' -s 'config."membership.ldap.attribute"=["member"]' -s 'config."membership.attribute.type"=["DN"]' -s 'config."groups.ldap.filter"=[]' -s 'config.mode=["LDAP_ONLY"]' -s 'config."user.roles.retrieve.strategy"=["LOAD_GROUPS_BY_MEMBER_ATTRIBUTE"]' -s 'config."mapped.group.attributes"=["admins-group"]' -s 'config."drop.non.existing.groups.during.sync"=["false"]' -s 'config.roles=["admins"]' -s 'config.groups=["admins-group"]' -s 'config.group=[]' -s 'config.preserve=["true"]' -s 'config.membership=["member"]'</pre></li></ol></div><h4 id="adding_a_full_name_ldap_mapper">Adding a full name LDAP mapper</h4><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem">
						Run the <code class="literal command">create</code> command on the <code class="literal filename">components</code> endpoint.
					</li><li class="listitem">
						Set the <code class="literal command">providerType</code> attribute to <code class="literal filename">org.keycloak.storage.ldap.mappers.LDAPStorageMapper</code>.
					</li><li class="listitem">
						Set the <code class="literal command">parentId</code> attribute to the ID of the LDAP provider instance.
					</li><li class="listitem"><p class="simpara">
						Set the <code class="literal command">providerId</code> attribute to <code class="literal filename">full-name-ldap-mapper</code>.
					</p><p class="simpara">
						For example:
					</p><pre class="screen">$ kcadm.sh create components -r demorealm -s name=full-name-ldap-mapper -s providerId=full-name-ldap-mapper -s providerType=org.keycloak.storage.ldap.mappers.LDAPStorageMapper -s parentId=b7c63d02-b62a-4fc1-977c-947d6a09e1ea -s 'config."ldap.full.name.attribute"=["cn"]' -s 'config."read.only"=["false"]' -s 'config."write.only"=["true"]'</pre></li></ol></div></section><section class="section" id="authentication_operations"><div class="titlepage"><div><div><h2 class="title">20.14. Authentication operations</h2></div></div></div><h4 id="setting_a_password_policy">Setting a password policy</h4><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem">
						Set the realm’s <code class="literal command">passwordPolicy</code> attribute to an enumeration expression that includes the specific policy provider ID and optional configuration.
					</li><li class="listitem"><p class="simpara">
						Use the following example to set a password policy to default values. The default values include:
					</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">
								27,500 hashing iterations
							</li><li class="listitem">
								at least one special character
							</li><li class="listitem">
								at least one uppercase character
							</li><li class="listitem">
								at least one digit character
							</li><li class="listitem">
								not be equal to a user’s <code class="literal filename">username</code>
							</li><li class="listitem"><p class="simpara">
								be at least eight characters long
							</p><pre class="screen">$ kcadm.sh update realms/demorealm -s 'passwordPolicy="hashIterations and specialChars and upperCase and digits and notUsername and length"'</pre></li></ul></div></li><li class="listitem">
						If you want to use values different from defaults, pass the configuration in brackets.
					</li><li class="listitem"><p class="simpara">
						Use the following example to set a password policy to:
					</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">
								25,000 hash iterations
							</li><li class="listitem">
								at least two special characters
							</li><li class="listitem">
								at least two uppercase characters
							</li><li class="listitem">
								at least two lowercase characters
							</li><li class="listitem">
								at least two digits
							</li><li class="listitem">
								be at least nine characters long
							</li><li class="listitem">
								not be equal to a user’s <code class="literal filename">username</code>
							</li><li class="listitem"><p class="simpara">
								not repeat for at least four changes back
							</p><pre class="screen">$ kcadm.sh update realms/demorealm -s 'passwordPolicy="hashIterations(25000) and specialChars(2) and upperCase(2) and lowerCase(2) and digits(2) and length(9) and notUsername and passwordHistory(4)"'</pre></li></ul></div></li></ol></div><h4 id="getting_the_current_password_policy">Getting the current password policy</h4><p>
				Get the current realm configuration and filter everything but the <code class="literal command">passwordPolicy</code> attribute.
			</p><p>
				Use the following example to display <code class="literal command">passwordPolicy</code> for <code class="literal filename">demorealm</code>.
			</p><pre class="screen">$ kcadm.sh get realms/demorealm --fields passwordPolicy</pre><h4 id="listing_authentication_flows">Listing authentication flows</h4><p>
				Run the <code class="literal command">get</code> command on the <code class="literal filename">authentication/flows</code> endpoint.
			</p><p>
				For example:
			</p><pre class="screen">$ kcadm.sh get authentication/flows -r demorealm</pre><h4 id="getting_a_specific_authentication_flow">Getting a specific authentication flow</h4><p>
				Run the <code class="literal command">get</code> command on the <code class="literal filename">authentication/flows/FLOW_ID</code> endpoint.
			</p><p>
				For example:
			</p><pre class="screen">$ kcadm.sh get authentication/flows/febfd772-e1a1-42fb-b8ae-00c0566fafb8 -r demorealm</pre><h4 id="listing_executions_for_a_flow">Listing executions for a flow</h4><p>
				Run the <code class="literal command">get</code> command on the <code class="literal filename">authentication/flows/FLOW_ALIAS/executions</code> endpoint.
			</p><p>
				For example:
			</p><pre class="screen">$ kcadm.sh get authentication/flows/Copy%20of%20browser/executions -r demorealm</pre><h4 id="adding_configuration_to_an_execution">Adding configuration to an execution</h4><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem">
						Get execution for a flow, and take note of its ID
					</li><li class="listitem">
						Run the <code class="literal command">create</code> command on the <code class="literal filename">authentication/executions/{executionId}/config</code> endpoint.
					</li></ol></div><p>
				For example:
			</p><pre class="screen">$ kcadm create "authentication/executions/a3147129-c402-4760-86d9-3f2345e401c7/config" -r examplerealm -b '{"config":{"x509-cert-auth.mapping-source-selection":"Match SubjectDN using regular expression","x509-cert-auth.regular-expression":"(.*?)(?:$)","x509-cert-auth.mapper-selection":"Custom Attribute Mapper","x509-cert-auth.mapper-selection.user-attribute-name":"usercertificate","x509-cert-auth.crl-checking-enabled":"","x509-cert-auth.crldp-checking-enabled":false,"x509-cert-auth.crl-relative-path":"crl.pem","x509-cert-auth.ocsp-checking-enabled":"","x509-cert-auth.ocsp-responder-uri":"","x509-cert-auth.keyusage":"","x509-cert-auth.extendedkeyusage":"","x509-cert-auth.confirmation-page-disallowed":""},"alias":"my_otp_config"}'</pre><h4 id="getting_configuration_for_an_execution">Getting configuration for an execution</h4><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem">
						Get execution for a flow, and get its <code class="literal filename">authenticationConfig</code> attribute, containing the config ID.
					</li><li class="listitem">
						Run the <code class="literal command">get</code> command on the <code class="literal filename">authentication/config/ID</code> endpoint.
					</li></ol></div><p>
				For example:
			</p><pre class="screen">$ kcadm get "authentication/config/dd91611a-d25c-421a-87e2-227c18421833" -r examplerealm</pre><h4 id="updating_configuration_for_an_execution">Updating configuration for an execution</h4><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem">
						Get execution for a flow, and get its <code class="literal filename">authenticationConfig</code> attribute, containing the config ID.
					</li><li class="listitem">
						Run the <code class="literal command">update</code> command on the <code class="literal filename">authentication/config/ID</code> endpoint.
					</li></ol></div><p>
				For example:
			</p><pre class="screen">$ kcadm update "authentication/config/dd91611a-d25c-421a-87e2-227c18421833" -r examplerealm -b '{"id":"dd91611a-d25c-421a-87e2-227c18421833","alias":"my_otp_config","config":{"x509-cert-auth.extendedkeyusage":"","x509-cert-auth.mapper-selection.user-attribute-name":"usercertificate","x509-cert-auth.ocsp-responder-uri":"","x509-cert-auth.regular-expression":"(.*?)(?:$)","x509-cert-auth.crl-checking-enabled":"true","x509-cert-auth.confirmation-page-disallowed":"","x509-cert-auth.keyusage":"","x509-cert-auth.mapper-selection":"Custom Attribute Mapper","x509-cert-auth.crl-relative-path":"crl.pem","x509-cert-auth.crldp-checking-enabled":"false","x509-cert-auth.mapping-source-selection":"Match SubjectDN using regular expression","x509-cert-auth.ocsp-checking-enabled":""}}'</pre><h4 id="deleting_configuration_for_an_execution">Deleting configuration for an execution</h4><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem">
						Get execution for a flow, and get its <code class="literal filename">authenticationConfig</code> attribute, containing the config ID.
					</li><li class="listitem">
						Run the <code class="literal command">delete</code> command on the <code class="literal filename">authentication/config/ID</code> endpoint.
					</li></ol></div><p>
				For example:
			</p><pre class="screen">$ kcadm delete "authentication/config/dd91611a-d25c-421a-87e2-227c18421833" -r examplerealm</pre></section></section><div><div xml:lang="en-US" class="legalnotice" id="idm140464637189680"><h1 class="legalnotice">Legal Notice</h1><div class="para">
				Copyright <span class="trademark"/>© 2019 Red Hat, Inc.
			</div><div class="para">
				Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with the License. You may obtain a copy of the License at
			</div><div class="para">
				<a class="ulink" href="http://www.apache.org/licenses/LICENSE-2.0"> http://www.apache.org/licenses/LICENSE-2.0</a>
			</div><div class="para">
				Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.
			</div></div></div></div></div></div><script type="text/javascript">
                        jQuery(document).ready(function() {
                            initSwitchery();
                            jQuery('pre[class*="language-"]').each(function(i, block){hljs.highlightBlock(block);});
                        });
                    </script></body></html>