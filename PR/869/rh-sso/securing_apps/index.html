<?xml version='1.0' encoding='UTF-8'?>
<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" class="chrometwo"><head><title>Securing Applications and Services Guide</title><link rel="stylesheet" type="text/css" href="Common_Content/css/default.css"/><meta name="generator" content="publican v4.3.4"/><meta name="description" content="This guide consists of information for securing applications and services using Red Hat Single Sign-On 7.4"/><link rel="next" href="#overview" title="Chapter 1. Overview"/><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/><script type="text/javascript" src="Common_Content/scripts/jquery-1.7.1.min.js"> </script><script type="text/javascript" src="Common_Content/scripts/utils.js"> </script><script type="text/javascript" src="Common_Content/scripts/highlight.js/highlight.pack.js"> </script></head><body><div id="chrometwo"><div id="main"><div xml:lang="en-US" class="book" id="idm140066878092864"><div class="titlepage"><div><div class="producttitle"><span class="productname">Red Hat Single Sign-On</span> <span class="productnumber">7.4</span></div><div><h1 class="title">Securing Applications and Services Guide</h1></div><div><h2 class="subtitle">For Use with Red Hat Single Sign-On 7.4</h2></div><div><div xml:lang="en-US" class="authorgroup"><span class="orgname">Red Hat Customer Content Services</span></div></div><div><a href="#idm140066873301568">Legal Notice</a></div><div><div class="abstract"><p class="title"><strong>Abstract</strong></p><div class="para">
				This guide consists of information for securing applications and services using Red Hat Single Sign-On 7.4
			</div></div></div></div><hr/></div><div class="toc"><ul class="toc"><li><span class="chapter"><a href="#overview">1. Overview</a></span><ul><li><span class="section"><a href="#what_are_client_adapters">1.1. What are Client Adapters?</a></span></li><li><span class="section"><a href="#supported_platforms">1.2. Supported Platforms</a></span><ul><li><span class="section"><a href="#openid_connect">1.2.1. OpenID Connect</a></span></li><li><span class="section"><a href="#saml">1.2.2. SAML</a></span></li></ul></li><li><span class="section"><a href="#supported_protocols">1.3. Supported Protocols</a></span><ul><li><span class="section"><a href="#openid_connect_2">1.3.1. OpenID Connect</a></span></li><li><span class="section"><a href="#saml_2_0">1.3.2. SAML 2.0</a></span></li><li><span class="section"><a href="#openid_connect_vs_saml">1.3.3. OpenID Connect vs. SAML</a></span></li></ul></li></ul></li><li><span class="chapter"><a href="#openid_connect_3">2. OpenID Connect</a></span><ul><li><span class="section"><a href="#java_adapters">2.1. Java Adapters</a></span><ul><li><span class="section"><a href="#java_adapter_config">2.1.1. Java Adapter Config</a></span></li><li><span class="section"><a href="#jboss_adapter">2.1.2. JBoss EAP Adapter</a></span></li><li><span class="section"><a href="#jboss_adapter_rpm">2.1.3. Installing JBoss EAP Adapter from an RPM</a></span></li><li><span class="section"><a href="#fuse_adapter">2.1.4. JBoss Fuse 6 Adapter</a></span></li><li><span class="section"><a href="#fuse7_adapter">2.1.5. JBoss Fuse 7 Adapter</a></span></li><li><span class="section"><a href="#spring_boot_adapter">2.1.6. Spring Boot Adapter</a></span></li><li><span class="section"><a href="#servlet_filter_adapter">2.1.7. Java Servlet Filter Adapter</a></span></li><li><span class="section"><a href="#security_context">2.1.8. Security Context</a></span></li><li><span class="section"><a href="#adapter_error_handling">2.1.9. Error Handling</a></span></li><li><span class="section"><a href="#logout">2.1.10. Logout</a></span></li><li><span class="section"><a href="#params_forwarding">2.1.11. Parameters Forwarding</a></span></li><li><span class="section"><a href="#client_authentication_adapter">2.1.12. Client Authentication</a></span></li><li><span class="section"><a href="#multi_tenancy">2.1.13. Multi Tenancy</a></span></li><li><span class="section"><a href="#applicationclustering">2.1.14. Application Clustering</a></span></li></ul></li><li><span class="section"><a href="#javascript_adapter">2.2. JavaScript Adapter</a></span><ul><li><span class="section"><a href="#session_status_iframe">2.2.1. Session Status iframe</a></span></li><li><span class="section"><a href="#javascript_implicit_flow">2.2.2. Implicit and Hybrid Flow</a></span></li><li><span class="section"><a href="#hybrid-apps-with-cordova">2.2.3. Hybrid Apps with Cordova</a></span></li><li><span class="section"><a href="#earlier_browsers">2.2.4. Earlier Browsers</a></span></li><li><span class="section"><a href="#javascript_adapter_reference">2.2.5. JavaScript Adapter Reference</a></span></li></ul></li><li><span class="section"><a href="#nodejs_adapter">2.3. Node.js Adapter</a></span><ul><li><span class="section"><a href="#installation">2.3.1. Installation</a></span></li><li><span class="section"><a href="#usage">2.3.2. Usage</a></span></li><li><span class="section"><a href="#installing_middleware">2.3.3. Installing Middleware</a></span></li><li><span class="section"><a href="#checking_authentication">2.3.4. Checking Authentication</a></span></li><li><span class="section"><a href="#protecting_resources">2.3.5. Protecting Resources</a></span></li><li><span class="section"><a href="#additional_urls">2.3.6. Additional URLs</a></span></li></ul></li><li><span class="section"><a href="#other_openid_connect_libraries">2.4. Other OpenID Connect Libraries</a></span><ul><li><span class="section"><a href="#endpoints">2.4.1. Endpoints</a></span></li><li><span class="section"><a href="#validating_access_tokens">2.4.2. Validating Access Tokens</a></span></li><li><span class="section"><a href="#flows">2.4.3. Flows</a></span></li><li><span class="section"><a href="#redirect_uris">2.4.4. Redirect URIs</a></span></li></ul></li></ul></li><li><span class="chapter"><a href="#saml_2">3. SAML</a></span><ul><li><span class="section"><a href="#java_adapters_2">3.1. Java Adapters</a></span><ul><li><span class="section"><a href="#saml-general-config">3.1.1. General Adapter Config</a></span></li><li><span class="section"><a href="#saml_jboss_adapter">3.1.2. JBoss EAP Adapter</a></span></li><li><span class="section"><a href="#jboss_adapter_rpm_saml">3.1.3. Installing JBoss EAP Adapter from an RPM</a></span></li><li><span class="section"><a href="#java_servlet_filter_adapter">3.1.4. Java Servlet Filter Adapter</a></span></li><li><span class="section"><a href="#registering_with_an_identity_provider">3.1.5. Registering with an Identity Provider</a></span></li><li><span class="section"><a href="#logout_2">3.1.6. Logout</a></span></li><li><span class="section"><a href="#obtaining_assertion_attributes">3.1.7. Obtaining Assertion Attributes</a></span></li><li><span class="section"><a href="#error_handling">3.1.8. Error Handling</a></span></li><li><span class="section"><a href="#troubleshooting">3.1.9. Troubleshooting</a></span></li><li><span class="section"><a href="#saml_multi_tenancy">3.1.10. Multi Tenancy</a></span></li></ul></li><li><span class="section"><a href="#mod_auth_mellon">3.2. mod_auth_mellon Apache HTTPD Module</a></span><ul><li><span class="section"><a href="#configuring_mod_auth_mellon_with_red_hat_single_sign_on">3.2.1. Configuring mod_auth_mellon with Red Hat Single Sign-On</a></span></li></ul></li></ul></li><li><span class="chapter"><a href="#docker_registry_configuration">4. Docker Registry Configuration</a></span><ul><li><span class="section"><a href="#docker_registry_configuration_file_installation">4.1. Docker Registry Configuration File Installation</a></span></li><li><span class="section"><a href="#docker_registry_environment_variable_override_installation">4.2. Docker Registry Environment Variable Override Installation</a></span></li><li><span class="section"><a href="#docker_compose_yaml_file">4.3. Docker Compose YAML File</a></span></li></ul></li><li><span class="chapter"><a href="#client_registration">5. Client Registration</a></span><ul><li><span class="section"><a href="#authentication">5.1. Authentication</a></span><ul><li><span class="section"><a href="#bearer_token">5.1.1. Bearer Token</a></span></li><li><span class="section"><a href="#initial_access_token">5.1.2. Initial Access Token</a></span></li><li><span class="section"><a href="#registration_access_token">5.1.3. Registration Access Token</a></span></li></ul></li><li><span class="section"><a href="#red_hat_single_sign_on_representations">5.2. Red Hat Single Sign-On Representations</a></span></li><li><span class="section"><a href="#red_hat_single_sign_on_adapter_configuration">5.3. Red Hat Single Sign-On Adapter Configuration</a></span></li><li><span class="section"><a href="#openid_connect_dynamic_client_registration">5.4. OpenID Connect Dynamic Client Registration</a></span></li><li><span class="section"><a href="#saml_entity_descriptors">5.5. SAML Entity Descriptors</a></span></li><li><span class="section"><a href="#example_using_curl_2">5.6. Example using CURL</a></span></li><li><span class="section"><a href="#example_using_java_client_registration_api">5.7. Example using Java Client Registration API</a></span></li><li><span class="section"><a href="#client_registration_policies">5.8. Client Registration Policies</a></span></li></ul></li><li><span class="chapter"><a href="#client_registration_cli">6. Client Registration CLI</a></span><ul><li><span class="section"><a href="#configuring_a_user_for_client_registration_cli">6.1. Configuring a new regular user for use with Client Registration CLI</a></span></li><li><span class="section"><a href="#configuring_a_client_for_use_with_client_registration_cli">6.2. Configuring a client for use with the Client Registration CLI</a></span></li><li><span class="section"><a href="#installing_client_registration_cli">6.3. Installing the Client Registration CLI</a></span></li><li><span class="section"><a href="#using_client_registration_cli">6.4. Using the Client Registration CLI</a></span><ul><li><span class="section"><a href="#logging_in">6.4.1. Logging in</a></span></li><li><span class="section"><a href="#working_with_alternative_configurations">6.4.2. Working with alternative configurations</a></span></li><li><span class="section"><a href="#initial_access_and_registration_access_tokens">6.4.3. Initial Access and Registration Access Tokens</a></span></li><li><span class="section"><a href="#performing_crud_operations">6.4.4. Creating a client configuration</a></span></li><li><span class="section"><a href="#retrieving_a_client_configuration">6.4.5. Retrieving a client configuration</a></span></li><li><span class="section"><a href="#modifying_a_client_configuration">6.4.6. Modifying a client configuration</a></span></li><li><span class="section"><a href="#deleting_a_client_configuration">6.4.7. Deleting a client configuration</a></span></li><li><span class="section"><a href="#refreshing_invalid_registration_access_tokens">6.4.8. Refreshing invalid Registration Access Tokens</a></span></li></ul></li><li><span class="section"><a href="#troubleshooting_2">6.5. Troubleshooting</a></span></li></ul></li><li><span class="chapter"><a href="#token-exchange">7. Token Exchange</a></span><ul><li><span class="section"><a href="#internal_token_to_internal_token_exchange">7.1. Internal Token to Internal Token Exchange</a></span><ul><li><span class="section"><a href="#client_to_client_permission">7.1.1. Granting Permission for the Exchange</a></span></li><li><span class="section"><a href="#making_the_request">7.1.2. Making the Request</a></span></li></ul></li><li><span class="section"><a href="#internal_token_to_external_token_exchange">7.2. Internal Token to External Token Exchange</a></span><ul><li><span class="section"><a href="#grant_permission_external_exchange">7.2.1. Granting Permission for the Exchange</a></span></li><li><span class="section"><a href="#internal_external_making_request">7.2.2. Making the Request</a></span></li></ul></li><li><span class="section"><a href="#external_token_to_internal_token_exchange">7.3. External Token to Internal Token Exchange</a></span><ul><li><span class="section"><a href="#granting_permission_for_the_exchange">7.3.1. Granting Permission for the Exchange</a></span></li><li><span class="section"><a href="#making_the_request_2">7.3.2. Making the Request</a></span></li></ul></li><li><span class="section"><a href="#impersonation">7.4. Impersonation</a></span><ul><li><span class="section"><a href="#granting_permission_for_the_exchange_2">7.4.1. Granting Permission for the Exchange</a></span></li><li><span class="section"><a href="#making_the_request_3">7.4.2. Making the Request</a></span></li></ul></li><li><span class="section"><a href="#direct_naked_impersonation">7.5. Direct Naked Impersonation</a></span><ul><li><span class="section"><a href="#granting_permission_for_the_exchange_3">7.5.1. Granting Permission for the Exchange</a></span></li><li><span class="section"><a href="#making_the_request_4">7.5.2. Making the Request</a></span></li></ul></li><li><span class="section"><a href="#expand_permission_model_with_service_accounts">7.6. Expand Permission Model With Service Accounts</a></span></li><li><span class="section"><a href="#exchange_vulnerabilities">7.7. Exchange Vulnerabilities</a></span></li></ul></li></ul></div><section class="chapter" id="overview"><div class="titlepage"><div><div><h1 class="title">Chapter 1. Overview</h1></div></div></div><p>
			Red Hat Single Sign-On supports both OpenID Connect (an extension to OAuth 2.0) and SAML 2.0. When securing clients and services the first thing you need to decide is which of the two you are going to use. If you want you can also choose to secure some with OpenID Connect and others with SAML.
		</p><p>
			To secure clients and services you are also going to need an adapter or library for the protocol you’ve selected. Red Hat Single Sign-On comes with its own adapters for selected platforms, but it is also possible to use generic OpenID Connect Relying Party and SAML Service Provider libraries.
		</p><section class="section" id="what_are_client_adapters"><div class="titlepage"><div><div><h2 class="title">1.1. What are Client Adapters?</h2></div></div></div><p>
				Red Hat Single Sign-On client adapters are libraries that make it very easy to secure applications and services with Red Hat Single Sign-On. We call them adapters rather than libraries as they provide a tight integration to the underlying platform and framework. This makes our adapters easy to use and they require less boilerplate code than what is typically required by a library.
			</p></section><section class="section" id="supported_platforms"><div class="titlepage"><div><div><h2 class="title">1.2. Supported Platforms</h2></div></div></div><section class="section" id="openid_connect"><div class="titlepage"><div><div><h3 class="title">1.2.1. OpenID Connect</h3></div></div></div><section class="section" id="java"><div class="titlepage"><div><div><h4 class="title">1.2.1.1. Java</h4></div></div></div><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">
								<a class="link" href="#jboss_adapter" title="2.1.2. JBoss EAP Adapter">JBoss EAP</a>
							</li><li class="listitem">
								<a class="link" href="#fuse_adapter" title="2.1.4. JBoss Fuse 6 Adapter">Fuse</a>
							</li><li class="listitem">
								<a class="link" href="#servlet_filter_adapter" title="2.1.7. Java Servlet Filter Adapter">Servlet Filter</a>
							</li><li class="listitem">
								<a class="link" href="#spring_boot_adapter" title="2.1.6. Spring Boot Adapter">Spring Boot</a>
							</li></ul></div></section><section class="section" id="javascript_client_side"><div class="titlepage"><div><div><h4 class="title">1.2.1.2. JavaScript (client-side)</h4></div></div></div><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">
								<a class="link" href="#javascript_adapter" title="2.2. JavaScript Adapter">JavaScript</a>
							</li></ul></div></section><section class="section" id="node_js_server_side"><div class="titlepage"><div><div><h4 class="title">1.2.1.3. Node.js (server-side)</h4></div></div></div><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">
								<a class="link" href="#nodejs_adapter" title="2.3. Node.js Adapter">Node.js</a>
							</li></ul></div></section></section><section class="section" id="saml"><div class="titlepage"><div><div><h3 class="title">1.2.2. SAML</h3></div></div></div><section class="section" id="java_2"><div class="titlepage"><div><div><h4 class="title">1.2.2.1. Java</h4></div></div></div><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">
								<a class="link" href="#saml_jboss_adapter" title="3.1.2. JBoss EAP Adapter">JBoss EAP</a>
							</li></ul></div></section><section class="section" id="apache_http_server"><div class="titlepage"><div><div><h4 class="title">1.2.2.2. Apache HTTP Server</h4></div></div></div><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">
								<a class="link" href="#mod_auth_mellon" title="3.2. mod_auth_mellon Apache HTTPD Module">mod_auth_mellon</a>
							</li></ul></div></section></section></section><section class="section" id="supported_protocols"><div class="titlepage"><div><div><h2 class="title">1.3. Supported Protocols</h2></div></div></div><section class="section" id="openid_connect_2"><div class="titlepage"><div><div><h3 class="title">1.3.1. OpenID Connect</h3></div></div></div><p>
					<a class="link" href="https://openid.net/connect/">OpenID Connect</a> (OIDC) is an authentication protocol that is an extension of <a class="link" href="https://tools.ietf.org/html/rfc6749">OAuth 2.0</a>. While OAuth 2.0 is only a framework for building authorization protocols and is mainly incomplete, OIDC is a full-fledged authentication and authorization protocol. OIDC also makes heavy use of the <a class="link" href="https://jwt.io">Json Web Token</a> (JWT) set of standards. These standards define an identity token JSON format and ways to digitally sign and encrypt that data in a compact and web-friendly way.
				</p><p>
					There are really two types of use cases when using OIDC. The first is an application that asks the Red Hat Single Sign-On server to authenticate a user for them. After a successful login, the application will receive an <span class="emphasis"><em>identity token</em></span> and an <span class="emphasis"><em>access token</em></span>. The <span class="emphasis"><em>identity token</em></span> contains information about the user such as username, email, and other profile information. The <span class="emphasis"><em>access token</em></span> is digitally signed by the realm and contains access information (like user role mappings) that the application can use to determine what resources the user is allowed to access on the application.
				</p><p>
					The second type of use cases is that of a client that wants to gain access to remote services. In this case, the client asks Red Hat Single Sign-On to obtain an <span class="emphasis"><em>access token</em></span> it can use to invoke on other remote services on behalf of the user. Red Hat Single Sign-On authenticates the user then asks the user for consent to grant access to the client requesting it. The client then receives the <span class="emphasis"><em>access token</em></span>. This <span class="emphasis"><em>access token</em></span> is digitally signed by the realm. The client can make REST invocations on remote services using this <span class="emphasis"><em>access token</em></span>. The REST service extracts the <span class="emphasis"><em>access token</em></span>, verifies the signature of the token, then decides based on access information within the token whether or not to process the request.
				</p></section><section class="section" id="saml_2_0"><div class="titlepage"><div><div><h3 class="title">1.3.2. SAML 2.0</h3></div></div></div><p>
					<a class="link" href="http://saml.xml.org/saml-specifications">SAML 2.0</a> is a similar specification to OIDC but a lot older and more mature. It has its roots in SOAP and the plethora of WS-* specifications so it tends to be a bit more verbose than OIDC. SAML 2.0 is primarily an authentication protocol that works by exchanging XML documents between the authentication server and the application. XML signatures and encryption are used to verify requests and responses.
				</p><p>
					In Red Hat Single Sign-On SAML serves two types of use cases: browser applications and REST invocations.
				</p><p>
					There are really two types of use cases when using SAML. The first is an application that asks the Red Hat Single Sign-On server to authenticate a user for them. After a successful login, the application will receive an XML document that contains something called a SAML assertion that specifies various attributes about the user. This XML document is digitally signed by the realm and contains access information (like user role mappings) that the application can use to determine what resources the user is allowed to access on the application.
				</p><p>
					The second type of use cases is that of a client that wants to gain access to remote services. In this case, the client asks Red Hat Single Sign-On to obtain a SAML assertion it can use to invoke on other remote services on behalf of the user.
				</p></section><section class="section" id="openid_connect_vs_saml"><div class="titlepage"><div><div><h3 class="title">1.3.3. OpenID Connect vs. SAML</h3></div></div></div><p>
					Choosing between OpenID Connect and SAML is not just a matter of using a newer protocol (OIDC) instead of the older more mature protocol (SAML).
				</p><p>
					In most cases Red Hat Single Sign-On recommends using OIDC.
				</p><p>
					SAML tends to be a bit more verbose than OIDC.
				</p><p>
					Beyond verbosity of exchanged data, if you compare the specifications you’ll find that OIDC was designed to work with the web while SAML was retrofitted to work on top of the web. For example, OIDC is also more suited for HTML5/JavaScript applications because it is easier to implement on the client side than SAML. As tokens are in the JSON format, they are easier to consume by JavaScript. You will also find several nice features that make implementing security in your web applications easier. For example, check out the <a class="link" href="https://openid.net/specs/openid-connect-session-1_0.html#ChangeNotification">iframe trick</a> that the specification uses to easily determine if a user is still logged in or not.
				</p><p>
					SAML has its uses though. As you see the OIDC specifications evolve you see they implement more and more features that SAML has had for years. What we often see is that people pick SAML over OIDC because of the perception that it is more mature and also because they already have existing applications that are secured with it.
				</p></section></section></section><section class="chapter" id="openid_connect_3"><div class="titlepage"><div><div><h1 class="title">Chapter 2. OpenID Connect</h1></div></div></div><p>
			This section describes how you can secure applications and services with OpenID Connect using either Red Hat Single Sign-On adapters or generic OpenID Connect Relying Party libraries.
		</p><section class="section" id="java_adapters"><div class="titlepage"><div><div><h2 class="title">2.1. Java Adapters</h2></div></div></div><p>
				Red Hat Single Sign-On comes with a range of different adapters for Java application. Selecting the correct adapter depends on the target platform.
			</p><p>
				All Java adapters share a set of common configuration options described in the <a class="link" href="#java_adapter_config" title="2.1.1. Java Adapter Config">Java Adapters Config</a> chapter.
			</p><section class="section" id="java_adapter_config"><div class="titlepage"><div><div><h3 class="title">2.1.1. Java Adapter Config</h3></div></div></div><p>
					Each Java adapter supported by Red Hat Single Sign-On can be configured by a simple JSON file. This is what one might look like:
				</p><pre class="programlisting language-json">{
  "realm" : "demo",
  "resource" : "customer-portal",
  "realm-public-key" : "MIGfMA0GCSqGSIb3D...31LwIDAQAB",
  "auth-server-url" : "https://localhost:8443/auth",
  "ssl-required" : "external",
  "use-resource-role-mappings" : false,
  "enable-cors" : true,
  "cors-max-age" : 1000,
  "cors-allowed-methods" : "POST, PUT, DELETE, GET",
  "cors-exposed-headers" : "WWW-Authenticate, My-custom-exposed-Header",
  "bearer-only" : false,
  "enable-basic-auth" : false,
  "expose-token" : true,
  "verify-token-audience" : true,
   "credentials" : {
      "secret" : "234234-234234-234234"
   },

   "connection-pool-size" : 20,
   "disable-trust-manager": false,
   "allow-any-hostname" : false,
   "truststore" : "path/to/truststore.jks",
   "truststore-password" : "geheim",
   "client-keystore" : "path/to/client-keystore.jks",
   "client-keystore-password" : "geheim",
   "client-key-password" : "geheim",
   "token-minimum-time-to-live" : 10,
   "min-time-between-jwks-requests" : 10,
   "public-key-cache-ttl": 86400,
   "redirect-rewrite-rules" : {
   "^/wsmaster/api/(.*)$" : "/api/$1"
   }
}</pre><p>
					You can use <code class="literal">${…​}</code> enclosure for system property replacement. For example <code class="literal">${jboss.server.config.dir}</code> would be replaced by <code class="literal">/path/to/Red Hat Single Sign-On</code>. Replacement of environment variables is also supported via the <code class="literal">env</code> prefix, e.g. <code class="literal">${env.MY_ENVIRONMENT_VARIABLE}</code>.
				</p><p>
					The initial config file can be obtained from the admin console. This can be done by opening the admin console, select <code class="literal">Clients</code> from the menu and clicking on the corresponding client. Once the page for the client is opened click on the <code class="literal">Installation</code> tab and select <code class="literal">Keycloak OIDC JSON</code>.
				</p><p>
					Here is a description of each configuration option:
				</p><div class="variablelist"><dl class="variablelist"><dt><span class="term">realm</span></dt><dd>
								Name of the realm. This is <span class="emphasis"><em>REQUIRED.</em></span>
							</dd><dt><span class="term">resource</span></dt><dd>
								The client-id of the application. Each application has a client-id that is used to identify the application. This is <span class="emphasis"><em>REQUIRED.</em></span>
							</dd><dt><span class="term">realm-public-key</span></dt><dd>
								PEM format of the realm public key. You can obtain this from the administration console. This is <span class="emphasis"><em>OPTIONAL</em></span> and it’s not recommended to set it. If not set, the adapter will download this from Red Hat Single Sign-On and it will always re-download it when needed (eg. Red Hat Single Sign-On rotate it’s keys). However if realm-public-key is set, then adapter will never download new keys from Red Hat Single Sign-On, so when Red Hat Single Sign-On rotate it’s keys, adapter will break.
							</dd><dt><span class="term">auth-server-url</span></dt><dd>
								The base URL of the Red Hat Single Sign-On server. All other Red Hat Single Sign-On pages and REST service endpoints are derived from this. It is usually of the form <code class="literal">https://host:port/auth</code>. This is <span class="emphasis"><em>REQUIRED.</em></span>
							</dd><dt><span class="term">ssl-required</span></dt><dd>
								Ensures that all communication to and from the Red Hat Single Sign-On server is over HTTPS. In production this should be set to <code class="literal">all</code>. This is <span class="emphasis"><em>OPTIONAL</em></span>. The default value is <span class="emphasis"><em>external</em></span> meaning that HTTPS is required by default for external requests. Valid values are 'all', 'external' and 'none'.
							</dd><dt><span class="term">confidential-port</span></dt><dd>
								The confidential port used by the Red Hat Single Sign-On server for secure connections over SSL/TLS. This is <span class="emphasis"><em>OPTIONAL</em></span>. The default value is <span class="emphasis"><em>8443</em></span>.
							</dd><dt><span class="term">use-resource-role-mappings</span></dt><dd>
								If set to true, the adapter will look inside the token for application level role mappings for the user. If false, it will look at the realm level for user role mappings. This is <span class="emphasis"><em>OPTIONAL</em></span>. The default value is <span class="emphasis"><em>false</em></span>.
							</dd><dt><span class="term">public-client</span></dt><dd>
								If set to true, the adapter will not send credentials for the client to Red Hat Single Sign-On. This is <span class="emphasis"><em>OPTIONAL</em></span>. The default value is <span class="emphasis"><em>false</em></span>.
							</dd><dt><span class="term">enable-cors</span></dt><dd>
								This enables CORS support. It will handle CORS preflight requests. It will also look into the access token to determine valid origins. This is <span class="emphasis"><em>OPTIONAL</em></span>. The default value is <span class="emphasis"><em>false</em></span>.
							</dd><dt><span class="term">cors-max-age</span></dt><dd>
								If CORS is enabled, this sets the value of the <code class="literal">Access-Control-Max-Age</code> header. This is <span class="emphasis"><em>OPTIONAL</em></span>. If not set, this header is not returned in CORS responses.
							</dd><dt><span class="term">cors-allowed-methods</span></dt><dd>
								If CORS is enabled, this sets the value of the <code class="literal">Access-Control-Allow-Methods</code> header. This should be a comma-separated string. This is <span class="emphasis"><em>OPTIONAL</em></span>. If not set, this header is not returned in CORS responses.
							</dd><dt><span class="term">cors-allowed-headers</span></dt><dd>
								If CORS is enabled, this sets the value of the <code class="literal">Access-Control-Allow-Headers</code> header. This should be a comma-separated string. This is <span class="emphasis"><em>OPTIONAL</em></span>. If not set, this header is not returned in CORS responses.
							</dd><dt><span class="term">cors-exposed-headers</span></dt><dd>
								If CORS is enabled, this sets the value of the <code class="literal">Access-Control-Expose-Headers</code> header. This should be a comma-separated string. This is <span class="emphasis"><em>OPTIONAL</em></span>. If not set, this header is not returned in CORS responses.
							</dd><dt><span class="term">bearer-only</span></dt><dd>
								This should be set to <span class="emphasis"><em>true</em></span> for services. If enabled the adapter will not attempt to authenticate users, but only verify bearer tokens. This is <span class="emphasis"><em>OPTIONAL</em></span>. The default value is <span class="emphasis"><em>false</em></span>.
							</dd><dt><span class="term">autodetect-bearer-only</span></dt><dd>
								This should be set to <span class="emphasis"><em>true</em></span> if your application serves both a web application and web services (e.g. SOAP or REST). It allows you to redirect unauthenticated users of the web application to the Keycloak login page, but send an HTTP <code class="literal">401</code> status code to unauthenticated SOAP or REST clients instead as they would not understand a redirect to the login page. Keycloak auto-detects SOAP or REST clients based on typical headers like <code class="literal">X-Requested-With</code>, <code class="literal">SOAPAction</code> or <code class="literal">Accept</code>. The default value is <span class="emphasis"><em>false</em></span>.
							</dd><dt><span class="term">enable-basic-auth</span></dt><dd>
								This tells the adapter to also support basic authentication. If this option is enabled, then <span class="emphasis"><em>secret</em></span> must also be provided. This is <span class="emphasis"><em>OPTIONAL</em></span>. The default value is <span class="emphasis"><em>false</em></span>.
							</dd><dt><span class="term">expose-token</span></dt><dd>
								If <code class="literal">true</code>, an authenticated browser client (via a JavaScript HTTP invocation) can obtain the signed access token via the URL <code class="literal">root/k_query_bearer_token</code>. This is <span class="emphasis"><em>OPTIONAL</em></span>. The default value is <span class="emphasis"><em>false</em></span>.
							</dd><dt><span class="term">credentials</span></dt><dd>
								Specify the credentials of the application. This is an object notation where the key is the credential type and the value is the value of the credential type. Currently password and jwt is supported. This is <span class="emphasis"><em>REQUIRED</em></span> only for clients with 'Confidential' access type.
							</dd><dt><span class="term">connection-pool-size</span></dt><dd>
								This config option defines how many connections to the Red Hat Single Sign-On server should be pooled. This is <span class="emphasis"><em>OPTIONAL</em></span>. The default value is <code class="literal">20</code>.
							</dd><dt><span class="term">disable-trust-manager</span></dt><dd>
								If the Red Hat Single Sign-On server requires HTTPS and this config option is set to <code class="literal">true</code> you do not have to specify a truststore. This setting should only be used during development and <span class="strong strong"><strong>never</strong></span> in production as it will disable verification of SSL certificates. This is <span class="emphasis"><em>OPTIONAL</em></span>. The default value is <code class="literal">false</code>.
							</dd><dt><span class="term">allow-any-hostname</span></dt><dd>
								If the Red Hat Single Sign-On server requires HTTPS and this config option is set to <code class="literal">true</code> the Red Hat Single Sign-On server’s certificate is validated via the truststore, but host name validation is not done. This setting should only be used during development and <span class="strong strong"><strong>never</strong></span> in production as it will disable verification of SSL certificates. This seting may be useful in test environments This is <span class="emphasis"><em>OPTIONAL</em></span>. The default value is <code class="literal">false</code>.
							</dd><dt><span class="term">proxy-url</span></dt><dd>
								The URL for the HTTP proxy if one is used.
							</dd><dt><span class="term">truststore</span></dt><dd>
								The value is the file path to a truststore file. If you prefix the path with <code class="literal">classpath:</code>, then the truststore will be obtained from the deployment’s classpath instead. Used for outgoing HTTPS communications to the Red Hat Single Sign-On server. Client making HTTPS requests need a way to verify the host of the server they are talking to. This is what the trustore does. The keystore contains one or more trusted host certificates or certificate authorities. You can create this truststore by extracting the public certificate of the Red Hat Single Sign-On server’s SSL keystore. This is <span class="emphasis"><em>REQUIRED</em></span> unless <code class="literal">ssl-required</code> is <code class="literal">none</code> or <code class="literal">disable-trust-manager</code> is <code class="literal">true</code>.
							</dd><dt><span class="term">truststore-password</span></dt><dd>
								Password for the truststore. This is <span class="emphasis"><em>REQUIRED</em></span> if <code class="literal">truststore</code> is set and the truststore requires a password.
							</dd><dt><span class="term">client-keystore</span></dt><dd>
								This is the file path to a keystore file. This keystore contains client certificate for two-way SSL when the adapter makes HTTPS requests to the Red Hat Single Sign-On server. This is <span class="emphasis"><em>OPTIONAL</em></span>.
							</dd><dt><span class="term">client-keystore-password</span></dt><dd>
								Password for the client keystore. This is <span class="emphasis"><em>REQUIRED</em></span> if <code class="literal">client-keystore</code> is set.
							</dd><dt><span class="term">client-key-password</span></dt><dd>
								Password for the client’s key. This is <span class="emphasis"><em>REQUIRED</em></span> if <code class="literal">client-keystore</code> is set.
							</dd><dt><span class="term">always-refresh-token</span></dt><dd>
								If <span class="emphasis"><em>true</em></span>, the adapter will refresh token in every request. Warning - when enabled this will result in a request to Red Hat Single Sign-On for every request to your application.
							</dd><dt><span class="term">register-node-at-startup</span></dt><dd>
								If <span class="emphasis"><em>true</em></span>, then adapter will send registration request to Red Hat Single Sign-On. It’s <span class="emphasis"><em>false</em></span> by default and useful only when application is clustered. See <a class="link" href="#applicationclustering" title="2.1.14. Application Clustering">Application Clustering</a> for details
							</dd><dt><span class="term">register-node-period</span></dt><dd>
								Period for re-registration adapter to Red Hat Single Sign-On. Useful when application is clustered. See <a class="link" href="#applicationclustering" title="2.1.14. Application Clustering">Application Clustering</a> for details
							</dd><dt><span class="term">token-store</span></dt><dd>
								Possible values are <span class="emphasis"><em>session</em></span> and <span class="emphasis"><em>cookie</em></span>. Default is <span class="emphasis"><em>session</em></span>, which means that adapter stores account info in HTTP Session. Alternative <span class="emphasis"><em>cookie</em></span> means storage of info in cookie. See <a class="link" href="#applicationclustering" title="2.1.14. Application Clustering">Application Clustering</a> for details
							</dd><dt><span class="term">token-cookie-path</span></dt><dd>
								When using a cookie store, this option sets the path of the cookie used to store account info. If it’s a relative path, then it is assumed that the application is running in a context root, and is interpreted relative to that context root. If it’s an absolute path, then the absolute path is used to set the cookie path. Defaults to use paths relative to the context root.
							</dd><dt><span class="term">principal-attribute</span></dt><dd>
								OpenID Connect ID Token attribute to populate the UserPrincipal name with. If token attribute is null, defaults to <code class="literal">sub</code>. Possible values are <code class="literal">sub</code>, <code class="literal">preferred_username</code>, <code class="literal">email</code>, <code class="literal">name</code>, <code class="literal">nickname</code>, <code class="literal">given_name</code>, <code class="literal">family_name</code>.
							</dd><dt><span class="term">turn-off-change-session-id-on-login</span></dt><dd>
								The session id is changed by default on a successful login on some platforms to plug a security attack vector. Change this to true if you want to turn this off This is <span class="emphasis"><em>OPTIONAL</em></span>. The default value is <span class="emphasis"><em>false</em></span>.
							</dd><dt><span class="term">token-minimum-time-to-live</span></dt><dd>
								Amount of time, in seconds, to preemptively refresh an active access token with the Red Hat Single Sign-On server before it expires. This is especially useful when the access token is sent to another REST client where it could expire before being evaluated. This value should never exceed the realm’s access token lifespan. This is <span class="emphasis"><em>OPTIONAL</em></span>. The default value is <code class="literal">0</code> seconds, so adapter will refresh access token just if it’s expired.
							</dd><dt><span class="term">min-time-between-jwks-requests</span></dt><dd>
								Amount of time, in seconds, specifying minimum interval between two requests to Red Hat Single Sign-On to retrieve new public keys. It is 10 seconds by default. Adapter will always try to download new public key when it recognize token with unknown <code class="literal">kid</code> . However it won’t try it more than once per 10 seconds (by default). This is to avoid DoS when attacker sends lots of tokens with bad <code class="literal">kid</code> forcing adapter to send lots of requests to Red Hat Single Sign-On.
							</dd><dt><span class="term">public-key-cache-ttl</span></dt><dd>
								Amount of time, in seconds, specifying maximum interval between two requests to Red Hat Single Sign-On to retrieve new public keys. It is 86400 seconds (1 day) by default. Adapter will always try to download new public key when it recognize token with unknown <code class="literal">kid</code> . If it recognize token with known <code class="literal">kid</code>, it will just use the public key downloaded previously. However at least once per this configured interval (1 day by default) will be new public key always downloaded even if the <code class="literal">kid</code> of token is already known.
							</dd><dt><span class="term">ignore-oauth-query-parameter</span></dt><dd>
								Defaults to <code class="literal">false</code>, if set to <code class="literal">true</code> will turn off processing of the <code class="literal">access_token</code> query parameter for bearer token processing. Users will not be able to authenticate if they only pass in an <code class="literal">access_token</code>
							</dd><dt><span class="term">redirect-rewrite-rules</span></dt><dd>
								If needed, specify the Redirect URI rewrite rule. This is an object notation where the key is the regular expression to which the Redirect URI is to be matched and the value is the replacement String. <code class="literal">$</code> character can be used for backreferences in the replacement String.
							</dd><dt><span class="term">verify-token-audience</span></dt><dd>
								If set to <code class="literal">true</code>, then during authentication with the bearer token, the adapter will verify whether the token contains this client name (resource) as an audience. The option is especially useful for services, which primarily serve requests authenticated by the bearer token. This is set to <code class="literal">false</code> by default, however for improved security, it is recommended to enable this. See <a class="link" href="https://access.redhat.com/documentation/en-us/red_hat_single_sign-on/7.4/html-single/server_administration_guide/#_audience">Audience Support</a> for more details about audience support.
							</dd></dl></div></section><section class="section" id="jboss_adapter"><div class="titlepage"><div><div><h3 class="title">2.1.2. JBoss EAP Adapter</h3></div></div></div><p>
					To be able to secure WAR apps deployed on JBoss EAP, you must install and configure the Red Hat Single Sign-On adapter subsystem. You then have two options to secure your WARs.
				</p><p>
					You can provide an adapter config file in your WAR and change the auth-method to KEYCLOAK within web.xml.
				</p><p>
					Alternatively, you don’t have to modify your WAR at all and you can secure it via the Red Hat Single Sign-On adapter subsystem configuration in the configuration file, such as <code class="literal">standalone.xml</code>. Both methods are described in this section.
				</p><section class="section" id="jboss_adapter_installation"><div class="titlepage"><div><div><h4 class="title">2.1.2.1. Installing the adapter</h4></div></div></div><p>
						Adapters are available as a separate archive depending on what server version you are using.
					</p><p>
						Install on JBoss EAP 7:
					</p><p>
						You can install the EAP 7 adapters either by unzipping a ZIP file, or by using an RPM.
					</p><p>
						Install the EAP 7 Adapters from a ZIP File:
					</p><pre class="screen">$ cd $EAP_HOME
$ unzip rh-sso-7.4.0.GA-eap7-adapter.zip</pre><p>
						Install on JBoss EAP 6:
					</p><p>
						You can install the EAP 6 adapters either by unzipping a ZIP file, or by using an RPM.
					</p><p>
						Install the EAP 6 Adapters from a ZIP File:
					</p><pre class="screen">$ cd $EAP_HOME
$ unzip rh-sso-7.4.0.GA-eap6-adapter.zip</pre><p>
						This ZIP archive contains JBoss Modules specific to the Red Hat Single Sign-On adapter. It also contains JBoss CLI scripts to configure the adapter subsystem.
					</p><p>
						To configure the adapter subsystem if the server is not running execute:
					</p><div class="admonition note"><div class="admonition_header">Note</div><div><p>
							Alternatively, you can specify the <code class="literal">server.config</code> property while installing adapters from the command line to install adapters using a different config, for example: <code class="literal">-Dserver.config=standalone-ha.xml</code>.
						</p></div></div><div class="formalpara"><p class="title"><strong>JBoss EAP 7.1 or newer</strong></p><p>
							
<pre class="screen">$ ./bin/jboss-cli.sh --file=bin/adapter-elytron-install-offline.cli</pre>
						</p></div><div class="admonition note"><div class="admonition_header">Note</div><div><p>
							The offline script is not available for JBoss EAP 6.4
						</p></div></div><p>
						Alternatively, if the server is running execute:
					</p><div class="formalpara"><p class="title"><strong>JBoss EAP 7.1 or newer</strong></p><p>
							
<pre class="screen">$ ./bin/jboss-cli.sh -c --file=bin/adapter-elytron-install.cli</pre>
						</p></div><div class="admonition note"><div class="admonition_header">Note</div><div><p>
							It is possible to use the legacy non-Elytron adapter on JBoss EAP 7.1 or newer as well, meaning you can use <code class="literal">adapter-install-offline.cli</code>
						</p></div></div><div class="formalpara"><p class="title"><strong>JBoss EAP 6.4</strong></p><p>
							
<pre class="screen">$ ./bin/jboss-cli.sh -c --file=bin/adapter-install.cli</pre>
						</p></div></section><section class="section" id="jboss_sso"><div class="titlepage"><div><div><h4 class="title">2.1.2.2. JBoss SSO</h4></div></div></div><p>
						JBoss EAP has built-in support for single sign-on for web applications deployed to the same JBoss EAP instance. This should not be enabled when using Red Hat Single Sign-On.
					</p></section><section class="section" id="required_per_war_configuration"><div class="titlepage"><div><div><h4 class="title">2.1.2.3. Required Per WAR Configuration</h4></div></div></div><p>
						This section describes how to secure a WAR directly by adding configuration and editing files within your WAR package.
					</p><p>
						The first thing you must do is create a <code class="literal">keycloak.json</code> adapter configuration file within the <code class="literal">WEB-INF</code> directory of your WAR.
					</p><p>
						The format of this configuration file is described in the <a class="link" href="#java_adapter_config" title="2.1.1. Java Adapter Config">Java adapter configuration</a> section.
					</p><p>
						Next you must set the <code class="literal">auth-method</code> to <code class="literal">KEYCLOAK</code> in <code class="literal">web.xml</code>. You also have to use standard servlet security to specify role-base constraints on your URLs.
					</p><p>
						Here’s an example:
					</p><pre class="programlisting language-xml">&lt;web-app xmlns="http://java.sun.com/xml/ns/javaee"
      xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
      xsi:schemaLocation="http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/web-app_3_0.xsd"
      version="3.0"&gt;

    &lt;module-name&gt;application&lt;/module-name&gt;

    &lt;security-constraint&gt;
        &lt;web-resource-collection&gt;
            &lt;web-resource-name&gt;Admins&lt;/web-resource-name&gt;
            &lt;url-pattern&gt;/admin/*&lt;/url-pattern&gt;
        &lt;/web-resource-collection&gt;
        &lt;auth-constraint&gt;
            &lt;role-name&gt;admin&lt;/role-name&gt;
        &lt;/auth-constraint&gt;
        &lt;user-data-constraint&gt;
            &lt;transport-guarantee&gt;CONFIDENTIAL&lt;/transport-guarantee&gt;
        &lt;/user-data-constraint&gt;
    &lt;/security-constraint&gt;
    &lt;security-constraint&gt;
        &lt;web-resource-collection&gt;
            &lt;web-resource-name&gt;Customers&lt;/web-resource-name&gt;
            &lt;url-pattern&gt;/customers/*&lt;/url-pattern&gt;
        &lt;/web-resource-collection&gt;
        &lt;auth-constraint&gt;
            &lt;role-name&gt;user&lt;/role-name&gt;
        &lt;/auth-constraint&gt;
        &lt;user-data-constraint&gt;
            &lt;transport-guarantee&gt;CONFIDENTIAL&lt;/transport-guarantee&gt;
        &lt;/user-data-constraint&gt;
    &lt;/security-constraint&gt;

    &lt;login-config&gt;
        &lt;auth-method&gt;KEYCLOAK&lt;/auth-method&gt;
        &lt;realm-name&gt;this is ignored currently&lt;/realm-name&gt;
    &lt;/login-config&gt;

    &lt;security-role&gt;
        &lt;role-name&gt;admin&lt;/role-name&gt;
    &lt;/security-role&gt;
    &lt;security-role&gt;
        &lt;role-name&gt;user&lt;/role-name&gt;
    &lt;/security-role&gt;
&lt;/web-app&gt;</pre></section><section class="section" id="securing_wars_via_adapter_subsystem"><div class="titlepage"><div><div><h4 class="title">2.1.2.4. Securing WARs via Adapter Subsystem</h4></div></div></div><p>
						You do not have to modify your WAR to secure it with Red Hat Single Sign-On. Instead you can externally secure it via the Red Hat Single Sign-On Adapter Subsystem. While you don’t have to specify KEYCLOAK as an <code class="literal">auth-method</code>, you still have to define the <code class="literal">security-constraints</code> in <code class="literal">web.xml</code>. You do not, however, have to create a <code class="literal">WEB-INF/keycloak.json</code> file. This metadata is instead defined within server configuration (i.e. <code class="literal">standalone.xml</code>) in the Red Hat Single Sign-On subsystem definition.
					</p><pre class="programlisting language-xml">&lt;extensions&gt;
  &lt;extension module="org.keycloak.keycloak-adapter-subsystem"/&gt;
&lt;/extensions&gt;

&lt;profile&gt;
  &lt;subsystem xmlns="urn:jboss:domain:keycloak:1.1"&gt;
     &lt;secure-deployment name="WAR MODULE NAME.war"&gt;
        &lt;realm&gt;demo&lt;/realm&gt;
        &lt;auth-server-url&gt;http://localhost:8081/auth&lt;/auth-server-url&gt;
        &lt;ssl-required&gt;external&lt;/ssl-required&gt;
        &lt;resource&gt;customer-portal&lt;/resource&gt;
        &lt;credential name="secret"&gt;password&lt;/credential&gt;
     &lt;/secure-deployment&gt;
  &lt;/subsystem&gt;
&lt;/profile&gt;</pre><p>
						The <code class="literal">secure-deployment</code> <code class="literal">name</code> attribute identifies the WAR you want to secure. Its value is the <code class="literal">module-name</code> defined in <code class="literal">web.xml</code> with <code class="literal">.war</code> appended. The rest of the configuration corresponds pretty much one to one with the <code class="literal">keycloak.json</code> configuration options defined in <a class="link" href="#java_adapter_config" title="2.1.1. Java Adapter Config">Java adapter configuration</a>.
					</p><p>
						The exception is the <code class="literal">credential</code> element.
					</p><p>
						To make it easier for you, you can go to the Red Hat Single Sign-On Administration Console and go to the Client/Installation tab of the application this WAR is aligned with. It provides an example XML file you can cut and paste.
					</p><p>
						If you have multiple deployments secured by the same realm you can share the realm configuration in a separate element. For example:
					</p><pre class="programlisting language-xml">&lt;subsystem xmlns="urn:jboss:domain:keycloak:1.1"&gt;
    &lt;realm name="demo"&gt;
        &lt;auth-server-url&gt;http://localhost:8080/auth&lt;/auth-server-url&gt;
        &lt;ssl-required&gt;external&lt;/ssl-required&gt;
    &lt;/realm&gt;
    &lt;secure-deployment name="customer-portal.war"&gt;
        &lt;realm&gt;demo&lt;/realm&gt;
        &lt;resource&gt;customer-portal&lt;/resource&gt;
        &lt;credential name="secret"&gt;password&lt;/credential&gt;
    &lt;/secure-deployment&gt;
    &lt;secure-deployment name="product-portal.war"&gt;
        &lt;realm&gt;demo&lt;/realm&gt;
        &lt;resource&gt;product-portal&lt;/resource&gt;
        &lt;credential name="secret"&gt;password&lt;/credential&gt;
    &lt;/secure-deployment&gt;
    &lt;secure-deployment name="database.war"&gt;
        &lt;realm&gt;demo&lt;/realm&gt;
        &lt;resource&gt;database-service&lt;/resource&gt;
        &lt;bearer-only&gt;true&lt;/bearer-only&gt;
    &lt;/secure-deployment&gt;
&lt;/subsystem&gt;</pre></section><section class="section" id="security_domain"><div class="titlepage"><div><div><h4 class="title">2.1.2.5. Security Domain</h4></div></div></div><p>
						The security context is propagated to the EJB tier automatically.
					</p></section></section><section class="section" id="jboss_adapter_rpm"><div class="titlepage"><div><div><h3 class="title">2.1.3. Installing JBoss EAP Adapter from an RPM</h3></div></div></div><p>
					Install the EAP 7 Adapters from an RPM:
				</p><div class="admonition note"><div class="admonition_header">Note</div><div><p>
						With Red Hat Enterprise Linux 7, the term channel was replaced with the term repository. In these instructions only the term repository is used.
					</p></div></div><p>
					You must subscribe to the JBoss EAP 7.2 repository before you can install the JBoss EAP 7 adapters from an RPM.
				</p><div class="orderedlist"><p class="title"><strong>Prerequisites</strong></p><ol class="orderedlist" type="1"><li class="listitem">
							Ensure that your Red Hat Enterprise Linux system is registered to your account using Red Hat Subscription Manager. For more information see the <a class="link" href="https://access.redhat.com/documentation/en-us/red_hat_subscription_management/1/html-single/quick_registration_for_rhel/index">Red Hat Subscription Management documentation</a>.
						</li><li class="listitem">
							If you are already subscribed to another JBoss EAP repository, you must unsubscribe from that repository first.
						</li></ol></div><p>
					For Red Hat Enterprise Linux 6, 7: Using Red Hat Subscription Manager, subscribe to the JBoss EAP 7.2 repository using the following command. Replace &lt;RHEL_VERSION&gt; with either 6 or 7 depending on your Red Hat Enterprise Linux version.
				</p><pre class="programlisting language-bash">$ sudo subscription-manager repos --enable=jb-eap-7-for-rhel-&lt;RHEL_VERSION&gt;-server-rpms</pre><p>
					For Red Hat Enterprise Linux 8: Using Red Hat Subscription Manager, subscribe to the JBoss EAP 7.2 repository using the following command:
				</p><pre class="programlisting language-bash">$ sudo subscription-manager repos --enable=jb-eap-7.2-for-rhel-8-x86_64-rpms --enable=rhel-8-for-x86_64-baseos-rpms --enable=rhel-8-for-x86_64-appstream-rpms</pre><p>
					Install the JBoss EAP 7 adapters for OIDC using the following command at Red Hat Enterprise Linux 6, 7:
				</p><pre class="screen">$ sudo yum install eap7-keycloak-adapter-sso7_3</pre><p>
					or use following one for Red Hat Enterprise Linux 8:
				</p><pre class="screen">$ sudo dnf install eap7-keycloak-adapter-sso7_3</pre><div class="admonition note"><div class="admonition_header">Note</div><div><p>
						The default EAP_HOME path for the RPM installation is /opt/rh/eap7/root/usr/share/wildfly.
					</p></div></div><p>
					Run the appropriate module installation script.
				</p><p>
					For the OIDC module, enter the following command:
				</p><pre class="screen">$ $EAP_HOME/bin/jboss-cli.sh -c --file=$EAP_HOME/bin/adapter-install.cli</pre><p>
					Your installation is complete.
				</p><p>
					Install the EAP 6 Adapters from an RPM:
				</p><div class="admonition note"><div class="admonition_header">Note</div><div><p>
						With Red Hat Enterprise Linux 7, the term channel was replaced with the term repository. In these instructions only the term repository is used.
					</p></div></div><p>
					You must subscribe to the JBoss EAP 6 repository before you can install the EAP 6 adapters from an RPM.
				</p><div class="orderedlist"><p class="title"><strong>Prerequisites</strong></p><ol class="orderedlist" type="1"><li class="listitem">
							Ensure that your Red Hat Enterprise Linux system is registered to your account using Red Hat Subscription Manager. For more information see the <a class="link" href="https://access.redhat.com/documentation/en-us/red_hat_subscription_management/1/html-single/quick_registration_for_rhel/index">Red Hat Subscription Management documentation</a>.
						</li><li class="listitem">
							If you are already subscribed to another JBoss EAP repository, you must unsubscribe from that repository first.
						</li></ol></div><p>
					Using Red Hat Subscription Manager, subscribe to the JBoss EAP 6 repository using the following command. Replace &lt;RHEL_VERSION&gt; with either 6 or 7 depending on your Red Hat Enterprise Linux version.
				</p><pre class="screen">$ sudo subscription-manager repos --enable=jb-eap-6-for-rhel-&lt;RHEL_VERSION&gt;-server-rpms</pre><p>
					Install the EAP 6 adapters for OIDC using the following command:
				</p><pre class="screen">$ sudo yum install keycloak-adapter-sso7_3-eap6</pre><div class="admonition note"><div class="admonition_header">Note</div><div><p>
						The default EAP_HOME path for the RPM installation is /opt/rh/eap6/root/usr/share/wildfly.
					</p></div></div><p>
					Run the appropriate module installation script.
				</p><p>
					For the OIDC module, enter the following command:
				</p><pre class="screen">$ $EAP_HOME/bin/jboss-cli.sh -c --file=$EAP_HOME/bin/adapter-install.cli</pre><p>
					Your installation is complete.
				</p></section><section class="section" id="fuse_adapter"><div class="titlepage"><div><div><h3 class="title">2.1.4. JBoss Fuse 6 Adapter</h3></div></div></div><p>
					Red Hat Single Sign-On supports securing your web applications running inside <a class="link" href="https://developers.redhat.com/products/fuse/overview">JBoss Fuse 6</a>.
				</p><div class="admonition warning"><div class="admonition_header">Warning</div><div><p>
						The only supported version of Fuse 6 is the latest release. If you use earlier versions of Fuse 6, it is possible that some functions will not work correctly. In particular, the <a class="link" href="https://hawt.io/">Hawtio</a> integration will not work with earlier versions of Fuse 6.
					</p></div></div><p>
					Security for the following items is supported for Fuse:
				</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">
							Classic WAR applications deployed on Fuse with Pax Web War Extender
						</li><li class="listitem">
							Servlets deployed on Fuse as OSGI services with Pax Web Whiteboard Extender
						</li><li class="listitem">
							<a class="link" href="https://camel.apache.org/">Apache Camel</a> Jetty endpoints running with the <a class="link" href="https://camel.apache.org/components/latest/jetty-component.html">Camel Jetty</a> component
						</li><li class="listitem">
							<a class="link" href="https://cxf.apache.org/">Apache CXF</a> endpoints running on their own separate <a class="link" href="https://cxf.apache.org/docs/jetty-configuration.html">Jetty engine</a>
						</li><li class="listitem">
							<a class="link" href="https://cxf.apache.org/">Apache CXF</a> endpoints running on the default engine provided by the CXF servlet
						</li><li class="listitem">
							SSH and JMX admin access
						</li><li class="listitem">
							<a class="link" href="https://hawt.io/">Hawtio administration console</a>
						</li></ul></div><section class="section" id="securing_your_web_applications_inside_fuse_6"><div class="titlepage"><div><div><h4 class="title">2.1.4.1. Securing Your Web Applications Inside Fuse 6</h4></div></div></div><p>
						You must first install the Red Hat Single Sign-On Karaf feature. Next you will need to perform the steps according to the type of application you want to secure. All referenced web applications require injecting the Red Hat Single Sign-On Jetty authenticator into the underlying Jetty server. The steps to achieve this depend on the application type. The details are described below.
					</p></section><section class="section" id="fuse_install_feature"><div class="titlepage"><div><div><h4 class="title">2.1.4.2. Installing the Keycloak Feature</h4></div></div></div><p>
						You must first install the <code class="literal">keycloak</code> feature in the JBoss Fuse environment. The keycloak feature includes the Fuse adapter and all third-party dependencies. You can install it either from the Maven repository or from an archive.
					</p><section class="section" id="installing_from_the_maven_repository"><div class="titlepage"><div><div><h5 class="title">2.1.4.2.1. Installing from the Maven Repository</h5></div></div></div><p>
							As a prerequisite, you must be online and have access to the Maven repository.
						</p><p>
							For Red Hat Single Sign-On you first need to configure a proper Maven repository, so you can install the artifacts. For more information see the <a class="link" href="https://access.redhat.com/maven-repository">JBoss Enterprise Maven repository</a> page.
						</p><p>
							Assuming the Maven repository is <a class="link" href="https://maven.repository.redhat.com/ga/">https://maven.repository.redhat.com/ga/</a>, add the following to the <code class="literal">$FUSE_HOME/etc/org.ops4j.pax.url.mvn.cfg</code> file and add the repository to the list of supported repositories. For example:
						</p><pre class="screen"> org.ops4j.pax.url.mvn.repositories= \
    https://maven.repository.redhat.com/ga/@id=redhat.product.repo
    http://repo1.maven.org/maven2@id=maven.central.repo, \
    ...</pre><p>
							To install the keycloak feature using the Maven repository, complete the following steps:
						</p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p class="simpara">
									Start JBoss Fuse 6.3.0 Rollup 12; then in the Karaf terminal type:
								</p><pre class="screen">features:addurl mvn:org.keycloak/keycloak-osgi-features/4.8.3.Final-redhat-00001/xml/features
features:install keycloak</pre></li><li class="listitem"><p class="simpara">
									You might also need to install the Jetty 9 feature:
								</p><pre class="screen">features:install keycloak-jetty9-adapter</pre></li><li class="listitem">
									Ensure that the features were installed:
								</li></ol></div><pre class="screen">features:list | grep keycloak</pre></section><section class="section" id="installing_from_the_zip_bundle"><div class="titlepage"><div><div><h5 class="title">2.1.4.2.2. Installing from the ZIP bundle</h5></div></div></div><p>
							This is useful if you are offline or do not want to use Maven to obtain the JAR files and other artifacts.
						</p><p>
							To install the Fuse adapter from the ZIP archive, complete the following steps:
						</p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem">
									Download the Red Hat Single Sign-On Fuse adapter ZIP archive.
								</li><li class="listitem"><p class="simpara">
									Unzip it into the root directory of JBoss Fuse. The dependencies are then installed under the <code class="literal">system</code> directory. You can overwrite all existing jar files.
								</p><p class="simpara">
									Use this for JBoss Fuse 6.3.0 Rollup 12:
								</p><pre class="screen">cd /path-to-fuse/jboss-fuse-6.3.0.redhat-254
unzip -q /path-to-adapter-zip/rh-sso-7.4.0.GA-fuse-adapter.zip</pre></li><li class="listitem"><p class="simpara">
									Start Fuse and run these commands in the fuse/karaf terminal:
								</p><pre class="screen">features:addurl mvn:org.keycloak/keycloak-osgi-features/4.8.3.Final-redhat-00001/xml/features
features:install keycloak</pre></li><li class="listitem">
									Install the corresponding Jetty adapter. Since the artifacts are available directly in the JBoss Fuse <code class="literal">system</code> directory, you do not need to use the Maven repository.
								</li></ol></div></section></section><section class="section" id="fuse_adapter_classic_war"><div class="titlepage"><div><div><h4 class="title">2.1.4.3. Securing a Classic WAR Application</h4></div></div></div><p>
						The needed steps to secure your WAR application are:
					</p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p class="simpara">
								In the <code class="literal">/WEB-INF/web.xml</code> file, declare the necessary:
							</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">
										security constraints in the &lt;security-constraint&gt; element
									</li><li class="listitem">
										login configuration in the &lt;login-config&gt; element
									</li><li class="listitem"><p class="simpara">
										security roles in the &lt;security-role&gt; element.
									</p><p class="simpara">
										For example:
									</p><pre class="programlisting language-xml">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;web-app xmlns="http://java.sun.com/xml/ns/javaee"
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/web-app_3_0.xsd"
         version="3.0"&gt;

    &lt;module-name&gt;customer-portal&lt;/module-name&gt;

    &lt;welcome-file-list&gt;
        &lt;welcome-file&gt;index.html&lt;/welcome-file&gt;
    &lt;/welcome-file-list&gt;

    &lt;security-constraint&gt;
        &lt;web-resource-collection&gt;
            &lt;web-resource-name&gt;Customers&lt;/web-resource-name&gt;
            &lt;url-pattern&gt;/customers/*&lt;/url-pattern&gt;
        &lt;/web-resource-collection&gt;
        &lt;auth-constraint&gt;
            &lt;role-name&gt;user&lt;/role-name&gt;
        &lt;/auth-constraint&gt;
    &lt;/security-constraint&gt;

    &lt;login-config&gt;
        &lt;auth-method&gt;BASIC&lt;/auth-method&gt;
        &lt;realm-name&gt;does-not-matter&lt;/realm-name&gt;
    &lt;/login-config&gt;

    &lt;security-role&gt;
        &lt;role-name&gt;admin&lt;/role-name&gt;
    &lt;/security-role&gt;
    &lt;security-role&gt;
        &lt;role-name&gt;user&lt;/role-name&gt;
    &lt;/security-role&gt;
&lt;/web-app&gt;</pre></li></ul></div></li><li class="listitem"><p class="simpara">
								Add the <code class="literal">jetty-web.xml</code> file with the authenticator to the <code class="literal">/WEB-INF/jetty-web.xml</code> file.
							</p><p class="simpara">
								For example:
							</p><pre class="programlisting language-xml">&lt;?xml version="1.0"?&gt;
&lt;!DOCTYPE Configure PUBLIC "-//Mort Bay Consulting//DTD Configure//EN"
 "http://www.eclipse.org/jetty/configure_9_0.dtd"&gt;
&lt;Configure class="org.eclipse.jetty.webapp.WebAppContext"&gt;
    &lt;Get name="securityHandler"&gt;
        &lt;Set name="authenticator"&gt;
            &lt;New class="org.keycloak.adapters.jetty.KeycloakJettyAuthenticator"&gt;
            &lt;/New&gt;
        &lt;/Set&gt;
    &lt;/Get&gt;
&lt;/Configure&gt;</pre></li><li class="listitem">
								Within the <code class="literal">/WEB-INF/</code> directory of your WAR, create a new file, keycloak.json. The format of this configuration file is described in the <a class="link" href="#java_adapter_config" title="2.1.1. Java Adapter Config">Java Adapters Config</a> section. It is also possible to make this file available externally as described in <a class="link" href="#config_external_adapter" title="2.1.4.3.1. Configuring the External Adapter">Configuring the External Adapter</a>.
							</li><li class="listitem"><p class="simpara">
								Ensure your WAR application imports <code class="literal">org.keycloak.adapters.jetty</code> and maybe some more packages in the <code class="literal">META-INF/MANIFEST.MF</code> file, under the <code class="literal">Import-Package</code> header. Using <code class="literal">maven-bundle-plugin</code> in your project properly generates OSGI headers in manifest. Note that "*" resolution for the package does not import the <code class="literal">org.keycloak.adapters.jetty</code> package, since it is not used by the application or the Blueprint or Spring descriptor, but is rather used in the <code class="literal">jetty-web.xml</code> file.
							</p><p class="simpara">
								The list of the packages to import might look like this:
							</p><pre class="screen">org.keycloak.adapters.jetty;version="4.8.3.Final-redhat-00001",
org.keycloak.adapters;version="4.8.3.Final-redhat-00001",
org.keycloak.constants;version="4.8.3.Final-redhat-00001",
org.keycloak.util;version="4.8.3.Final-redhat-00001",
org.keycloak.*;version="4.8.3.Final-redhat-00001",
*;resolution:=optional</pre></li></ol></div><section class="section" id="config_external_adapter"><div class="titlepage"><div><div><h5 class="title">2.1.4.3.1. Configuring the External Adapter</h5></div></div></div><p>
							If you do not want the <code class="literal">keycloak.json</code> adapter configuration file to be bundled inside your WAR application, but instead made available externally and loaded based on naming conventions, use this configuration method.
						</p><p>
							To enable the functionality, add this section to your <code class="literal">/WEB_INF/web.xml</code> file:
						</p><pre class="programlisting language-xml">&lt;context-param&gt;
    &lt;param-name&gt;keycloak.config.resolver&lt;/param-name&gt;
    &lt;param-value&gt;org.keycloak.adapters.osgi.PathBasedKeycloakConfigResolver&lt;/param-value&gt;
&lt;/context-param&gt;</pre><p>
							That component uses <code class="literal">keycloak.config</code> or <code class="literal">karaf.etc</code> java properties to search for a base folder to locate the configuration. Then inside one of those folders it searches for a file called <code class="literal">&lt;your_web_context&gt;-keycloak.json</code>.
						</p><p>
							So, for example, if your web application has context <code class="literal">my-portal</code>, then your adapter configuration is loaded from the <code class="literal">$FUSE_HOME/etc/my-portal-keycloak.json</code> file.
						</p></section></section><section class="section" id="fuse_adapter_servlet_whiteboard"><div class="titlepage"><div><div><h4 class="title">2.1.4.4. Securing a Servlet Deployed as an OSGI Service</h4></div></div></div><p>
						You can use this method if you have a servlet class inside your OSGI bundled project that is not deployed as a classic WAR application. Fuse uses Pax Web Whiteboard Extender to deploy such servlets as web applications.
					</p><p>
						To secure your servlet with Red Hat Single Sign-On, complete the following steps:
					</p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p class="simpara">
								Red Hat Single Sign-On provides PaxWebIntegrationService, which allows injecting jetty-web.xml and configuring security constraints for your application. You need to declare such services in the <code class="literal">OSGI-INF/blueprint/blueprint.xml</code> file inside your application. Note that your servlet needs to depend on it. An example configuration:
							</p><pre class="programlisting language-xml">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;blueprint xmlns="http://www.osgi.org/xmlns/blueprint/v1.0.0"
           xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
           xsi:schemaLocation="http://www.osgi.org/xmlns/blueprint/v1.0.0
           http://www.osgi.org/xmlns/blueprint/v1.0.0/blueprint.xsd"&gt;

    &lt;!-- Using jetty bean just for the compatibility with other fuse services --&gt;
    &lt;bean id="servletConstraintMapping" class="org.eclipse.jetty.security.ConstraintMapping"&gt;
        &lt;property name="constraint"&gt;
            &lt;bean class="org.eclipse.jetty.util.security.Constraint"&gt;
                &lt;property name="name" value="cst1"/&gt;
                &lt;property name="roles"&gt;
                    &lt;list&gt;
                        &lt;value&gt;user&lt;/value&gt;
                    &lt;/list&gt;
                &lt;/property&gt;
                &lt;property name="authenticate" value="true"/&gt;
                &lt;property name="dataConstraint" value="0"/&gt;
            &lt;/bean&gt;
        &lt;/property&gt;
        &lt;property name="pathSpec" value="/product-portal/*"/&gt;
    &lt;/bean&gt;

    &lt;bean id="keycloakPaxWebIntegration" class="org.keycloak.adapters.osgi.PaxWebIntegrationService"
          init-method="start" destroy-method="stop"&gt;
        &lt;property name="jettyWebXmlLocation" value="/WEB-INF/jetty-web.xml" /&gt;
        &lt;property name="bundleContext" ref="blueprintBundleContext" /&gt;
        &lt;property name="constraintMappings"&gt;
            &lt;list&gt;
                &lt;ref component-id="servletConstraintMapping" /&gt;
            &lt;/list&gt;
        &lt;/property&gt;
    &lt;/bean&gt;

    &lt;bean id="productServlet" class="org.keycloak.example.ProductPortalServlet" depends-on="keycloakPaxWebIntegration"&gt;
    &lt;/bean&gt;

    &lt;service ref="productServlet" interface="javax.servlet.Servlet"&gt;
        &lt;service-properties&gt;
            &lt;entry key="alias" value="/product-portal" /&gt;
            &lt;entry key="servlet-name" value="ProductServlet" /&gt;
            &lt;entry key="keycloak.config.file" value="/keycloak.json" /&gt;
        &lt;/service-properties&gt;
    &lt;/service&gt;

&lt;/blueprint&gt;</pre><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">
										You might need to have the <code class="literal">WEB-INF</code> directory inside your project (even if your project is not a web application) and create the <code class="literal">/WEB-INF/jetty-web.xml</code> and <code class="literal">/WEB-INF/keycloak.json</code> files as in the <a class="link" href="#fuse_adapter_classic_war" title="2.1.4.3. Securing a Classic WAR Application">Classic WAR application</a> section. Note you don’t need the <code class="literal">web.xml</code> file as the security-constraints are declared in the blueprint configuration file.
									</li></ul></div></li><li class="listitem"><p class="simpara">
								The <code class="literal">Import-Package</code> in <code class="literal">META-INF/MANIFEST.MF</code> must contain at least these imports:
							</p><pre class="screen">org.keycloak.adapters.jetty;version="4.8.3.Final-redhat-00001",
org.keycloak.adapters;version="4.8.3.Final-redhat-00001",
org.keycloak.constants;version="4.8.3.Final-redhat-00001",
org.keycloak.util;version="4.8.3.Final-redhat-00001",
org.keycloak.*;version="4.8.3.Final-redhat-00001",
*;resolution:=optional</pre></li></ol></div></section><section class="section" id="securing_an_apache_camel_application"><div class="titlepage"><div><div><h4 class="title">2.1.4.5. Securing an Apache Camel Application</h4></div></div></div><p>
						You can secure Apache Camel endpoints implemented with the <a class="link" href="https://camel.apache.org/components/latest/jetty-component.html">camel-jetty</a> component by adding the securityHandler with <code class="literal">KeycloakJettyAuthenticator</code> and the proper security constraints injected. You can add the <code class="literal">OSGI-INF/blueprint/blueprint.xml</code> file to your Camel application with a similar configuration as below. The roles, security constraint mappings, and Red Hat Single Sign-On adapter configuration might differ slightly depending on your environment and needs.
					</p><p>
						For example:
					</p><pre class="programlisting language-xml">&lt;?xml version="1.0" encoding="UTF-8"?&gt;

&lt;blueprint xmlns="http://www.osgi.org/xmlns/blueprint/v1.0.0"
           xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
           xmlns:camel="http://camel.apache.org/schema/blueprint"
           xsi:schemaLocation="
       http://www.osgi.org/xmlns/blueprint/v1.0.0 http://www.osgi.org/xmlns/blueprint/v1.0.0/blueprint.xsd
       http://camel.apache.org/schema/blueprint http://camel.apache.org/schema/blueprint/camel-blueprint.xsd"&gt;

    &lt;bean id="kcAdapterConfig" class="org.keycloak.representations.adapters.config.AdapterConfig"&gt;
        &lt;property name="realm" value="demo"/&gt;
        &lt;property name="resource" value="admin-camel-endpoint"/&gt;
        &lt;property name="bearerOnly" value="true"/&gt;
        &lt;property name="authServerUrl" value="http://localhost:8080/auth" /&gt;
        &lt;property name="sslRequired" value="EXTERNAL"/&gt;
    &lt;/bean&gt;

    &lt;bean id="keycloakAuthenticator" class="org.keycloak.adapters.jetty.KeycloakJettyAuthenticator"&gt;
        &lt;property name="adapterConfig" ref="kcAdapterConfig"/&gt;
    &lt;/bean&gt;

    &lt;bean id="constraint" class="org.eclipse.jetty.util.security.Constraint"&gt;
        &lt;property name="name" value="Customers"/&gt;
        &lt;property name="roles"&gt;
            &lt;list&gt;
                &lt;value&gt;admin&lt;/value&gt;
            &lt;/list&gt;
        &lt;/property&gt;
        &lt;property name="authenticate" value="true"/&gt;
        &lt;property name="dataConstraint" value="0"/&gt;
    &lt;/bean&gt;

    &lt;bean id="constraintMapping" class="org.eclipse.jetty.security.ConstraintMapping"&gt;
        &lt;property name="constraint" ref="constraint"/&gt;
        &lt;property name="pathSpec" value="/*"/&gt;
    &lt;/bean&gt;

    &lt;bean id="securityHandler" class="org.eclipse.jetty.security.ConstraintSecurityHandler"&gt;
        &lt;property name="authenticator" ref="keycloakAuthenticator" /&gt;
        &lt;property name="constraintMappings"&gt;
            &lt;list&gt;
                &lt;ref component-id="constraintMapping" /&gt;
            &lt;/list&gt;
        &lt;/property&gt;
        &lt;property name="authMethod" value="BASIC"/&gt;
        &lt;property name="realmName" value="does-not-matter"/&gt;
    &lt;/bean&gt;

    &lt;bean id="sessionHandler" class="org.keycloak.adapters.jetty.spi.WrappingSessionHandler"&gt;
        &lt;property name="handler" ref="securityHandler" /&gt;
    &lt;/bean&gt;

    &lt;bean id="helloProcessor" class="org.keycloak.example.CamelHelloProcessor" /&gt;

    &lt;camelContext id="blueprintContext"
                  trace="false"
                  xmlns="http://camel.apache.org/schema/blueprint"&gt;
        &lt;route id="httpBridge"&gt;
            &lt;from uri="jetty:http://0.0.0.0:8383/admin-camel-endpoint?handlers=sessionHandler&amp;amp;matchOnUriPrefix=true" /&gt;
            &lt;process ref="helloProcessor" /&gt;
            &lt;log message="The message from camel endpoint contains ${body}"/&gt;
        &lt;/route&gt;
    &lt;/camelContext&gt;

&lt;/blueprint&gt;</pre><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">
								The <code class="literal">Import-Package</code> in <code class="literal">META-INF/MANIFEST.MF</code> needs to contain these imports:
							</li></ul></div><pre class="screen">javax.servlet;version="[3,4)",
javax.servlet.http;version="[3,4)",
org.apache.camel.*,
org.apache.camel;version="[2.13,3)",
org.eclipse.jetty.security;version="[9,10)",
org.eclipse.jetty.server.nio;version="[9,10)",
org.eclipse.jetty.util.security;version="[9,10)",
org.keycloak.*;version="4.8.3.Final-redhat-00001",
org.osgi.service.blueprint,
org.osgi.service.blueprint.container,
org.osgi.service.event,</pre></section><section class="section" id="camel_restdsl"><div class="titlepage"><div><div><h4 class="title">2.1.4.6. Camel RestDSL</h4></div></div></div><p>
						Camel RestDSL is a Camel feature used to define your REST endpoints in a fluent way. But you must still use specific implementation classes and provide instructions on how to integrate with Red Hat Single Sign-On.
					</p><p>
						The way to configure the integration mechanism depends on the Camel component for which you configure your RestDSL-defined routes.
					</p><p>
						The following example shows how to configure integration using the Jetty component, with references to some of the beans defined in previous Blueprint example.
					</p><pre class="programlisting language-xml">&lt;bean id="securityHandlerRest" class="org.eclipse.jetty.security.ConstraintSecurityHandler"&gt;
    &lt;property name="authenticator" ref="keycloakAuthenticator" /&gt;
    &lt;property name="constraintMappings"&gt;
        &lt;list&gt;
            &lt;ref component-id="constraintMapping" /&gt;
        &lt;/list&gt;
    &lt;/property&gt;
    &lt;property name="authMethod" value="BASIC"/&gt;
    &lt;property name="realmName" value="does-not-matter"/&gt;
&lt;/bean&gt;

&lt;bean id="sessionHandlerRest" class="org.keycloak.adapters.jetty.spi.WrappingSessionHandler"&gt;
    &lt;property name="handler" ref="securityHandlerRest" /&gt;
&lt;/bean&gt;


&lt;camelContext id="blueprintContext"
              trace="false"
              xmlns="http://camel.apache.org/schema/blueprint"&gt;

    &lt;restConfiguration component="jetty" contextPath="/restdsl"
                       port="8484"&gt;
        &lt;!--the link with Keycloak security handlers happens here--&gt;
        &lt;endpointProperty key="handlers" value="sessionHandlerRest"&gt;&lt;/endpointProperty&gt;
        &lt;endpointProperty key="matchOnUriPrefix" value="true"&gt;&lt;/endpointProperty&gt;
    &lt;/restConfiguration&gt;

    &lt;rest path="/hello" &gt;
        &lt;description&gt;Hello rest service&lt;/description&gt;
        &lt;get uri="/{id}" outType="java.lang.String"&gt;
            &lt;description&gt;Just an helllo&lt;/description&gt;
            &lt;to uri="direct:justDirect" /&gt;
        &lt;/get&gt;

    &lt;/rest&gt;

    &lt;route id="justDirect"&gt;
        &lt;from uri="direct:justDirect"/&gt;
        &lt;process ref="helloProcessor" /&gt;
        &lt;log message="RestDSL correctly invoked ${body}"/&gt;
        &lt;setBody&gt;
            &lt;constant&gt;(__This second sentence is returned from a Camel RestDSL endpoint__)&lt;/constant&gt;
        &lt;/setBody&gt;
    &lt;/route&gt;

&lt;/camelContext&gt;</pre></section><section class="section" id="fuse_adapter_cxf_separate"><div class="titlepage"><div><div><h4 class="title">2.1.4.7. Securing an Apache CXF Endpoint on a Separate Jetty Engine</h4></div></div></div><p>
						To run your CXF endpoints secured by Red Hat Single Sign-On on separate Jetty engines, complete the following steps:
					</p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p class="simpara">
								Add <code class="literal">META-INF/spring/beans.xml</code> to your application, and in it, declare <code class="literal">httpj:engine-factory</code> with Jetty SecurityHandler with injected <code class="literal">KeycloakJettyAuthenticator</code>. The configuration for a CFX JAX-WS application might resemble this one:
							</p><pre class="programlisting language-xml">&lt;?xml version="1.0" encoding="UTF-8"?&gt;

&lt;beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xmlns:jaxws="http://cxf.apache.org/jaxws"
       xmlns:httpj="http://cxf.apache.org/transports/http-jetty/configuration"
       xsi:schemaLocation="
        http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd
        http://cxf.apache.org/jaxws http://cxf.apache.org/schemas/jaxws.xsd
        http://www.springframework.org/schema/osgi http://www.springframework.org/schema/osgi/spring-osgi.xsd
        http://cxf.apache.org/transports/http-jetty/configuration http://cxf.apache.org/schemas/configuration/http-jetty.xsd"&gt;

    &lt;import resource="classpath:META-INF/cxf/cxf.xml" /&gt;

    &lt;bean id="kcAdapterConfig" class="org.keycloak.representations.adapters.config.AdapterConfig"&gt;
        &lt;property name="realm" value="demo"/&gt;
        &lt;property name="resource" value="custom-cxf-endpoint"/&gt;
        &lt;property name="bearerOnly" value="true"/&gt;
        &lt;property name="authServerUrl" value="http://localhost:8080/auth" /&gt;
        &lt;property name="sslRequired" value="EXTERNAL"/&gt;
    &lt;/bean&gt;

    &lt;bean id="keycloakAuthenticator" class="org.keycloak.adapters.jetty.KeycloakJettyAuthenticator"&gt;
        &lt;property name="adapterConfig"&gt;
            &lt;ref local="kcAdapterConfig" /&gt;
        &lt;/property&gt;
    &lt;/bean&gt;

    &lt;bean id="constraint" class="org.eclipse.jetty.util.security.Constraint"&gt;
        &lt;property name="name" value="Customers"/&gt;
        &lt;property name="roles"&gt;
            &lt;list&gt;
                &lt;value&gt;user&lt;/value&gt;
            &lt;/list&gt;
        &lt;/property&gt;
        &lt;property name="authenticate" value="true"/&gt;
        &lt;property name="dataConstraint" value="0"/&gt;
    &lt;/bean&gt;

    &lt;bean id="constraintMapping" class="org.eclipse.jetty.security.ConstraintMapping"&gt;
        &lt;property name="constraint" ref="constraint"/&gt;
        &lt;property name="pathSpec" value="/*"/&gt;
    &lt;/bean&gt;

    &lt;bean id="securityHandler" class="org.eclipse.jetty.security.ConstraintSecurityHandler"&gt;
        &lt;property name="authenticator" ref="keycloakAuthenticator" /&gt;
        &lt;property name="constraintMappings"&gt;
            &lt;list&gt;
                &lt;ref local="constraintMapping" /&gt;
            &lt;/list&gt;
        &lt;/property&gt;
        &lt;property name="authMethod" value="BASIC"/&gt;
        &lt;property name="realmName" value="does-not-matter"/&gt;
    &lt;/bean&gt;

    &lt;httpj:engine-factory bus="cxf" id="kc-cxf-endpoint"&gt;
        &lt;httpj:engine port="8282"&gt;
            &lt;httpj:handlers&gt;
                &lt;ref local="securityHandler" /&gt;
            &lt;/httpj:handlers&gt;
            &lt;httpj:sessionSupport&gt;true&lt;/httpj:sessionSupport&gt;
        &lt;/httpj:engine&gt;
    &lt;/httpj:engine-factory&gt;

    &lt;jaxws:endpoint
                    implementor="org.keycloak.example.ws.ProductImpl"
                    address="http://localhost:8282/ProductServiceCF" depends-on="kc-cxf-endpoint" /&gt;

&lt;/beans&gt;</pre><p class="simpara">
								For the CXF JAX-RS application, the only difference might be in the configuration of the endpoint dependent on engine-factory:
							</p><pre class="programlisting language-xml">&lt;jaxrs:server serviceClass="org.keycloak.example.rs.CustomerService" address="http://localhost:8282/rest"
    depends-on="kc-cxf-endpoint"&gt;
    &lt;jaxrs:providers&gt;
        &lt;bean class="com.fasterxml.jackson.jaxrs.json.JacksonJsonProvider" /&gt;
    &lt;/jaxrs:providers&gt;
&lt;/jaxrs:server&gt;</pre></li><li class="listitem">
								The <code class="literal">Import-Package</code> in <code class="literal">META-INF/MANIFEST.MF</code> must contain those imports:
							</li></ol></div><pre class="screen">META-INF.cxf;version="[2.7,3.2)",
META-INF.cxf.osgi;version="[2.7,3.2)";resolution:=optional,
org.apache.cxf.bus;version="[2.7,3.2)",
org.apache.cxf.bus.spring;version="[2.7,3.2)",
org.apache.cxf.bus.resource;version="[2.7,3.2)",
org.apache.cxf.transport.http;version="[2.7,3.2)",
org.apache.cxf.*;version="[2.7,3.2)",
org.springframework.beans.factory.config,
org.eclipse.jetty.security;version="[9,10)",
org.eclipse.jetty.util.security;version="[9,10)",
org.keycloak.*;version="4.8.3.Final-redhat-00001"</pre></section><section class="section" id="fuse_adapter_cxf_builtin"><div class="titlepage"><div><div><h4 class="title">2.1.4.8. Securing an Apache CXF Endpoint on the Default Jetty Engine</h4></div></div></div><p>
						Some services automatically come with deployed servlets on startup. One such service is the CXF servlet running in the http://localhost:8181/cxf context. Securing such endpoints can be complicated. One approach, which Red Hat Single Sign-On is currently using, is ServletReregistrationService, which undeploys a built-in servlet at startup, enabling you to redeploy it on a context secured by Red Hat Single Sign-On.
					</p><p>
						The configuration file <code class="literal">OSGI-INF/blueprint/blueprint.xml</code> inside your application might resemble the one below. Note that it adds the JAX-RS <code class="literal">customerservice</code> endpoint, which is endpoint-specific to your application, but more importantly, secures the entire <code class="literal">/cxf</code> context.
					</p><pre class="programlisting language-xml">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;blueprint xmlns="http://www.osgi.org/xmlns/blueprint/v1.0.0"
           xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
           xmlns:jaxrs="http://cxf.apache.org/blueprint/jaxrs"
           xsi:schemaLocation="
		http://www.osgi.org/xmlns/blueprint/v1.0.0 http://www.osgi.org/xmlns/blueprint/v1.0.0/blueprint.xsd
		http://cxf.apache.org/blueprint/jaxrs http://cxf.apache.org/schemas/blueprint/jaxrs.xsd"&gt;

    &lt;!-- JAXRS Application --&gt;

    &lt;bean id="customerBean" class="org.keycloak.example.rs.CxfCustomerService" /&gt;

    &lt;jaxrs:server id="cxfJaxrsServer" address="/customerservice"&gt;
        &lt;jaxrs:providers&gt;
            &lt;bean class="com.fasterxml.jackson.jaxrs.json.JacksonJsonProvider" /&gt;
        &lt;/jaxrs:providers&gt;
        &lt;jaxrs:serviceBeans&gt;
            &lt;ref component-id="customerBean" /&gt;
        &lt;/jaxrs:serviceBeans&gt;
    &lt;/jaxrs:server&gt;


    &lt;!-- Securing of whole /cxf context by unregister default cxf servlet from paxweb and re-register with applied security constraints --&gt;

    &lt;bean id="cxfConstraintMapping" class="org.eclipse.jetty.security.ConstraintMapping"&gt;
        &lt;property name="constraint"&gt;
            &lt;bean class="org.eclipse.jetty.util.security.Constraint"&gt;
                &lt;property name="name" value="cst1"/&gt;
                &lt;property name="roles"&gt;
                    &lt;list&gt;
                        &lt;value&gt;user&lt;/value&gt;
                    &lt;/list&gt;
                &lt;/property&gt;
                &lt;property name="authenticate" value="true"/&gt;
                &lt;property name="dataConstraint" value="0"/&gt;
            &lt;/bean&gt;
        &lt;/property&gt;
        &lt;property name="pathSpec" value="/cxf/*"/&gt;
    &lt;/bean&gt;

    &lt;bean id="cxfKeycloakPaxWebIntegration" class="org.keycloak.adapters.osgi.PaxWebIntegrationService"
          init-method="start" destroy-method="stop"&gt;
        &lt;property name="bundleContext" ref="blueprintBundleContext" /&gt;
        &lt;property name="jettyWebXmlLocation" value="/WEB-INF/jetty-web.xml" /&gt;
        &lt;property name="constraintMappings"&gt;
            &lt;list&gt;
                &lt;ref component-id="cxfConstraintMapping" /&gt;
            &lt;/list&gt;
        &lt;/property&gt;
    &lt;/bean&gt;

    &lt;bean id="defaultCxfReregistration" class="org.keycloak.adapters.osgi.ServletReregistrationService" depends-on="cxfKeycloakPaxWebIntegration"
          init-method="start" destroy-method="stop"&gt;
        &lt;property name="bundleContext" ref="blueprintBundleContext" /&gt;
        &lt;property name="managedServiceReference"&gt;
            &lt;reference interface="org.osgi.service.cm.ManagedService" filter="(service.pid=org.apache.cxf.osgi)" timeout="5000"  /&gt;
        &lt;/property&gt;
    &lt;/bean&gt;

&lt;/blueprint&gt;</pre><p>
						As a result, all other CXF services running on the default CXF HTTP destination are also secured. Similarly, when the application is undeployed, the entire <code class="literal">/cxf</code> context becomes unsecured as well. For this reason, using your own Jetty engine for your applications as described in <a class="link" href="#fuse_adapter_cxf_separate" title="2.1.4.7. Securing an Apache CXF Endpoint on a Separate Jetty Engine">Secure CXF Application on separate Jetty Engine</a> then gives you more control over security for each individual application.
					</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">
								The <code class="literal">WEB-INF</code> directory might need to be inside your project (even if your project is not a web application). You might also need to edit the <code class="literal">/WEB-INF/jetty-web.xml</code> and <code class="literal">/WEB-INF/keycloak.json</code> files in a similar way as in <a class="link" href="#fuse_adapter_classic_war" title="2.1.4.3. Securing a Classic WAR Application">Classic WAR application</a>. Note that you do not need the <code class="literal">web.xml</code> file as the security constraints are declared in the blueprint configuration file.
							</li><li class="listitem">
								The <code class="literal">Import-Package</code> in <code class="literal">META-INF/MANIFEST.MF</code> must contain these imports:
							</li></ul></div><pre class="screen">META-INF.cxf;version="[2.7,3.2)",
META-INF.cxf.osgi;version="[2.7,3.2)";resolution:=optional,
org.apache.cxf.transport.http;version="[2.7,3.2)",
org.apache.cxf.*;version="[2.7,3.2)",
com.fasterxml.jackson.jaxrs.json;version="[2.5,3)",
org.eclipse.jetty.security;version="[9,10)",
org.eclipse.jetty.util.security;version="[9,10)",
org.keycloak.*;version="4.8.3.Final-redhat-00001",
org.keycloak.adapters.jetty;version="4.8.3.Final-redhat-00001",
*;resolution:=optional</pre></section><section class="section" id="fuse_adapter_admin"><div class="titlepage"><div><div><h4 class="title">2.1.4.9. Securing Fuse Administration Services</h4></div></div></div><section class="section" id="using_ssh_authentication_to_fuse_terminal"><div class="titlepage"><div><div><h5 class="title">2.1.4.9.1. Using SSH Authentication to Fuse Terminal</h5></div></div></div><p>
							Red Hat Single Sign-On mainly addresses use cases for authentication of web applications; however, if your other web services and applications are protected with Red Hat Single Sign-On, protecting non-web administration services such as SSH with Red Hat Single Sign-On credentials is a best pracrice. You can do this using the JAAS login module, which allows remote connection to Red Hat Single Sign-On and verifies credentials based on <a class="link" href="#resource_owner_password_credentials_flow" title="2.4.3.3. Resource Owner Password Credentials">Resource Owner Password Credentials</a>.
						</p><p>
							To enable SSH authentication, complete the following steps:
						</p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem">
									In Red Hat Single Sign-On create a client (for example, <code class="literal">ssh-jmx-admin-client</code>), which will be used for SSH authentication. This client needs to have <code class="literal">Direct Access Grants Enabled</code> selected to <code class="literal">On</code>.
								</li><li class="listitem"><p class="simpara">
									In the <code class="literal">$FUSE_HOME/etc/org.apache.karaf.shell.cfg</code> file, update or specify this property:
								</p><pre class="screen">sshRealm=keycloak</pre></li><li class="listitem"><p class="simpara">
									Add the <code class="literal">$FUSE_HOME/etc/keycloak-direct-access.json</code> file with content similar to the following (based on your environment and Red Hat Single Sign-On client settings):
								</p><pre class="programlisting language-json">{
    "realm": "demo",
    "resource": "ssh-jmx-admin-client",
    "ssl-required" : "external",
    "auth-server-url" : "http://localhost:8080/auth",
    "credentials": {
        "secret": "password"
    }
}</pre><p class="simpara">
									This file specifies the client application configuration, which is used by JAAS DirectAccessGrantsLoginModule from the <code class="literal">keycloak</code> JAAS realm for SSH authentication.
								</p></li><li class="listitem"><p class="simpara">
									Start Fuse and install the <code class="literal">keycloak</code> JAAS realm. The easiest way is to install the <code class="literal">keycloak-jaas</code> feature, which has the JAAS realm predefined. You can override the feature’s predefined realm by using your own <code class="literal">keycloak</code> JAAS realm with higher ranking. For details see the <a class="link" href="https://access.redhat.com/documentation/en-us/red_hat_jboss_fuse/6.3/html-single/security_guide/#ESBSecureContainer">JBoss Fuse documentation</a>.
								</p><p class="simpara">
									Use these commands in the Fuse terminal:
								</p><pre class="screen">features:addurl mvn:org.keycloak/keycloak-osgi-features/4.8.3.Final-redhat-00001/xml/features
features:install keycloak-jaas</pre></li><li class="listitem"><p class="simpara">
									Log in using SSH as <code class="literal">admin</code> user by typing the following in the terminal:
								</p><pre class="screen">ssh -o PubkeyAuthentication=no -p 8101 admin@localhost</pre></li><li class="listitem">
									Log in with password <code class="literal">password</code>.
								</li></ol></div><div class="admonition note"><div class="admonition_header">Note</div><div><p>
								On some later operating systems, you might also need to use the SSH command’s -o option <code class="literal">-o HostKeyAlgorithms=+ssh-dss</code> because later SSH clients do not allow use of the <code class="literal">ssh-dss</code> algorithm, by default. However, by default, it is currently used in JBoss Fuse 6.3.0 Rollup 12.
							</p></div></div><p>
							Note that the user needs to have realm role <code class="literal">admin</code> to perform all operations or another role to perform a subset of operations (for example, the <span class="strong strong"><strong>viewer</strong></span> role that restricts the user to run only read-only Karaf commands). The available roles are configured in <code class="literal">$FUSE_HOME/etc/org.apache.karaf.shell.cfg</code> or <code class="literal">$FUSE_HOME/etc/system.properties</code>.
						</p></section><section class="section" id="using_jmx_authentication"><div class="titlepage"><div><div><h5 class="title">2.1.4.9.2. Using JMX Authentication</h5></div></div></div><p>
							JMX authentication might be necessary if you want to use jconsole or another external tool to remotely connect to JMX through RMI. Otherwise it might be better to use hawt.io/jolokia, since the jolokia agent is installed in hawt.io by default. For more details see <a class="link" href="#hawtio" title="2.1.4.10. Securing the Hawtio Administration Console">Hawtio Admin Console</a>.
						</p><p>
							To use JMX authentication, complete the following steps:
						</p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p class="simpara">
									In the <code class="literal">$FUSE_HOME/etc/org.apache.karaf.management.cfg</code> file, change the jmxRealm property to:
								</p><pre class="screen">jmxRealm=keycloak</pre></li><li class="listitem">
									Install the <code class="literal">keycloak-jaas</code> feature and configure the <code class="literal">$FUSE_HOME/etc/keycloak-direct-access.json</code> file as described in the SSH section above.
								</li><li class="listitem">
									In jconsole you can use a URL such as:
								</li></ol></div><pre class="screen">service:jmx:rmi://localhost:44444/jndi/rmi://localhost:1099/karaf-root</pre><p>
							and credentials: admin/password (based on the user with admin privileges according to your environment).
						</p></section></section><section class="section" id="hawtio"><div class="titlepage"><div><div><h4 class="title">2.1.4.10. Securing the Hawtio Administration Console</h4></div></div></div><p>
						To secure the Hawtio Administration Console with Red Hat Single Sign-On, complete the following steps:
					</p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p class="simpara">
								Add these properties to the <code class="literal">$FUSE_HOME/etc/system.properties</code> file:
							</p><pre class="screen">hawtio.keycloakEnabled=true
hawtio.realm=keycloak
hawtio.keycloakClientConfig=file://${karaf.base}/etc/keycloak-hawtio-client.json
hawtio.rolePrincipalClasses=org.keycloak.adapters.jaas.RolePrincipal,org.apache.karaf.jaas.boot.principal.RolePrincipal</pre></li><li class="listitem">
								Create a client in the Red Hat Single Sign-On administration console in your realm. For example, in the Red Hat Single Sign-On <code class="literal">demo</code> realm, create a client <code class="literal">hawtio-client</code>, specify <code class="literal">public</code> as the Access Type, and specify a redirect URI pointing to Hawtio: http://localhost:8181/hawtio/*. You must also have a corresponding Web Origin configured (in this case, http://localhost:8181).
							</li><li class="listitem"><p class="simpara">
								Create the <code class="literal">keycloak-hawtio-client.json</code> file in the <code class="literal">$FUSE_HOME/etc</code> directory using content similar to that shown in the example below. Change the <code class="literal">realm</code>, <code class="literal">resource</code>, and <code class="literal">auth-server-url</code> properties according to your Red Hat Single Sign-On environment. The <code class="literal">resource</code> property must point to the client created in the previous step. This file is used by the client (Hawtio JavaScript application) side.
							</p><pre class="programlisting language-json">{
  "realm" : "demo",
  "resource" : "hawtio-client",
  "auth-server-url" : "http://localhost:8080/auth",
  "ssl-required" : "external",
  "public-client" : true
}</pre></li><li class="listitem"><p class="simpara">
								Create the <code class="literal">keycloak-hawtio.json</code> file in the <code class="literal">$FUSE_HOME/etc</code> dicrectory using content similar to that shown in the example below. Change the <code class="literal">realm</code> and <code class="literal">auth-server-url</code> properties according to your Red Hat Single Sign-On environment. This file is used by the adapters on the server (JAAS Login module) side.
							</p><pre class="programlisting language-json">{
  "realm" : "demo",
  "resource" : "jaas",
  "bearer-only" : true,
  "auth-server-url" : "http://localhost:8080/auth",
  "ssl-required" : "external",
  "use-resource-role-mappings": false,
  "principal-attribute": "preferred_username"
}</pre></li><li class="listitem"><p class="simpara">
								Start JBoss Fuse 6.3.0 Rollup 12 and install the keycloak feature if you have not already done so. The commands in Karaf terminal are similar to this example:
							</p><pre class="screen">features:addurl mvn:org.keycloak/keycloak-osgi-features/4.8.3.Final-redhat-00001/xml/features
features:install keycloak</pre></li><li class="listitem"><p class="simpara">
								Go to <a class="link" href="http://localhost:8181/hawtio">http://localhost:8181/hawtio</a> and log in as a user from your Red Hat Single Sign-On realm.
							</p><p class="simpara">
								Note that the user needs to have the proper realm role to successfully authenticate to Hawtio. The available roles are configured in the <code class="literal">$FUSE_HOME/etc/system.properties</code> file in <code class="literal">hawtio.roles</code>.
							</p></li></ol></div><section class="section" id="securing_hawtio_on_jboss_eap_6_4"><div class="titlepage"><div><div><h5 class="title">2.1.4.10.1. Securing Hawtio on JBoss EAP 6.4</h5></div></div></div><p>
							To run Hawtio on the JBoss EAP 6.4 server, complete the following steps:
						</p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p class="simpara">
									Set up Red Hat Single Sign-On as described in the previous section, Securing the Hawtio Administration Console. It is assumed that:
								</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">
											you have a Red Hat Single Sign-On realm <code class="literal">demo</code> and client <code class="literal">hawtio-client</code>
										</li><li class="listitem">
											your Red Hat Single Sign-On is running on <code class="literal">localhost:8080</code>
										</li><li class="listitem">
											the JBoss EAP 6.4 server with deployed Hawtio will be running on <code class="literal">localhost:8181</code>. The directory with this server is referred in next steps as <code class="literal">$EAP_HOME</code>.
										</li></ul></div></li><li class="listitem">
									Copy the <code class="literal">hawtio-wildfly-1.4.0.redhat-630396.war</code> archive to the <code class="literal">$EAP_HOME/standalone/configuration</code> directory. For more details about deploying Hawtio see the <a class="link" href="https://access.redhat.com/documentation/en-us/red_hat_jboss_fuse/6.3/html-single/deploying_into_a_web_server/">Fuse Hawtio documentation</a>.
								</li><li class="listitem">
									Copy the <code class="literal">keycloak-hawtio.json</code> and <code class="literal">keycloak-hawtio-client.json</code> files with the above content to the <code class="literal">$EAP_HOME/standalone/configuration</code> directory.
								</li><li class="listitem">
									Install the Red Hat Single Sign-On adapter subsystem to your JBoss EAP 6.4 server as described in the <a class="link" href="#jboss_adapter" title="2.1.2. JBoss EAP Adapter">JBoss adapter documentation</a>.
								</li><li class="listitem"><p class="simpara">
									In the <code class="literal">$EAP_HOME/standalone/configuration/standalone.xml</code> file configure the system properties as in this example:
								</p><pre class="programlisting language-xml">&lt;extensions&gt;
...
&lt;/extensions&gt;

&lt;system-properties&gt;
    &lt;property name="hawtio.authenticationEnabled" value="true" /&gt;
    &lt;property name="hawtio.realm" value="hawtio" /&gt;
    &lt;property name="hawtio.roles" value="admin,viewer" /&gt;
    &lt;property name="hawtio.rolePrincipalClasses" value="org.keycloak.adapters.jaas.RolePrincipal" /&gt;
    &lt;property name="hawtio.keycloakEnabled" value="true" /&gt;
    &lt;property name="hawtio.keycloakClientConfig" value="${jboss.server.config.dir}/keycloak-hawtio-client.json" /&gt;
    &lt;property name="hawtio.keycloakServerConfig" value="${jboss.server.config.dir}/keycloak-hawtio.json" /&gt;
&lt;/system-properties&gt;</pre></li><li class="listitem"><p class="simpara">
									Add the Hawtio realm to the same file in the <code class="literal">security-domains</code> section:
								</p><pre class="programlisting language-xml">&lt;security-domain name="hawtio" cache-type="default"&gt;
    &lt;authentication&gt;
        &lt;login-module code="org.keycloak.adapters.jaas.BearerTokenLoginModule" flag="required"&gt;
            &lt;module-option name="keycloak-config-file" value="${hawtio.keycloakServerConfig}"/&gt;
        &lt;/login-module&gt;
    &lt;/authentication&gt;
&lt;/security-domain&gt;</pre></li><li class="listitem"><p class="simpara">
									Add the <code class="literal">secure-deployment</code> section <code class="literal">hawtio</code> to the adapter subsystem. This ensures that the Hawtio WAR is able to find the JAAS login module classes.
								</p><pre class="programlisting language-xml">&lt;subsystem xmlns="urn:jboss:domain:keycloak:1.1"&gt;
    &lt;secure-deployment name="hawtio-wildfly-1.4.0.redhat-630396.war" /&gt;
&lt;/subsystem&gt;</pre></li><li class="listitem"><p class="simpara">
									Restart the JBoss EAP 6.4 server with Hawtio:
								</p><pre class="programlisting language-bash">cd $EAP_HOME/bin
./standalone.sh -Djboss.socket.binding.port-offset=101</pre></li><li class="listitem">
									Access Hawtio at <a class="link" href="http://localhost:8181/hawtio">http://localhost:8181/hawtio</a>. It is secured by Red Hat Single Sign-On.
								</li></ol></div></section></section></section><section class="section" id="fuse7_adapter"><div class="titlepage"><div><div><h3 class="title">2.1.5. JBoss Fuse 7 Adapter</h3></div></div></div><p>
					Red Hat Single Sign-On supports securing your web applications running inside <a class="link" href="https://developers.redhat.com/products/fuse/overview">JBoss Fuse 7</a>.
				</p><p>
					JBoss Fuse 7 leverages Undertow adapter which is essentially the same as <a class="link" href="#jboss_adapter" title="2.1.2. JBoss EAP Adapter">JBoss EAP 7 Adapter</a> as JBoss Fuse 7.4.0 is bundled with <a class="link" href="http://undertow.io/">Undertow HTTP engine</a> under the covers and Undertow is used for running various kinds of web applications.
				</p><div class="admonition warning"><div class="admonition_header">Warning</div><div><p>
						The only supported version of Fuse 7 is the latest release. If you use earlier versions of Fuse 7, it is possible that some functions will not work correctly. In particular, integration will not work at all for versions of Fuse 7 lower than 7.0.1.
					</p></div></div><p>
					Security for the following items is supported for Fuse:
				</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">
							Classic WAR applications deployed on Fuse with Pax Web War Extender
						</li><li class="listitem">
							Servlets deployed on Fuse as OSGI services with Pax Web Whiteboard Extender and additionally servlets registered through org.osgi.service.http.HttpService#registerServlet() which is standard OSGi Enterprise HTTP Service
						</li><li class="listitem">
							<a class="link" href="https://camel.apache.org/">Apache Camel</a> Undertow endpoints running with the <a class="link" href="https://camel.apache.org/components/latest/undertow-component.html">Camel Undertow</a> component
						</li><li class="listitem">
							<a class="link" href="https://cxf.apache.org/">Apache CXF</a> endpoints running on their own separate Undertow engine
						</li><li class="listitem">
							<a class="link" href="https://cxf.apache.org/">Apache CXF</a> endpoints running on the default engine provided by the CXF servlet
						</li><li class="listitem">
							SSH and JMX admin access
						</li><li class="listitem">
							<a class="link" href="https://hawt.io/">Hawtio administration console</a>
						</li></ul></div><section class="section" id="securing_your_web_applications_inside_fuse_7"><div class="titlepage"><div><div><h4 class="title">2.1.5.1. Securing Your Web Applications Inside Fuse 7</h4></div></div></div><p>
						You must first install the Red Hat Single Sign-On Karaf feature. Next you will need to perform the steps according to the type of application you want to secure. All referenced web applications require injecting the Red Hat Single Sign-On Undertow authentication mechanism into the underlying web server. The steps to achieve this depend on the application type. The details are described below.
					</p></section><section class="section" id="fuse7_install_feature"><div class="titlepage"><div><div><h4 class="title">2.1.5.2. Installing the Keycloak Feature</h4></div></div></div><p>
						You must first install the <code class="literal">keycloak-pax-http-undertow</code> and <code class="literal">keycloak-jaas</code> features in the JBoss Fuse environment. The <code class="literal">keycloak-pax-http-undertow</code> feature includes the Fuse adapter and all third-party dependencies. The <code class="literal">keycloak-jaas</code> contains JAAS module used in realm for SSH and JMX authentication. You can install it either from the Maven repository or from an archive.
					</p><section class="section" id="installing_from_the_maven_repository_2"><div class="titlepage"><div><div><h5 class="title">2.1.5.2.1. Installing from the Maven Repository</h5></div></div></div><p>
							As a prerequisite, you must be online and have access to the Maven repository.
						</p><p>
							For Red Hat Single Sign-On you first need to configure a proper Maven repository, so you can install the artifacts. For more information see the <a class="link" href="https://access.redhat.com/maven-repository">JBoss Enterprise Maven repository</a> page.
						</p><p>
							Assuming the Maven repository is <a class="link" href="https://maven.repository.redhat.com/ga/">https://maven.repository.redhat.com/ga/</a>, add the following to the <code class="literal">$FUSE_HOME/etc/org.ops4j.pax.url.mvn.cfg</code> file and add the repository to the list of supported repositories. For example:
						</p><pre class="screen">config:edit org.ops4j.pax.url.mvn
config:property-append org.ops4j.pax.url.mvn.repositories ,https://maven.repository.redhat.com/ga/@id=redhat.product.repo
config:update

feature:repo-refresh</pre><p>
							To install the keycloak feature using the Maven repository, complete the following steps:
						</p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p class="simpara">
									Start JBoss Fuse 7.4.0; then in the Karaf terminal type:
								</p><pre class="screen">feature:repo-add mvn:org.keycloak/keycloak-osgi-features/4.8.3.Final-redhat-00001/xml/features
feature:install keycloak-pax-http-undertow keycloak-jaas</pre></li><li class="listitem"><p class="simpara">
									You might also need to install the Undertow feature:
								</p><pre class="screen">feature:install pax-http-undertow</pre></li><li class="listitem">
									Ensure that the features were installed:
								</li></ol></div><pre class="screen">feature:list | grep keycloak</pre></section><section class="section" id="installing_from_the_zip_bundle_2"><div class="titlepage"><div><div><h5 class="title">2.1.5.2.2. Installing from the ZIP bundle</h5></div></div></div><p>
							This is useful if you are offline or do not want to use Maven to obtain the JAR files and other artifacts.
						</p><p>
							To install the Fuse adapter from the ZIP archive, complete the following steps:
						</p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem">
									Download the Red Hat Single Sign-On Fuse adapter ZIP archive.
								</li><li class="listitem"><p class="simpara">
									Unzip it into the root directory of JBoss Fuse. The dependencies are then installed under the <code class="literal">system</code> directory. You can overwrite all existing jar files.
								</p><p class="simpara">
									Use this for JBoss Fuse 7.4.0:
								</p><pre class="screen">cd /path-to-fuse/fuse-karaf-7.z
unzip -q /path-to-adapter-zip/rh-sso-7.4.0.GA-fuse-adapter.zip</pre></li><li class="listitem"><p class="simpara">
									Start Fuse and run these commands in the fuse/karaf terminal:
								</p><pre class="screen">feature:repo-add mvn:org.keycloak/keycloak-osgi-features/4.8.3.Final-redhat-00001/xml/features
feature:install keycloak-pax-http-undertow keycloak-jaas</pre></li><li class="listitem">
									Install the corresponding Undertow adapter. Since the artifacts are available directly in the JBoss Fuse <code class="literal">system</code> directory, you do not need to use the Maven repository.
								</li></ol></div></section></section><section class="section" id="fuse7_adapter_classic_war"><div class="titlepage"><div><div><h4 class="title">2.1.5.3. Securing a Classic WAR Application</h4></div></div></div><p>
						The needed steps to secure your WAR application are:
					</p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p class="simpara">
								In the <code class="literal">/WEB-INF/web.xml</code> file, declare the necessary:
							</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">
										security constraints in the &lt;security-constraint&gt; element
									</li><li class="listitem">
										login configuration in the &lt;login-config&gt; element. Make sure that the <code class="literal">&lt;auth-method&gt;</code> is <code class="literal">KEYCLOAK</code>.
									</li><li class="listitem"><p class="simpara">
										security roles in the &lt;security-role&gt; element
									</p><p class="simpara">
										For example:
									</p><pre class="programlisting language-xml">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;web-app xmlns="http://java.sun.com/xml/ns/javaee"
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/web-app_3_0.xsd"
         version="3.0"&gt;

    &lt;module-name&gt;customer-portal&lt;/module-name&gt;

    &lt;welcome-file-list&gt;
        &lt;welcome-file&gt;index.html&lt;/welcome-file&gt;
    &lt;/welcome-file-list&gt;

    &lt;security-constraint&gt;
        &lt;web-resource-collection&gt;
            &lt;web-resource-name&gt;Customers&lt;/web-resource-name&gt;
            &lt;url-pattern&gt;/customers/*&lt;/url-pattern&gt;
        &lt;/web-resource-collection&gt;
        &lt;auth-constraint&gt;
            &lt;role-name&gt;user&lt;/role-name&gt;
        &lt;/auth-constraint&gt;
    &lt;/security-constraint&gt;

    &lt;login-config&gt;
        &lt;auth-method&gt;KEYCLOAK&lt;/auth-method&gt;
        &lt;realm-name&gt;does-not-matter&lt;/realm-name&gt;
    &lt;/login-config&gt;

    &lt;security-role&gt;
        &lt;role-name&gt;admin&lt;/role-name&gt;
    &lt;/security-role&gt;
    &lt;security-role&gt;
        &lt;role-name&gt;user&lt;/role-name&gt;
    &lt;/security-role&gt;
&lt;/web-app&gt;</pre></li></ul></div></li><li class="listitem"><p class="simpara">
								Within the <code class="literal">/WEB-INF/</code> directory of your WAR, create a new file, keycloak.json. The format of this configuration file is described in the <a class="link" href="#java_adapter_config" title="2.1.1. Java Adapter Config">Java Adapters Config</a> section. It is also possible to make this file available externally as described in <a class="link" href="#config_external_adapter" title="2.1.4.3.1. Configuring the External Adapter">Configuring the External Adapter</a>.
							</p><p class="simpara">
								For example:
							</p><pre class="programlisting language-json">{
    "realm": "demo",
    "resource": "customer-portal",
    "auth-server-url": "http://localhost:8080/auth",
    "ssl-required" : "external",
    "credentials": {
        "secret": "password"
    }
}</pre></li><li class="listitem">
								Contrary to the Fuse 6 adapter, there are no special OSGi imports needed in MANIFEST.MF.
							</li></ol></div><section class="section" id="fuse7_config_external_adapter"><div class="titlepage"><div><div><h5 class="title">2.1.5.3.1. Configuration Resolvers</h5></div></div></div><p>
							The <code class="literal">keycloak.json</code> adapter configuration file can be stored inside a bundle, which is default behaviour, or in a directory on a filesystem. To specify the actual source of the configuration file, set the <code class="literal">keycloak.config.resolver</code> deployment parameter to the desired configuration resolver class. For example, in a classic WAR application, set the <code class="literal">keycloak.config.resolver</code> context parameter in <code class="literal">web.xml</code> file like this:
						</p><pre class="programlisting language-xml">&lt;context-param&gt;
    &lt;param-name&gt;keycloak.config.resolver&lt;/param-name&gt;
    &lt;param-value&gt;org.keycloak.adapters.osgi.PathBasedKeycloakConfigResolver&lt;/param-value&gt;
&lt;/context-param&gt;</pre><p>
							The following resolvers are available for <code class="literal">keycloak.config.resolver</code>:
						</p><div class="variablelist"><dl class="variablelist"><dt><span class="term">org.keycloak.adapters.osgi.BundleBasedKeycloakConfigResolver</span></dt><dd>
										This is the default resolver. The configuration file is expected inside the OSGi bundle that is being secured. By default, it loads file named <code class="literal">WEB-INF/keycloak.json</code> but this file name can be configured via <code class="literal">configLocation</code> property.
									</dd><dt><span class="term">org.keycloak.adapters.osgi.PathBasedKeycloakConfigResolver</span></dt><dd><p class="simpara">
										This resolver searches for a file called <code class="literal">&lt;your_web_context&gt;-keycloak.json</code> inside a folder that is specified by <code class="literal">keycloak.config</code> system property. If <code class="literal">keycloak.config</code> is not set, <code class="literal">karaf.etc</code> system property is used instead.
									</p><p class="simpara">
										For example, if your web application is deployed into context <code class="literal">my-portal</code>, then your adapter configuration would be loaded either from the <code class="literal">${keycloak.config}/my-portal-keycloak.json</code> file, or from <code class="literal">${karaf.etc}/my-portal-keycloak.json</code>.
									</p></dd><dt><span class="term">org.keycloak.adapters.osgi.HierarchicalPathBasedKeycloakConfigResolver</span></dt><dd><p class="simpara">
										This resolver is similar to <code class="literal">PathBasedKeycloakConfigResolver</code> above, where for given URI path, configuration locations are checked from most to least specific.
									</p><p class="simpara">
										For example, for <code class="literal">/my/web-app/context</code> URI, the following configuration locations are searched for existence until the first one exists:
									</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">
												<code class="literal">${karaf.etc}/my-web-app-context-keycloak.json</code>
											</li><li class="listitem">
												<code class="literal">${karaf.etc}/my-web-app-keycloak.json</code>
											</li><li class="listitem">
												<code class="literal">${karaf.etc}/my-keycloak.json</code>
											</li><li class="listitem">
												<code class="literal">${karaf.etc}/keycloak.json</code>
											</li></ul></div></dd></dl></div></section></section><section class="section" id="fuse7_adapter_servlet_whiteboard"><div class="titlepage"><div><div><h4 class="title">2.1.5.4. Securing a Servlet Deployed as an OSGI Service</h4></div></div></div><p>
						You can use this method if you have a servlet class inside your OSGI bundled project that is not deployed as a classic WAR application. Fuse uses Pax Web Whiteboard Extender to deploy such servlets as web applications.
					</p><p>
						To secure your servlet with Red Hat Single Sign-On, complete the following steps:
					</p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p class="simpara">
								Red Hat Single Sign-On provides <code class="literal">org.keycloak.adapters.osgi.undertow.PaxWebIntegrationService</code>, which allows configuring authentication method and security constraints for your application. You need to declare such services in the <code class="literal">OSGI-INF/blueprint/blueprint.xml</code> file inside your application. Note that your servlet needs to depend on it. An example configuration:
							</p><pre class="programlisting language-xml">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;blueprint xmlns="http://www.osgi.org/xmlns/blueprint/v1.0.0"
           xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
           xsi:schemaLocation="http://www.osgi.org/xmlns/blueprint/v1.0.0 http://www.osgi.org/xmlns/blueprint/v1.0.0/blueprint.xsd"&gt;

    &lt;bean id="servletConstraintMapping" class="org.keycloak.adapters.osgi.PaxWebSecurityConstraintMapping"&gt;
        &lt;property name="roles"&gt;
            &lt;list&gt;
                &lt;value&gt;user&lt;/value&gt;
            &lt;/list&gt;
        &lt;/property&gt;
        &lt;property name="authentication" value="true"/&gt;
        &lt;property name="url" value="/product-portal/*"/&gt;
    &lt;/bean&gt;

    &lt;!-- This handles the integration and setting the login-config and security-constraints parameters --&gt;
    &lt;bean id="keycloakPaxWebIntegration" class="org.keycloak.adapters.osgi.undertow.PaxWebIntegrationService"
          init-method="start" destroy-method="stop"&gt;
        &lt;property name="bundleContext" ref="blueprintBundleContext" /&gt;
        &lt;property name="constraintMappings"&gt;
            &lt;list&gt;
                &lt;ref component-id="servletConstraintMapping" /&gt;
            &lt;/list&gt;
        &lt;/property&gt;
    &lt;/bean&gt;

    &lt;bean id="productServlet" class="org.keycloak.example.ProductPortalServlet" depends-on="keycloakPaxWebIntegration" /&gt;

    &lt;service ref="productServlet" interface="javax.servlet.Servlet"&gt;
        &lt;service-properties&gt;
            &lt;entry key="alias" value="/product-portal" /&gt;
            &lt;entry key="servlet-name" value="ProductServlet" /&gt;
            &lt;entry key="keycloak.config.file" value="/keycloak.json" /&gt;
        &lt;/service-properties&gt;
    &lt;/service&gt;
&lt;/blueprint&gt;</pre><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">
										You might need to have the <code class="literal">WEB-INF</code> directory inside your project (even if your project is not a web application) and create the <code class="literal">/WEB-INF/keycloak.json</code> file as described in the <a class="link" href="#fuse7_adapter_classic_war" title="2.1.5.3. Securing a Classic WAR Application">Classic WAR application</a> section. Note you don’t need the <code class="literal">web.xml</code> file as the security-constraints are declared in the blueprint configuration file.
									</li></ul></div></li><li class="listitem">
								Contrary to the Fuse 6 adapter, there are no special OSGi imports needed in MANIFEST.MF.
							</li></ol></div></section><section class="section" id="fuse7_adapter_camel"><div class="titlepage"><div><div><h4 class="title">2.1.5.5. Securing an Apache Camel Application</h4></div></div></div><p>
						You can secure Apache Camel endpoints implemented with the <a class="link" href="https://camel.apache.org/components/latest/undertow-component.html">camel-undertow</a> component by injecting the proper security constraints via blueprint and updating the used component to <code class="literal">undertow-keycloak</code>. You have to add the <code class="literal">OSGI-INF/blueprint/blueprint.xml</code> file to your Camel application with a similar configuration as below. The roles, security constraint mappings, and adapter configuration might differ slightly depending on your environment and needs.
					</p><p>
						Compared to the standard <code class="literal">undertow</code> component, <code class="literal">undertow-keycloak</code> component adds two new properties:
					</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">
								<code class="literal">configResolver</code> is a resolver bean that supplies Red Hat Single Sign-On adapter configuration. Available resolvers are listed in <a class="link" href="#fuse7_config_external_adapter" title="2.1.5.3.1. Configuration Resolvers">Configuration Resolvers</a> section.
							</li><li class="listitem">
								<code class="literal">allowedRoles</code> is a comma-separated list of roles. User accessing the service has to have at least one role to be permitted the access.
							</li></ul></div><p>
						For example:
					</p><pre class="programlisting language-xml">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;blueprint xmlns="http://www.osgi.org/xmlns/blueprint/v1.0.0"
           xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
           xmlns:camel="http://camel.apache.org/schema/blueprint"
           xsi:schemaLocation="
       http://www.osgi.org/xmlns/blueprint/v1.0.0 http://www.osgi.org/xmlns/blueprint/v1.0.0/blueprint.xsd
       http://camel.apache.org/schema/blueprint http://camel.apache.org/schema/blueprint/camel-blueprint-2.17.1.xsd"&gt;

    &lt;bean id="keycloakConfigResolver" class="org.keycloak.adapters.osgi.BundleBasedKeycloakConfigResolver" &gt;
        &lt;property name="bundleContext" ref="blueprintBundleContext" /&gt;
    &lt;/bean&gt;

    &lt;bean id="helloProcessor" class="org.keycloak.example.CamelHelloProcessor" /&gt;

    &lt;camelContext id="blueprintContext"
                  trace="false"
                  xmlns="http://camel.apache.org/schema/blueprint"&gt;

        &lt;route id="httpBridge"&gt;
            &lt;from uri="undertow-keycloak:http://0.0.0.0:8383/admin-camel-endpoint?matchOnUriPrefix=true&amp;amp;configResolver=#keycloakConfigResolver&amp;amp;allowedRoles=admin" /&gt;
            &lt;process ref="helloProcessor" /&gt;
            &lt;log message="The message from camel endpoint contains ${body}"/&gt;
        &lt;/route&gt;

    &lt;/camelContext&gt;

&lt;/blueprint&gt;</pre><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">
								The <code class="literal">Import-Package</code> in <code class="literal">META-INF/MANIFEST.MF</code> needs to contain these imports:
							</li></ul></div><pre class="screen">javax.servlet;version="[3,4)",
javax.servlet.http;version="[3,4)",
javax.net.ssl,
org.apache.camel.*,
org.apache.camel;version="[2.13,3)",
io.undertow.*,
org.keycloak.*;version="4.8.3.Final-redhat-00001",
org.osgi.service.blueprint,
org.osgi.service.blueprint.container</pre></section><section class="section" id="camel_restdsl_2"><div class="titlepage"><div><div><h4 class="title">2.1.5.6. Camel RestDSL</h4></div></div></div><p>
						Camel RestDSL is a Camel feature used to define your REST endpoints in a fluent way. But you must still use specific implementation classes and provide instructions on how to integrate with Red Hat Single Sign-On.
					</p><p>
						The way to configure the integration mechanism depends on the Camel component for which you configure your RestDSL-defined routes.
					</p><p>
						The following example shows how to configure integration using the <code class="literal">undertow-keycloak</code> component, with references to some of the beans defined in previous Blueprint example.
					</p><pre class="programlisting language-xml">&lt;camelContext id="blueprintContext"
              trace="false"
              xmlns="http://camel.apache.org/schema/blueprint"&gt;

    &lt;!--the link with Keycloak security handlers happens by using undertow-keycloak component --&gt;
    &lt;restConfiguration apiComponent="undertow-keycloak" contextPath="/restdsl" port="8484"&gt;
        &lt;endpointProperty key="configResolver" value="#keycloakConfigResolver" /&gt;
        &lt;endpointProperty key="allowedRoles" value="admin,superadmin" /&gt;
    &lt;/restConfiguration&gt;

    &lt;rest path="/hello" &gt;
        &lt;description&gt;Hello rest service&lt;/description&gt;
        &lt;get uri="/{id}" outType="java.lang.String"&gt;
            &lt;description&gt;Just a hello&lt;/description&gt;
            &lt;to uri="direct:justDirect" /&gt;
        &lt;/get&gt;

    &lt;/rest&gt;

    &lt;route id="justDirect"&gt;
        &lt;from uri="direct:justDirect"/&gt;
        &lt;process ref="helloProcessor" /&gt;
        &lt;log message="RestDSL correctly invoked ${body}"/&gt;
        &lt;setBody&gt;
            &lt;constant&gt;(__This second sentence is returned from a Camel RestDSL endpoint__)&lt;/constant&gt;
        &lt;/setBody&gt;
    &lt;/route&gt;

&lt;/camelContext&gt;</pre></section><section class="section" id="fuse7_adapter_cxf_separate"><div class="titlepage"><div><div><h4 class="title">2.1.5.7. Securing an Apache CXF Endpoint on a Separate Undertow Engine</h4></div></div></div><p>
						To run your CXF endpoints secured by Red Hat Single Sign-On on a separate Undertow engine, complete the following steps:
					</p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p class="simpara">
								Add <code class="literal">OSGI-INF/blueprint/blueprint.xml</code> to your application, and in it, add the proper configuration resolver bean similarly to <a class="link" href="#fuse7_adapter_camel" title="2.1.5.5. Securing an Apache Camel Application">Camel configuration</a>. In the <code class="literal">httpu:engine-factory</code> declare <code class="literal">org.keycloak.adapters.osgi.undertow.CxfKeycloakAuthHandler</code> handler using that camel configuration. The configuration for a CFX JAX-WS application might resemble this one:
							</p><pre class="programlisting language-xml">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;blueprint xmlns="http://www.osgi.org/xmlns/blueprint/v1.0.0"
           xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
           xmlns:jaxws="http://cxf.apache.org/blueprint/jaxws"
           xmlns:cxf="http://cxf.apache.org/blueprint/core"
           xmlns:httpu="http://cxf.apache.org/transports/http-undertow/configuration".
           xsi:schemaLocation="
      http://cxf.apache.org/transports/http-undertow/configuration http://cxf.apache.org/schemas/configuration/http-undertow.xsd
      http://cxf.apache.org/blueprint/core http://cxf.apache.org/schemas/blueprint/core.xsd
      http://cxf.apache.org/blueprint/jaxws http://cxf.apache.org/schemas/blueprint/jaxws.xsd"&gt;

    &lt;bean id="keycloakConfigResolver" class="org.keycloak.adapters.osgi.BundleBasedKeycloakConfigResolver" &gt;
        &lt;property name="bundleContext" ref="blueprintBundleContext" /&gt;
    &lt;/bean&gt;

    &lt;httpu:engine-factory bus="cxf" id="kc-cxf-endpoint"&gt;
        &lt;httpu:engine port="8282"&gt;
            &lt;httpu:handlers&gt;
                &lt;bean class="org.keycloak.adapters.osgi.undertow.CxfKeycloakAuthHandler"&gt;
                    &lt;property name="configResolver" ref="keycloakConfigResolver" /&gt;
                &lt;/bean&gt;
            &lt;/httpu:handlers&gt;
        &lt;/httpu:engine&gt;
    &lt;/httpu:engine-factory&gt;

    &lt;jaxws:endpoint implementor="org.keycloak.example.ws.ProductImpl"
                    address="http://localhost:8282/ProductServiceCF" depends-on="kc-cxf-endpoint"/&gt;

&lt;/blueprint&gt;</pre><p class="simpara">
								For the CXF JAX-RS application, the only difference might be in the configuration of the endpoint dependent on engine-factory:
							</p><pre class="programlisting language-xml">&lt;jaxrs:server serviceClass="org.keycloak.example.rs.CustomerService" address="http://localhost:8282/rest"
    depends-on="kc-cxf-endpoint"&gt;
    &lt;jaxrs:providers&gt;
        &lt;bean class="com.fasterxml.jackson.jaxrs.json.JacksonJsonProvider" /&gt;
    &lt;/jaxrs:providers&gt;
&lt;/jaxrs:server&gt;</pre></li><li class="listitem">
								The <code class="literal">Import-Package</code> in <code class="literal">META-INF/MANIFEST.MF</code> must contain those imports:
							</li></ol></div><pre class="screen">META-INF.cxf;version="[2.7,3.3)",
META-INF.cxf.osgi;version="[2.7,3.3)";resolution:=optional,
org.apache.cxf.bus;version="[2.7,3.3)",
org.apache.cxf.bus.spring;version="[2.7,3.3)",
org.apache.cxf.bus.resource;version="[2.7,3.3)",
org.apache.cxf.transport.http;version="[2.7,3.3)",
org.apache.cxf.*;version="[2.7,3.3)",
org.springframework.beans.factory.config,
org.keycloak.*;version="4.8.3.Final-redhat-00001"</pre></section><section class="section" id="fuse7_adapter_cxf_builtin"><div class="titlepage"><div><div><h4 class="title">2.1.5.8. Securing an Apache CXF Endpoint on the Default Undertow Engine</h4></div></div></div><p>
						Some services automatically come with deployed servlets on startup. One such service is the CXF servlet running in the http://localhost:8181/cxf context. Fuse’s Pax Web supports altering existing contexts via configuration admin. This can be used to secure endpoints by Red Hat Single Sign-On.
					</p><p>
						The configuration file <code class="literal">OSGI-INF/blueprint/blueprint.xml</code> inside your application might resemble the one below. Note that it adds the JAX-RS <code class="literal">customerservice</code> endpoint, which is endpoint-specific to your application.
					</p><pre class="programlisting language-xml">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;blueprint xmlns="http://www.osgi.org/xmlns/blueprint/v1.0.0"
           xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
           xmlns:jaxrs="http://cxf.apache.org/blueprint/jaxrs"
           xsi:schemaLocation="
		http://www.osgi.org/xmlns/blueprint/v1.0.0 http://www.osgi.org/xmlns/blueprint/v1.0.0/blueprint.xsd
		http://cxf.apache.org/blueprint/jaxrs http://cxf.apache.org/schemas/blueprint/jaxrs.xsd"&gt;

    &lt;!-- JAXRS Application --&gt;
    &lt;bean id="customerBean" class="org.keycloak.example.rs.CxfCustomerService" /&gt;

    &lt;jaxrs:server id="cxfJaxrsServer" address="/customerservice"&gt;
        &lt;jaxrs:providers&gt;
            &lt;bean class="com.fasterxml.jackson.jaxrs.json.JacksonJsonProvider" /&gt;
        &lt;/jaxrs:providers&gt;
        &lt;jaxrs:serviceBeans&gt;
            &lt;ref component-id="customerBean" /&gt;
        &lt;/jaxrs:serviceBeans&gt;
    &lt;/jaxrs:server&gt;
&lt;/blueprint&gt;</pre><p>
						Furthermore, you have to create <code class="literal">${karaf.etc}/org.ops4j.pax.web.context-<span class="emphasis"><em>anyName</em></span>.cfg file</code>. It will be treated as factory PID configuration that is tracked by <code class="literal">pax-web-runtime</code> bundle. Such configuration may contain the following properties that correspond to some of the properties of standard <code class="literal">web.xml</code>:
					</p><pre class="screen">bundle.symbolicName = org.apache.cxf.cxf-rt-transports-http
context.id = default

context.param.keycloak.config.resolver = org.keycloak.adapters.osgi.HierarchicalPathBasedKeycloakConfigResolver

login.config.authMethod = KEYCLOAK

security.cxf.url = /cxf/customerservice/*
security.cxf.roles = admin, user</pre><p>
						For full description of available properties in configuration admin file, please refer to Fuse documentation. The properties above have the following meaning:
					</p><div class="variablelist"><dl class="variablelist"><dt><span class="term"><code class="literal">bundle.symbolicName</code> and <code class="literal">context.id</code></span></dt><dd>
									Identification of the bundle and its deployment context within <code class="literal">org.ops4j.pax.web.service.WebContainer</code>.
								</dd><dt><span class="term"><code class="literal">context.param.keycloak.config.resolver</code></span></dt><dd>
									Provides value of <code class="literal">keycloak.config.resolver</code> context parameter to the bundle just the same as in <code class="literal">web.xml</code> for classic WARs. Available resolvers are described in <a class="link" href="#fuse7_config_external_adapter" title="2.1.5.3.1. Configuration Resolvers">Configuration Resolvers</a> section.
								</dd><dt><span class="term"><code class="literal">login.config.authMethod</code></span></dt><dd>
									Authentication method. Must be <code class="literal">KEYCLOAK</code>.
								</dd><dt><span class="term"><code class="literal">security.<span class="emphasis"><em>anyName</em></span>.url</code> and <code class="literal">security.<span class="emphasis"><em>anyName</em></span>.roles</code></span></dt><dd><p class="simpara">
									Values of properties of individual security constraints just as they would be set in <code class="literal">security-constraint/web-resource-collection/url-pattern</code> and <code class="literal">security-constraint/auth-constraint/role-name</code> in <code class="literal">web.xml</code>, respectively. Roles are separated by comma and whitespace around it. The <code class="literal"><span class="emphasis"><em>anyName</em></span></code> identifier can be arbitrary but must match for individual properties of the same security constraint.
								</p><div class="admonition note"><div class="admonition_header">Note</div><div><p>
										Some Fuse versions contain a bug that requires roles to be separated by <code class="literal">", "</code> (comma and single space). Make sure you use precisely this notation for separating the roles.
									</p></div></div></dd></dl></div><p>
						The <code class="literal">Import-Package</code> in <code class="literal">META-INF/MANIFEST.MF</code> must contain at least these imports:
					</p><pre class="screen">javax.ws.rs;version="[2,3)",
META-INF.cxf;version="[2.7,3.3)",
META-INF.cxf.osgi;version="[2.7,3.3)";resolution:=optional,
org.apache.cxf.transport.http;version="[2.7,3.3)",
org.apache.cxf.*;version="[2.7,3.3)",
com.fasterxml.jackson.jaxrs.json;version="${jackson.version}"</pre></section><section class="section" id="fuse7_adapter_admin"><div class="titlepage"><div><div><h4 class="title">2.1.5.9. Securing Fuse Administration Services</h4></div></div></div><section class="section" id="using_ssh_authentication_to_fuse_terminal_2"><div class="titlepage"><div><div><h5 class="title">2.1.5.9.1. Using SSH Authentication to Fuse Terminal</h5></div></div></div><p>
							Red Hat Single Sign-On mainly addresses use cases for authentication of web applications; however, if your other web services and applications are protected with Red Hat Single Sign-On, protecting non-web administration services such as SSH with Red Hat Single Sign-On credentials is a best pracrice. You can do this using the JAAS login module, which allows remote connection to Red Hat Single Sign-On and verifies credentials based on <a class="link" href="#resource_owner_password_credentials_flow" title="2.4.3.3. Resource Owner Password Credentials">Resource Owner Password Credentials</a>.
						</p><p>
							To enable SSH authentication, complete the following steps:
						</p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem">
									In Red Hat Single Sign-On create a client (for example, <code class="literal">ssh-jmx-admin-client</code>), which will be used for SSH authentication. This client needs to have <code class="literal">Direct Access Grants Enabled</code> selected to <code class="literal">On</code>.
								</li><li class="listitem"><p class="simpara">
									In the <code class="literal">$FUSE_HOME/etc/org.apache.karaf.shell.cfg</code> file, update or specify this property:
								</p><pre class="screen">sshRealm=keycloak</pre></li><li class="listitem"><p class="simpara">
									Add the <code class="literal">$FUSE_HOME/etc/keycloak-direct-access.json</code> file with content similar to the following (based on your environment and Red Hat Single Sign-On client settings):
								</p><pre class="programlisting language-json">{
    "realm": "demo",
    "resource": "ssh-jmx-admin-client",
    "ssl-required" : "external",
    "auth-server-url" : "http://localhost:8080/auth",
    "credentials": {
        "secret": "password"
    }
}</pre><p class="simpara">
									This file specifies the client application configuration, which is used by JAAS DirectAccessGrantsLoginModule from the <code class="literal">keycloak</code> JAAS realm for SSH authentication.
								</p></li><li class="listitem"><p class="simpara">
									Start Fuse and install the <code class="literal">keycloak</code> JAAS realm. The easiest way is to install the <code class="literal">keycloak-jaas</code> feature, which has the JAAS realm predefined. You can override the feature’s predefined realm by using your own <code class="literal">keycloak</code> JAAS realm with higher ranking. For details see the <a class="link" href="https://access.redhat.com/documentation/en-us/red_hat_fuse/7.2/html-single/apache_karaf_security_guide/index#ESBSecureContainer">JBoss Fuse documentation</a>.
								</p><p class="simpara">
									Use these commands in the Fuse terminal:
								</p><pre class="screen">features:addurl mvn:org.keycloak/keycloak-osgi-features/4.8.3.Final-redhat-00001/xml/features
features:install keycloak-jaas</pre></li><li class="listitem"><p class="simpara">
									Log in using SSH as <code class="literal">admin</code> user by typing the following in the terminal:
								</p><pre class="screen">ssh -o PubkeyAuthentication=no -p 8101 admin@localhost</pre></li><li class="listitem">
									Log in with password <code class="literal">password</code>.
								</li></ol></div><div class="admonition note"><div class="admonition_header">Note</div><div><p>
								On some later operating systems, you might also need to use the SSH command’s -o option <code class="literal">-o HostKeyAlgorithms=+ssh-dss</code> because later SSH clients do not allow use of the <code class="literal">ssh-dss</code> algorithm, by default. However, by default, it is currently used in JBoss Fuse 7.4.0.
							</p></div></div><p>
							Note that the user needs to have realm role <code class="literal">admin</code> to perform all operations or another role to perform a subset of operations (for example, the <span class="strong strong"><strong>viewer</strong></span> role that restricts the user to run only read-only Karaf commands). The available roles are configured in <code class="literal">$FUSE_HOME/etc/org.apache.karaf.shell.cfg</code> or <code class="literal">$FUSE_HOME/etc/system.properties</code>.
						</p></section><section class="section" id="using_jmx_authentication_2"><div class="titlepage"><div><div><h5 class="title">2.1.5.9.2. Using JMX Authentication</h5></div></div></div><p>
							JMX authentication might be necessary if you want to use jconsole or another external tool to remotely connect to JMX through RMI. Otherwise it might be better to use hawt.io/jolokia, since the jolokia agent is installed in hawt.io by default. For more details see <a class="link" href="#fuse7_hawtio" title="2.1.5.10. Securing the Hawtio Administration Console">Hawtio Admin Console</a>.
						</p><p>
							To use JMX authentication, complete the following steps:
						</p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p class="simpara">
									In the <code class="literal">$FUSE_HOME/etc/org.apache.karaf.management.cfg</code> file, change the jmxRealm property to:
								</p><pre class="screen">jmxRealm=keycloak</pre></li><li class="listitem">
									Install the <code class="literal">keycloak-jaas</code> feature and configure the <code class="literal">$FUSE_HOME/etc/keycloak-direct-access.json</code> file as described in the SSH section above.
								</li><li class="listitem">
									In jconsole you can use a URL such as:
								</li></ol></div><pre class="screen">service:jmx:rmi://localhost:44444/jndi/rmi://localhost:1099/karaf-root</pre><p>
							and credentials: admin/password (based on the user with admin privileges according to your environment).
						</p></section></section><section class="section" id="fuse7_hawtio"><div class="titlepage"><div><div><h4 class="title">2.1.5.10. Securing the Hawtio Administration Console</h4></div></div></div><p>
						To secure the Hawtio Administration Console with Red Hat Single Sign-On, complete the following steps:
					</p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem">
								Create a client in the Red Hat Single Sign-On administration console in your realm. For example, in the Red Hat Single Sign-On <code class="literal">demo</code> realm, create a client <code class="literal">hawtio-client</code>, specify <code class="literal">public</code> as the Access Type, and specify a redirect URI pointing to Hawtio: http://localhost:8181/hawtio/*. Configure corresponding Web Origin (in this case, http://localhost:8181). Setup client scope mapping to include <span class="emphasis"><em>view-profile</em></span> client role of <span class="emphasis"><em>account</em></span> client in <span class="emphasis"><em>Scope</em></span> tab in <code class="literal">hawtio-client</code> client detail.
							</li><li class="listitem"><p class="simpara">
								Create the <code class="literal">keycloak-hawtio-client.json</code> file in the <code class="literal">$FUSE_HOME/etc</code> directory using content similar to that shown in the example below. Change the <code class="literal">realm</code>, <code class="literal">resource</code>, and <code class="literal">auth-server-url</code> properties according to your Red Hat Single Sign-On environment. The <code class="literal">resource</code> property must point to the client created in the previous step. This file is used by the client (Hawtio JavaScript application) side.
							</p><pre class="programlisting language-json">{
  "realm" : "demo",
  "clientId" : "hawtio-client",
  "url" : "http://localhost:8080/auth",
  "ssl-required" : "external",
  "public-client" : true
}</pre></li><li class="listitem"><p class="simpara">
								Create the <code class="literal">keycloak-direct-access.json</code> file in the <code class="literal">$FUSE_HOME/etc</code> directory using content similar to that shown in the example below. Change the <code class="literal">realm</code> and <code class="literal">url</code> properties according to your Red Hat Single Sign-On environment. This file is used by JavaScript client.
							</p><pre class="programlisting language-json">{
  "realm" : "demo",
  "resource" : "ssh-jmx-admin-client",
  "auth-server-url" : "http://localhost:8080/auth",
  "ssl-required" : "external",
  "credentials": {
    "secret": "password"
  }
}</pre></li><li class="listitem"><p class="simpara">
								Create the <code class="literal">keycloak-hawtio.json</code> file in the <code class="literal">$FUSE_HOME/etc</code> dicrectory using content similar to that shown in the example below. Change the <code class="literal">realm</code> and <code class="literal">auth-server-url</code> properties according to your Red Hat Single Sign-On environment. This file is used by the adapters on the server (JAAS Login module) side.
							</p><pre class="programlisting language-json">{
  "realm" : "demo",
  "resource" : "jaas",
  "bearer-only" : true,
  "auth-server-url" : "http://localhost:8080/auth",
  "ssl-required" : "external",
  "use-resource-role-mappings": false,
  "principal-attribute": "preferred_username"
}</pre></li><li class="listitem"><p class="simpara">
								Start JBoss Fuse 7.4.0, <a class="link" href="#fuse7_install_feature" title="2.1.5.2. Installing the Keycloak Feature">install the Keycloak feature</a>. Then type in the Karaf terminal:
							</p><pre class="screen">system:property -p hawtio.keycloakEnabled true
system:property -p hawtio.realm keycloak
system:property -p hawtio.keycloakClientConfig file://\${karaf.base}/etc/keycloak-hawtio-client.json
system:property -p hawtio.rolePrincipalClasses org.keycloak.adapters.jaas.RolePrincipal,org.apache.karaf.jaas.boot.principal.RolePrincipal
restart io.hawt.hawtio-war</pre></li><li class="listitem"><p class="simpara">
								Go to <a class="link" href="http://localhost:8181/hawtio">http://localhost:8181/hawtio</a> and log in as a user from your Red Hat Single Sign-On realm.
							</p><p class="simpara">
								Note that the user needs to have the proper realm role to successfully authenticate to Hawtio. The available roles are configured in the <code class="literal">$FUSE_HOME/etc/system.properties</code> file in <code class="literal">hawtio.roles</code>.
							</p></li></ol></div></section></section><section class="section" id="spring_boot_adapter"><div class="titlepage"><div><div><h3 class="title">2.1.6. Spring Boot Adapter</h3></div></div></div><p>
					To be able to secure Spring Boot apps you must add the Keycloak Spring Boot adapter JAR to your app. You then have to provide some extra configuration via normal Spring Boot configuration (<code class="literal">application.properties</code>). Let’s go over these steps.
				</p><section class="section" id="spring_boot_adapter_installation"><div class="titlepage"><div><div><h4 class="title">2.1.6.1. Adapter Installation</h4></div></div></div><p>
						The Keycloak Spring Boot adapter takes advantage of Spring Boot’s autoconfiguration so all you need to do is add the Keycloak Spring Boot starter to your project. The Keycloak Spring Boot Starter is also directly available from the <a class="link" href="https://start.spring.io/">Spring Initializr Page</a>. To add it manually using Maven, add the following to your dependencies:
					</p><pre class="programlisting language-xml">&lt;dependency&gt;
    &lt;groupId&gt;org.keycloak&lt;/groupId&gt;
    &lt;artifactId&gt;keycloak-spring-boot-starter&lt;/artifactId&gt;
&lt;/dependency&gt;</pre><p>
						Add the Adapter BOM dependency:
					</p><pre class="programlisting language-xml">&lt;dependencyManagement&gt;
  &lt;dependencies&gt;
    &lt;dependency&gt;
      &lt;groupId&gt;org.keycloak.bom&lt;/groupId&gt;
      &lt;artifactId&gt;keycloak-adapter-bom&lt;/artifactId&gt;
      &lt;version&gt;4.8.3.Final-redhat-00001&lt;/version&gt;
      &lt;type&gt;pom&lt;/type&gt;
      &lt;scope&gt;import&lt;/scope&gt;
    &lt;/dependency&gt;
  &lt;/dependencies&gt;
&lt;/dependencyManagement&gt;</pre><p>
						Currently the following embedded containers are supported and do not require any extra dependencies if using the Starter:
					</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">
								Tomcat
							</li><li class="listitem">
								Undertow
							</li><li class="listitem">
								Jetty
							</li></ul></div></section><section class="section" id="spring_boot_adapter_configuration"><div class="titlepage"><div><div><h4 class="title">2.1.6.2. Required Spring Boot Adapter Configuration</h4></div></div></div><p>
						This section describes how to configure your Spring Boot app to use Keycloak.
					</p><p>
						Instead of a <code class="literal">keycloak.json</code> file, you configure the realm for the Spring Boot Keycloak adapter via the normal Spring Boot configuration. For example:
					</p><pre class="screen">keycloak.realm = demorealm
keycloak.auth-server-url = http://127.0.0.1:8080/auth
keycloak.ssl-required = external
keycloak.resource = demoapp
keycloak.credentials.secret = 11111111-1111-1111-1111-111111111111
keycloak.use-resource-role-mappings = true</pre><p>
						You can disable the Keycloak Spring Boot Adapter (for example in tests) by setting <code class="literal">keycloak.enabled = false</code>.
					</p><p>
						To configure a Policy Enforcer, unlike keycloak.json, <code class="literal">policy-enforcer-config</code> must be used instead of just <code class="literal">policy-enforcer</code>.
					</p><p>
						You also need to specify the Java EE security config that would normally go in the <code class="literal">web.xml</code>. The Spring Boot Adapter will set the <code class="literal">login-method</code> to <code class="literal">KEYCLOAK</code> and configure the <code class="literal">security-constraints</code> at startup time. Here’s an example configuration:
					</p><pre class="screen">keycloak.securityConstraints[0].authRoles[0] = admin
keycloak.securityConstraints[0].authRoles[1] = user
keycloak.securityConstraints[0].securityCollections[0].name = insecure stuff
keycloak.securityConstraints[0].securityCollections[0].patterns[0] = /insecure

keycloak.securityConstraints[1].authRoles[0] = admin
keycloak.securityConstraints[1].securityCollections[0].name = admin stuff
keycloak.securityConstraints[1].securityCollections[0].patterns[0] = /admin</pre><div class="admonition warning"><div class="admonition_header">Warning</div><div><p>
							If you plan to deploy your Spring Application as a WAR then you should not use the Spring Boot Adapter and use the dedicated adapter for the application server or servlet container you are using. Your Spring Boot should also contain a <code class="literal">web.xml</code> file.
						</p></div></div></section></section><section class="section" id="servlet_filter_adapter"><div class="titlepage"><div><div><h3 class="title">2.1.7. Java Servlet Filter Adapter</h3></div></div></div><p>
					If you are deploying your Java Servlet application on a platform where there is no Red Hat Single Sign-On adapter you opt to use the servlet filter adapter. This adapter works a bit differently than the other adapters. You do not define security constraints in web.xml. Instead you define a filter mapping using the Red Hat Single Sign-On servlet filter adapter to secure the url patterns you want to secure.
				</p><div class="admonition warning"><div class="admonition_header">Warning</div><div><p>
						Backchannel logout works a bit differently than the standard adapters. Instead of invalidating the HTTP session it marks the session id as logged out. There’s no standard way to invalidate an HTTP session based on a session id.
					</p></div></div><pre class="programlisting language-xml">&lt;web-app xmlns="http://java.sun.com/xml/ns/javaee"
      xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
      xsi:schemaLocation="http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/web-app_3_0.xsd"
      version="3.0"&gt;

	&lt;module-name&gt;application&lt;/module-name&gt;

    &lt;filter&gt;
        &lt;filter-name&gt;Keycloak Filter&lt;/filter-name&gt;
        &lt;filter-class&gt;org.keycloak.adapters.servlet.KeycloakOIDCFilter&lt;/filter-class&gt;
    &lt;/filter&gt;
    &lt;filter-mapping&gt;
        &lt;filter-name&gt;Keycloak Filter&lt;/filter-name&gt;
        &lt;url-pattern&gt;/keycloak/*&lt;/url-pattern&gt;
        &lt;url-pattern&gt;/protected/*&lt;/url-pattern&gt;
    &lt;/filter-mapping&gt;
&lt;/web-app&gt;</pre><p>
					In the snippet above there are two url-patterns. <span class="emphasis"><em>/protected/*</em></span> are the files we want protected, while the <span class="emphasis"><em>/keycloak/*</em></span> url-pattern handles callbacks from the Red Hat Single Sign-On server.
				</p><p>
					If you need to exclude some paths beneath the configured <code class="literal">url-patterns</code> you can use the Filter init-param <code class="literal">keycloak.config.skipPattern</code> to configure a regular expression that describes a path-pattern for which the keycloak filter should immediately delegate to the filter-chain. By default no skipPattern is configured.
				</p><p>
					Patterns are matched against the <code class="literal">requestURI</code> without the <code class="literal">context-path</code>. Given the context-path <code class="literal">/myapp</code> a request for <code class="literal">/myapp/index.html</code> will be matched with <code class="literal">/index.html</code> against the skip pattern.
				</p><pre class="programlisting language-xml">&lt;init-param&gt;
    &lt;param-name&gt;keycloak.config.skipPattern&lt;/param-name&gt;
    &lt;param-value&gt;^/(path1|path2|path3).*&lt;/param-value&gt;
&lt;/init-param&gt;</pre><p>
					Note that you should configure your client in the Red Hat Single Sign-On Admin Console with an Admin URL that points to a secured section covered by the filter’s url-pattern.
				</p><p>
					The Admin URL will make callbacks to the Admin URL to do things like backchannel logout. So, the Admin URL in this example should be <code class="literal">http[s]://hostname/{context-root}/keycloak</code>.
				</p><p>
					The Red Hat Single Sign-On filter has the same configuration parameters as the other adapters except you must define them as filter init params instead of context params.
				</p><p>
					To use this filter, include this maven artifact in your WAR poms:
				</p><pre class="programlisting language-xml">&lt;dependency&gt;
    &lt;groupId&gt;org.keycloak&lt;/groupId&gt;
    &lt;artifactId&gt;keycloak-servlet-filter-adapter&lt;/artifactId&gt;
    &lt;version&gt;4.8.3.Final-redhat-00001&lt;/version&gt;
&lt;/dependency&gt;</pre></section><section class="section" id="security_context"><div class="titlepage"><div><div><h3 class="title">2.1.8. Security Context</h3></div></div></div><p>
					The <code class="literal">KeycloakSecurityContext</code> interface is available if you need to access to the tokens directly. This could be useful if you want to retrieve additional details from the token (such as user profile information) or you want to invoke a RESTful service that is protected by Red Hat Single Sign-On.
				</p><p>
					In servlet environments it is available in secured invocations as an attribute in HttpServletRequest:
				</p><pre class="programlisting language-java">httpServletRequest
    .getAttribute(KeycloakSecurityContext.class.getName());</pre><p>
					Or, it is available in insecured requests in the HttpSession:
				</p><pre class="programlisting language-java">httpServletRequest.getSession()
    .getAttribute(KeycloakSecurityContext.class.getName());</pre></section><section class="section" id="adapter_error_handling"><div class="titlepage"><div><div><h3 class="title">2.1.9. Error Handling</h3></div></div></div><p>
					Red Hat Single Sign-On has some error handling facilities for servlet based client adapters. When an error is encountered in authentication, Red Hat Single Sign-On will call <code class="literal">HttpServletResponse.sendError()</code>. You can set up an error-page within your <code class="literal">web.xml</code> file to handle the error however you want. Red Hat Single Sign-On can throw 400, 401, 403, and 500 errors.
				</p><pre class="programlisting language-xml">&lt;error-page&gt;
    &lt;error-code&gt;403&lt;/error-code&gt;
    &lt;location&gt;/ErrorHandler&lt;/location&gt;
&lt;/error-page&gt;</pre><p>
					Red Hat Single Sign-On also sets a <code class="literal">HttpServletRequest</code> attribute that you can retrieve. The attribute name is <code class="literal">org.keycloak.adapters.spi.AuthenticationError</code>, which should be casted to <code class="literal">org.keycloak.adapters.OIDCAuthenticationError</code>.
				</p><p>
					For example:
				</p><pre class="programlisting language-java">import org.keycloak.adapters.OIDCAuthenticationError;
import org.keycloak.adapters.OIDCAuthenticationError.Reason;
...

OIDCAuthenticationError error = (OIDCAuthenticationError) httpServletRequest
    .getAttribute('org.keycloak.adapters.spi.AuthenticationError');

Reason reason = error.getReason();
System.out.println(reason.name());</pre></section><section class="section" id="logout"><div class="titlepage"><div><div><h3 class="title">2.1.10. Logout</h3></div></div></div><p id="java_adapter_logout">
					You can log out of a web application in multiple ways. For Java EE servlet containers, you can call <code class="literal">HttpServletRequest.logout()</code>. For other browser applications, you can redirect the browser to <code class="literal">http://auth-server/auth/realms/{realm-name}/protocol/openid-connect/logout?redirect_uri=encodedRedirectUri</code>, which logs you out if you have an SSO session with your browser.
				</p><p>
					When using the <code class="literal">HttpServletRequest.logout()</code> option the adapter executes a back-channel POST call against the Red Hat Single Sign-On server passing the refresh token. If the method is executed from an unprotected page (a page that does not check for a valid token) the refresh token can be unavailable and, in that case, the adapter skips the call. For this reason, using a protected page to execute <code class="literal">HttpServletRequest.logout()</code> is recommended so that current tokens are always taken into account and an interaction with the Red Hat Single Sign-On server is performed if needed.
				</p><p>
					If you want to avoid logging out of an external identity provider as part of the logout process, you can supply the parameter <code class="literal">initiating_idp</code>, with the value being the identity (alias) of the identity provider in question. This is useful when the logout endpoint is invoked as part of single logout initiated by the external identity provider.
				</p></section><section class="section" id="params_forwarding"><div class="titlepage"><div><div><h3 class="title">2.1.11. Parameters Forwarding</h3></div></div></div><p>
					The Red Hat Single Sign-On initial authorization endpoint request has support for various parameters. Most of the parameters are described in <a class="link" href="https://openid.net/specs/openid-connect-core-1_0.html#AuthorizationEndpoint">OIDC specification</a>. Some parameters are added automatically by the adapter based on the adapter configuration. However, there are also a few parameters that can be added on a per-invocation basis. When you open the secured application URI, the particular parameter will be forwarded to the Red Hat Single Sign-On authorization endpoint.
				</p><p>
					For example, if you request an offline token, then you can open the secured application URI with the <code class="literal">scope</code> parameter like:
				</p><pre class="screen">http://myappserver/mysecuredapp?scope=offline_access</pre><p>
					and the parameter <code class="literal">scope=offline_access</code> will be automatically forwarded to the Red Hat Single Sign-On authorization endpoint.
				</p><p>
					The supported parameters are:
				</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">
							scope - Use a space-delimited list of scopes. A space-delimited list typically references <a class="link" href="https://access.redhat.com/documentation/en-us/red_hat_single_sign-on/7.4/html-single/server_administration_guide/#_client_scopes">Client scopes</a> defined on particular client. Note that the scope <code class="literal">openid</code> will be always be added to the list of scopes by the adapter. For example, if you enter the scope options <code class="literal">address phone</code>, then the request to Red Hat Single Sign-On will contain the scope parameter <code class="literal">scope=openid address phone</code>.
						</li><li class="listitem"><p class="simpara">
							prompt - Red Hat Single Sign-On supports these settings:
						</p><div class="itemizedlist"><ul class="itemizedlist" type="circle"><li class="listitem">
									<code class="literal">login</code> - SSO will be ignored and the Red Hat Single Sign-On login page will be always shown, even if the user is already authenticated
								</li><li class="listitem">
									<code class="literal">consent</code> - Applicable only for the clients with <code class="literal">Consent Required</code>. If it is used, the Consent page will always be displayed, even if the user previously granted consent to this client.
								</li><li class="listitem">
									<code class="literal">none</code> - The login page will never be shown; instead the user will be redirected to the application, with an error if the user is not yet authenticated. This setting allows you to create a filter/interceptor on the application side and show a custom error page to the user. See more details in the specification.
								</li></ul></div></li><li class="listitem">
							max_age - Used only if a user is already authenticated. Specifies maximum permitted time for the authentication to persist, measured from when the user authenticated. If user is authenticated longer than <code class="literal">maxAge</code>, the SSO is ignored and he must re-authenticate.
						</li><li class="listitem">
							login_hint - Used to pre-fill the username/email field on the login form.
						</li><li class="listitem">
							kc_idp_hint - Used to tell Red Hat Single Sign-On to skip showing login page and automatically redirect to specified identity provider instead. More info in the <a class="link" href="https://access.redhat.com/documentation/en-us/red_hat_single_sign-on/7.4/html-single/server_administration_guide/#_client_suggested_idp">Identity Provider documentation</a>.
						</li></ul></div><p>
					Most of the parameters are described in the <a class="link" href="https://openid.net/specs/openid-connect-core-1_0.html#AuthorizationEndpoint">OIDC specification</a>. The only exception is parameter <code class="literal">kc_idp_hint</code>, which is specific to Red Hat Single Sign-On and contains the name of the identity provider to automatically use. For more information see the <code class="literal">Identity Brokering</code> section in <a class="link" href="https://access.redhat.com/documentation/en-us/red_hat_single_sign-on/7.4/html-single/server_administration_guide/">Server Administration Guide</a>.
				</p><div class="admonition warning"><div class="admonition_header">Warning</div><div><p>
						If you open the URL using the attached parameters, the adapter will not redirect you to Red Hat Single Sign-On if you are already authenticated in the application. For example, opening http://myappserver/mysecuredapp?prompt=login will not automatically redirect you to the Red Hat Single Sign-On login page if you are already authenticated to the application <code class="literal">mysecredapp</code> . This behavior may be changed in the future.
					</p></div></div></section><section class="section" id="client_authentication_adapter"><div class="titlepage"><div><div><h3 class="title">2.1.12. Client Authentication</h3></div></div></div><p>
					When a confidential OIDC client needs to send a backchannel request (for example, to exchange code for the token, or to refresh the token) it needs to authenticate against the Red Hat Single Sign-On server. By default, there are three ways to authenticate the client: client ID and client secret, client authentication with signed JWT, or client authentication with signed JWT using client secret.
				</p><section class="section" id="client_id_and_client_secret"><div class="titlepage"><div><div><h4 class="title">2.1.12.1. Client ID and Client Secret</h4></div></div></div><p>
						This is the traditional method described in the OAuth2 specification. The client has a secret, which needs to be known to both the adapter (application) and the Red Hat Single Sign-On server. You can generate the secret for a particular client in the Red Hat Single Sign-On administration console, and then paste this secret into the <code class="literal">keycloak.json</code> file on the application side:
					</p><pre class="programlisting language-json">"credentials": {
    "secret": "19666a4f-32dd-4049-b082-684c74115f28"
}</pre></section><section class="section" id="client_authentication_with_signed_jwt"><div class="titlepage"><div><div><h4 class="title">2.1.12.2. Client Authentication with Signed JWT</h4></div></div></div><p>
						This is based on the <a class="link" href="https://tools.ietf.org/html/rfc7523">RFC7523</a> specification. It works this way:
					</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">
								The client must have the private key and certificate. For Red Hat Single Sign-On this is available through the traditional <code class="literal">keystore</code> file, which is either available on the client application’s classpath or somewhere on the file system.
							</li><li class="listitem">
								Once the client application is started, it allows to download its public key in <a class="link" href="https://self-issued.info/docs/draft-ietf-jose-json-web-key.html">JWKS</a> format using a URL such as http://myhost.com/myapp/k_jwks, assuming that http://myhost.com/myapp is the base URL of your client application. This URL can be used by Red Hat Single Sign-On (see below).
							</li><li class="listitem">
								During authentication, the client generates a JWT token and signs it with its private key and sends it to Red Hat Single Sign-On in the particular backchannel request (for example, code-to-token request) in the <code class="literal">client_assertion</code> parameter.
							</li><li class="listitem"><p class="simpara">
								Red Hat Single Sign-On must have the public key or certificate of the client so that it can verify the signature on JWT. In Red Hat Single Sign-On you need to configure client credentials for your client. First you need to choose <code class="literal">Signed JWT</code> as the method of authenticating your client in the tab <code class="literal">Credentials</code> in administration console. Then you can choose to either:
							</p><div class="itemizedlist"><ul class="itemizedlist" type="circle"><li class="listitem">
										Configure the JWKS URL where Red Hat Single Sign-On can download the client’s public keys. This can be a URL such as http://myhost.com/myapp/k_jwks (see details above). This option is the most flexible, since the client can rotate its keys anytime and Red Hat Single Sign-On then always downloads new keys when needed without needing to change the configuration. More accurately, Red Hat Single Sign-On downloads new keys when it sees the token signed by an unknown <code class="literal">kid</code> (Key ID).
									</li><li class="listitem">
										Upload the client’s public key or certificate, either in PEM format, in JWK format, or from the keystore. With this option, the public key is hardcoded and must be changed when the client generates a new key pair. You can even generate your own keystore from the Red Hat Single Sign-On admininstration console if you don’t have your own available. For more details on how to set up the Red Hat Single Sign-On administration console see <a class="link" href="https://access.redhat.com/documentation/en-us/red_hat_single_sign-on/7.4/html-single/server_administration_guide/">Server Administration Guide</a>.
									</li></ul></div></li></ul></div><p>
						For set up on the adapter side you need to have something like this in your <code class="literal">keycloak.json</code> file:
					</p><pre class="programlisting language-json">"credentials": {
  "jwt": {
    "client-keystore-file": "classpath:keystore-client.jks",
    "client-keystore-type": "JKS",
    "client-keystore-password": "storepass",
    "client-key-password": "keypass",
    "client-key-alias": "clientkey",
    "token-expiration": 10
  }
}</pre><p>
						With this configuration, the keystore file <code class="literal">keystore-client.jks</code> must be available on classpath in your WAR. If you do not use the prefix <code class="literal">classpath:</code> you can point to any file on the file system where the client application is running.
					</p></section></section><section class="section" id="multi_tenancy"><div class="titlepage"><div><div><h3 class="title">2.1.13. Multi Tenancy</h3></div></div></div><p>
					Multi Tenancy, in our context, means that a single target application (WAR) can be secured with multiple Red Hat Single Sign-On realms. The realms can be located one the same Red Hat Single Sign-On instance or on different instances.
				</p><p>
					In practice, this means that the application needs to have multiple <code class="literal">keycloak.json</code> adapter configuration files.
				</p><p>
					You could have multiple instances of your WAR with different adapter configuration files deployed to different context-paths. However, this may be inconvenient and you may also want to select the realm based on something else than context-path.
				</p><p>
					Red Hat Single Sign-On makes it possible to have a custom config resolver so you can choose what adapter config is used for each request.
				</p><p>
					To achieve this first you need to create an implementation of <code class="literal">org.keycloak.adapters.KeycloakConfigResolver</code>. For example:
				</p><pre class="programlisting language-java">package example;

import org.keycloak.adapters.KeycloakConfigResolver;
import org.keycloak.adapters.KeycloakDeployment;
import org.keycloak.adapters.KeycloakDeploymentBuilder;

public class PathBasedKeycloakConfigResolver implements KeycloakConfigResolver {

    @Override
    public KeycloakDeployment resolve(OIDCHttpFacade.Request request) {
        if (path.startsWith("alternative")) {
            KeycloakDeployment deployment = cache.get(realm);
            if (null == deployment) {
                InputStream is = getClass().getResourceAsStream("/tenant1-keycloak.json");
                return KeycloakDeploymentBuilder.build(is);
            }
        } else {
            InputStream is = getClass().getResourceAsStream("/default-keycloak.json");
            return KeycloakDeploymentBuilder.build(is);
        }
    }

}</pre><p>
					You also need to configure which <code class="literal">KeycloakConfigResolver</code> implementation to use with the <code class="literal">keycloak.config.resolver</code> context-param in your <code class="literal">web.xml</code>:
				</p><pre class="programlisting language-xml">&lt;web-app&gt;
    ...
    &lt;context-param&gt;
        &lt;param-name&gt;keycloak.config.resolver&lt;/param-name&gt;
        &lt;param-value&gt;example.PathBasedKeycloakConfigResolver&lt;/param-value&gt;
    &lt;/context-param&gt;
&lt;/web-app&gt;</pre></section><section class="section" id="applicationclustering"><div class="titlepage"><div><div><h3 class="title">2.1.14. Application Clustering</h3></div></div></div><p>
					This chapter is related to supporting clustered applications deployed to JBoss EAP.
				</p><p>
					There are a few options available depending on whether your application is:
				</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">
							Stateless or stateful
						</li><li class="listitem">
							Distributable (replicated http session) or non-distributable
						</li><li class="listitem">
							Relying on sticky sessions provided by load balancer
						</li><li class="listitem">
							Hosted on same domain as Red Hat Single Sign-On
						</li></ul></div><p>
					Dealing with clustering is not quite as simple as for a regular application. Mainly due to the fact that both the browser and the server-side application sends requests to Red Hat Single Sign-On, so it’s not as simple as enabling sticky sessions on your load balancer.
				</p><section class="section" id="stateless_token_store"><div class="titlepage"><div><div><h4 class="title">2.1.14.1. Stateless token store</h4></div></div></div><p>
						By default, the web application secured by Red Hat Single Sign-On uses the HTTP session to store security context. This means that you either have to enable sticky sessions or replicate the HTTP session.
					</p><p>
						As an alternative to storing the security context in the HTTP session the adapter can be configured to store this in a cookie instead. This is useful if you want to make your application stateless or if you don’t want to store the security context in the HTTP session.
					</p><p>
						To use the cookie store for saving the security context, edit your applications <code class="literal">WEB-INF/keycloak.json</code> and add:
					</p><pre class="programlisting language-json">"token-store": "cookie"</pre><div class="admonition note"><div class="admonition_header">Note</div><div><p>
							The default value for <code class="literal">token-store</code> is <code class="literal">session</code>, which stores the security context in the HTTP session.
						</p></div></div><p>
						One limitation of using the cookie store is that the whole security context is passed in the cookie for every HTTP request. This may impact performance.
					</p><p>
						Another small limitation is limited support for Single-Sign Out. It works without issues if you init servlet logout (HttpServletRequest.logout) from the application itself as the adapter will delete the KEYCLOAK_ADAPTER_STATE cookie. However, back-channel logout initialized from a different application isn’t propagated by Red Hat Single Sign-On to applications using cookie store. Hence it’s recommended to use a short value for the access token timeout (for example 1 minute).
					</p><div class="admonition note"><div class="admonition_header">Note</div><div><p>
							Some load balancers do not allow any configuration of the sticky session cookie name or contents, such as Amazon ALB. For these, it is recommended to set the <code class="literal">shouldAttachRoute</code> option to <code class="literal">false</code>.
						</p></div></div></section><section class="section" id="relative_uri_optimization"><div class="titlepage"><div><div><h4 class="title">2.1.14.2. Relative URI optimization</h4></div></div></div><p>
						In deployment scenarios where Red Hat Single Sign-On and the application is hosted on the same domain (through a reverse proxy or load balancer) it can be convenient to use relative URI options in your client configuration.
					</p><p>
						With relative URIs the URI is resolved as relative to the URL used to access Red Hat Single Sign-On.
					</p><p>
						For example if the URL to your application is <code class="literal">https://acme.org/myapp</code> and the URL to Red Hat Single Sign-On is <code class="literal">https://acme.org/auth</code>, then you can use the redirect-uri <code class="literal">/myapp</code> instead of <code class="literal">https://acme.org/myapp</code>.
					</p></section><section class="section" id="admin_url_configuration"><div class="titlepage"><div><div><h4 class="title">2.1.14.3. Admin URL configuration</h4></div></div></div><p>
						Admin URL for a particular client can be configured in the Red Hat Single Sign-On Administration Console. It’s used by the Red Hat Single Sign-On server to send backend requests to the application for various tasks, like logout users or push revocation policies.
					</p><p>
						For example the way backchannel logout works is:
					</p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem">
								User sends logout request from one application
							</li><li class="listitem">
								The application sends logout request to Red Hat Single Sign-On
							</li><li class="listitem">
								The Red Hat Single Sign-On server invalidates the user session
							</li><li class="listitem">
								The Red Hat Single Sign-On server then sends a backchannel request to application with an admin url that are associated with the session
							</li><li class="listitem">
								When an application receives the logout request it invalidates the corresponding HTTP session
							</li></ol></div><p>
						If admin URL contains <code class="literal">${application.session.host}</code> it will be replaced with the URL to the node associated with the HTTP session.
					</p></section><section class="section" id="registration_app_nodes"><div class="titlepage"><div><div><h4 class="title">2.1.14.4. Registration of application nodes</h4></div></div></div><p>
						The previous section describes how Red Hat Single Sign-On can send logout request to node associated with a specific HTTP session. However, in some cases admin may want to propagate admin tasks to all registered cluster nodes, not just one of them. For example to push a new not before policy to the application or to logout all users from the application.
					</p><p>
						In this case Red Hat Single Sign-On needs to be aware of all application cluster nodes, so it can send the event to all of them. To achieve this, we support auto-discovery mechanism:
					</p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem">
								When a new application node joins the cluster, it sends a registration request to the Red Hat Single Sign-On server
							</li><li class="listitem">
								The request may be re-sent to Red Hat Single Sign-On in configured periodic intervals
							</li><li class="listitem">
								If the Red Hat Single Sign-On server doesn’t receive a re-registration request within a specified timeout then it automatically unregisters the specific node
							</li><li class="listitem">
								The node is also unregistered in Red Hat Single Sign-On when it sends an unregistration request, which is usually during node shutdown or application undeployment. This may not work properly for forced shutdown when undeployment listeners are not invoked, which results in the need for automatic unregistration
							</li></ol></div><p>
						Sending startup registrations and periodic re-registration is disabled by default as it’s only required for some clustered applications.
					</p><p>
						To enable the feature edit the <code class="literal">WEB-INF/keycloak.json</code> file for your application and add:
					</p><pre class="programlisting language-json">"register-node-at-startup": true,
"register-node-period": 600,</pre><p>
						This means the adapter will send the registration request on startup and re-register every 10 minutes.
					</p><p>
						In the Red Hat Single Sign-On Administration Console you can specify the maximum node re-registration timeout (should be larger than <span class="emphasis"><em>register-node-period</em></span> from the adapter configuration). You can also manually add and remove cluster nodes in through the Adminstration Console, which is useful if you don’t want to rely on the automatic registration feature or if you want to remove stale application nodes in the event your not using the automatic unregistration feature.
					</p></section><section class="section" id="refresh_token_each_req"><div class="titlepage"><div><div><h4 class="title">2.1.14.5. Refresh token in each request</h4></div></div></div><p>
						By default the application adapter will only refresh the access token when it’s expired. However, you can also configure the adapter to refresh the token on every request. This may have a performance impact as your application will send more requests to the Red Hat Single Sign-On server.
					</p><p>
						To enable the feature edit the <code class="literal">WEB-INF/keycloak.json</code> file for your application and add:
					</p><pre class="programlisting language-json">"always-refresh-token": true</pre><div class="admonition note"><div class="admonition_header">Note</div><div><p>
							This may have a significant impact on performance. Only enable this feature if you can’t rely on backchannel messages to propagate logout and not before policies. Another thing to consider is that by default access tokens has a short expiration so even if logout is not propagated the token will expire within minutes of the logout.
						</p></div></div></section></section></section><section class="section" id="javascript_adapter"><div class="titlepage"><div><div><h2 class="title">2.2. JavaScript Adapter</h2></div></div></div><p>
				Red Hat Single Sign-On comes with a client-side JavaScript library that can be used to secure HTML5/JavaScript applications. The JavaScript adapter has built-in support for Cordova applications.
			</p><p>
				The library can be retrieved directly from the Red Hat Single Sign-On server at <code class="literal">/auth/js/keycloak.js</code> and is also distributed as a ZIP archive.
			</p><p>
				A best practice is to load the JavaScript adapter directly from Red Hat Single Sign-On Server as it will automatically be updated when you upgrade the server. If you copy the adapter to your web application instead, make sure you upgrade the adapter only after you have upgraded the server.
			</p><p>
				One important thing to note about using client-side applications is that the client has to be a public client as there is no secure way to store client credentials in a client-side application. This makes it very important to make sure the redirect URIs you have configured for the client are correct and as specific as possible.
			</p><p>
				To use the JavaScript adapter you must first create a client for your application in the Red Hat Single Sign-On Administration Console. Make sure <code class="literal">public</code> is selected for <code class="literal">Access Type</code>.
			</p><p>
				You also need to configure <code class="literal">Valid Redirect URIs</code> and <code class="literal">Web Origins</code>. Be as specific as possible as failing to do so may result in a security vulnerability.
			</p><p>
				Once the client is created click on the <code class="literal">Installation</code> tab select <code class="literal">Keycloak OIDC JSON</code> for <code class="literal">Format Option</code> then click <code class="literal">Download</code>. The downloaded <code class="literal">keycloak.json</code> file should be hosted on your web server at the same location as your HTML pages.
			</p><p>
				Alternatively, you can skip the configuration file and manually configure the adapter.
			</p><p>
				The following example shows how to initialize the JavaScript adapter:
			</p><pre class="programlisting language-html">&lt;head&gt;
    &lt;script src="keycloak.js"&gt;&lt;/script&gt;
    &lt;script&gt;
        var keycloak = new Keycloak();
        keycloak.init().then(function(authenticated) {
            alert(authenticated ? 'authenticated' : 'not authenticated');
        }).catch(function() {
            alert('failed to initialize');
        });
    &lt;/script&gt;
&lt;/head&gt;</pre><p>
				If the <code class="literal">keycloak.json</code> file is in a different location you can specify it:
			</p><pre class="programlisting language-javascript">var keycloak = new Keycloak('http://localhost:8080/myapp/keycloak.json');</pre><p>
				Alternatively, you can pass in a JavaScript object with the required configuration instead:
			</p><pre class="programlisting language-javascript">var keycloak = new Keycloak({
    url: 'http://keycloak-server/auth',
    realm: 'myrealm',
    clientId: 'myapp'
});</pre><p>
				By default to authenticate you need to call the <code class="literal">login</code> function. However, there are two options available to make the adapter automatically authenticate. You can pass <code class="literal">login-required</code> or <code class="literal">check-sso</code> to the init function. <code class="literal">login-required</code> will authenticate the client if the user is logged-in to Red Hat Single Sign-On or display the login page if not. <code class="literal">check-sso</code> will only authenticate the client if the user is already logged-in, if the user is not logged-in the browser will be redirected back to the application and remain unauthenticated.
			</p><p>
				You can configure a <span class="emphasis"><em>silent</em></span> <code class="literal">check-sso</code> option. With this feature enabled, your browser won’t do a full redirect to the Red Hat Single Sign-On server and back to your application, but this action will be performed in a hidden iframe, so your application resources only need to be loaded and parsed once by the browser when the app is initialized and not again after the redirect back from Red Hat Single Sign-On to your app. This is particularly useful in case of SPAs (Single Page Applications).
			</p><p>
				To enable the <span class="emphasis"><em>silent</em></span> <code class="literal">check-sso</code>, you have to provide a <code class="literal">silentCheckSsoRedirectUri</code> attribute in the init method. This URI needs to be a valid endpoint in the application (and of course it must be configured as a valid redirect for the client in the Red Hat Single Sign-On Administration Console):
			</p><pre class="programlisting language-javascript">keycloak.init({
    onLoad: 'check-sso',
    silentCheckSsoRedirectUri: window.location.origin + '/silent-check-sso.html'
})</pre><p>
				The page at the silent check-sso redirect uri is loaded in the iframe after successfully checking your authentication state and retrieving the tokens from the Red Hat Single Sign-On server. It has no other task than sending the received tokens to the main application and should only look like this:
			</p><pre class="programlisting language-html">&lt;html&gt;
&lt;body&gt;
    &lt;script&gt;
        parent.postMessage(location.href, location.origin)
    &lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;</pre><p>
				Please keep in mind that this page at the specified location must be provided by the application itself and is <span class="emphasis"><em>not</em></span> part of the JavaScript adapter!
			</p><div class="admonition warning"><div class="admonition_header">Warning</div><div><p>
					Starting with Chrome version 80 (released on February 2020), silent <code class="literal">check-sso</code> functionality will work only when the SSL / TLS connection is configured on the Red Hat Single Sign-On side.
				</p></div></div><p>
				To enable <code class="literal">login-required</code> set <code class="literal">onLoad</code> to <code class="literal">login-required</code> and pass to the init method:
			</p><pre class="programlisting language-javascript">keycloak.init({
    onLoad: 'login-required'
})</pre><p>
				After the user is authenticated the application can make requests to RESTful services secured by Red Hat Single Sign-On by including the bearer token in the <code class="literal">Authorization</code> header. For example:
			</p><pre class="programlisting language-javascript">var loadData = function () {
    document.getElementById('username').innerText = keycloak.subject;

    var url = 'http://localhost:8080/restful-service';

    var req = new XMLHttpRequest();
    req.open('GET', url, true);
    req.setRequestHeader('Accept', 'application/json');
    req.setRequestHeader('Authorization', 'Bearer ' + keycloak.token);

    req.onreadystatechange = function () {
        if (req.readyState == 4) {
            if (req.status == 200) {
                alert('Success');
            } else if (req.status == 403) {
                alert('Forbidden');
            }
        }
    }

    req.send();
};</pre><p>
				One thing to keep in mind is that the access token by default has a short life expiration so you may need to refresh the access token prior to sending the request. You can do this by the <code class="literal">updateToken</code> method. The <code class="literal">updateToken</code> method returns a promise which makes it easy to invoke the service only if the token was successfully refreshed and display an error to the user if it wasn’t. For example:
			</p><pre class="programlisting language-javascript">keycloak.updateToken(30).then(function() {
    loadData();
}).catch(function() {
    alert('Failed to refresh token');
});</pre><section class="section" id="session_status_iframe"><div class="titlepage"><div><div><h3 class="title">2.2.1. Session Status iframe</h3></div></div></div><p>
					By default, the JavaScript adapter creates a hidden iframe that is used to detect if a Single-Sign Out has occurred. This does not require any network traffic, instead the status is retrieved by looking at a special status cookie. This feature can be disabled by setting <code class="literal">checkLoginIframe: false</code> in the options passed to the <code class="literal">init</code> method.
				</p><p>
					You should not rely on looking at this cookie directly. Its format can change and it’s also associated with the URL of the Red Hat Single Sign-On server, not your application.
				</p><div class="admonition warning"><div class="admonition_header">Warning</div><div><p>
						Starting with Chrome version 80 (released on February 2020), status iframe will only be able to see the special cookie over the SSL / TLS connection configured on the Red Hat Single Sign-On side. Using an insecure connection may lead to redirecting to Red Hat Single Sign-On every time iframe checks the status. You can avoid this behavior by disabling iframe or <a class="link" href="https://access.redhat.com/documentation/en-us/red_hat_single_sign-on/7.4/html-single/server_installation_and_configuration_guide/#_setting_up_ssl">configuring the SSL / TLS</a> on the Red Hat Single Sign-On side.
					</p></div></div></section><section class="section" id="javascript_implicit_flow"><div class="titlepage"><div><div><h3 class="title">2.2.2. Implicit and Hybrid Flow</h3></div></div></div><p>
					By default, the JavaScript adapter uses the <a class="link" href="https://openid.net/specs/openid-connect-core-1_0.html#CodeFlowAuth">Authorization Code</a> flow.
				</p><p>
					With this flow the Red Hat Single Sign-On server returns an authorization code, not an authentication token, to the application. The JavaScript adapter exchanges the <code class="literal">code</code> for an access token and a refresh token after the browser is redirected back to the application.
				</p><p>
					Red Hat Single Sign-On also supports the <a class="link" href="https://openid.net/specs/openid-connect-core-1_0.html#ImplicitFlowAuth">Implicit</a> flow where an access token is sent immediately after successful authentication with Red Hat Single Sign-On. This may have better performance than standard flow, as there is no additional request to exchange the code for tokens, but it has implications when the access token expires.
				</p><p>
					However, sending the access token in the URL fragment can be a security vulnerability. For example the token could be leaked through web server logs and or browser history.
				</p><p>
					To enable implicit flow, you need to enable the <code class="literal">Implicit Flow Enabled</code> flag for the client in the Red Hat Single Sign-On Administration Console. You also need to pass the parameter <code class="literal">flow</code> with value <code class="literal">implicit</code> to <code class="literal">init</code> method:
				</p><pre class="programlisting language-javascript">keycloak.init({
    flow: 'implicit'
})</pre><p>
					One thing to note is that only an access token is provided and there is no refresh token. This means that once the access token has expired the application has to do the redirect to the Red Hat Single Sign-On again to obtain a new access token.
				</p><p>
					Red Hat Single Sign-On also supports the <a class="link" href="https://openid.net/specs/openid-connect-core-1_0.html#HybridFlowAuth">Hybrid</a> flow.
				</p><p>
					This requires the client to have both the <code class="literal">Standard Flow Enabled</code> and <code class="literal">Implicit Flow Enabled</code> flags enabled in the admin console. The Red Hat Single Sign-On server will then send both the code and tokens to your application. The access token can be used immediately while the code can be exchanged for access and refresh tokens. Similar to the implicit flow, the hybrid flow is good for performance because the access token is available immediately. But, the token is still sent in the URL, and the security vulnerability mentioned earlier may still apply.
				</p><p>
					One advantage in the Hybrid flow is that the refresh token is made available to the application.
				</p><p>
					For the Hybrid flow, you need to pass the parameter <code class="literal">flow</code> with value <code class="literal">hybrid</code> to the <code class="literal">init</code> method:
				</p><pre class="programlisting language-javascript">keycloak.init({
    flow: 'hybrid'
})</pre></section><section class="section" id="hybrid-apps-with-cordova"><div class="titlepage"><div><div><h3 class="title">2.2.3. Hybrid Apps with Cordova</h3></div></div></div><p>
					Keycloak support hybrid mobile apps developed with <a class="link" href="https://cordova.apache.org/">Apache Cordova</a>. The JavaScript adapter has two modes for this: <code class="literal">cordova</code> and <code class="literal">cordova-native</code>:
				</p><p>
					The default is cordova, which the adapter will automatically select if no adapter type has been configured and window.cordova is present. When logging in, it will open an <a class="link" href="https://cordova.apache.org/docs/en/latest/reference/cordova-plugin-inappbrowser/">InApp Browser</a> that lets the user interact with Red Hat Single Sign-On and afterwards returns to the app by redirecting to <code class="literal"><a class="link" href="http://localhost">http://localhost</a></code>. Because of this, you must whitelist this URL as a valid redirect-uri in the client configuration section of the Administration Console.
				</p><p>
					While this mode is easy to setup, it also has some disadvantages:
				</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">
							The InApp-Browser is a browser embedded in the app and is not the phone’s default browser. Therefore it will have different settings and stored credentials will not be available.
						</li><li class="listitem">
							The InApp-Browser might also be slower, especially when rendering more complex themes.
						</li><li class="listitem">
							There are security concerns to consider, before using this mode, such as that it is possible for the app to gain access to the credentials of the user, as it has full control of the browser rendering the login page, so do not allow its use in apps you do not trust.
						</li></ul></div><p>
					Use this example app to help you get started: <a class="link" href="https://github.com/keycloak/keycloak/tree/master/examples/cordova">https://github.com/keycloak/keycloak/tree/master/examples/cordova</a>
				</p><p>
					The alternative mode <code class="literal">cordova-native</code> takes a different approach. It opens the login page using the system’s browser. After the user has authenticated, the browser redirects back into the app using a special URL. From there, the Red Hat Single Sign-On adapter can finish the login by reading the code or token from the URL.
				</p><p>
					You can activate the native mode by passing the adapter type <code class="literal">cordova-native</code> to the <code class="literal">init</code> method:
				</p><pre class="programlisting language-javascript">keycloak.init({
    adapter: 'cordova-native'
})</pre><p>
					This adapter required two additional plugins:
				</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">
							<a class="link" href="https://github.com/google/cordova-plugin-browsertab">cordova-plugin-browsertab</a>: allows the app to open webpages in the system’s browser
						</li><li class="listitem">
							<a class="link" href="https://github.com/e-imaxina/cordova-plugin-deeplinks">cordova-plugin-deeplinks</a>: allow the browser to redirect back to your app by special URLs
						</li></ul></div><p>
					The technical details for linking to an app differ on each platform and special setup is needed. Please refer to the Android and iOS sections of the <a class="link" href="https://github.com/e-imaxina/cordova-plugin-deeplinks/blob/master/README.md">deeplinks plugin documentation</a> for further instructions.
				</p><p>
					There are different kinds of links for opening apps: custom schemes (i.e. <code class="literal">myapp://login</code> or <code class="literal">android-app://com.example.myapp/https/example.com/login</code>) and <a class="link" href="https://developer.apple.com/ios/universal-links/">Universal Links (iOS)</a>) / <a class="link" href="https://developer.android.com/training/app-links/deep-linking">Deep Links (Android)</a>. While the former are easier to setup and tend to work more reliably, the later offer extra security as they are unique and only the owner of a domain can register them. Custom-URLs are deprecated on iOS. We recommend that you use universal links, combined with a fallback site with a custom-url link on it for best reliability.
				</p><p>
					Furthermore, we recommend the following steps to improve compatibility with the Keycloak Adapter:
				</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">
							Universal Links on iOS seem to work more reliably with <code class="literal">response-mode</code> set to <code class="literal">query</code>
						</li><li class="listitem">
							To prevent Android from opening a new instance of your app on redirect add the following snippet to <code class="literal">config.xml</code>:
						</li></ul></div><pre class="programlisting language-xml">&lt;preference name="AndroidLaunchMode" value="singleTask" /&gt;</pre><p>
					There is an example app that shows how to use the native-mode: <a class="link" href="https://github.com/keycloak/keycloak/tree/master/examples/cordova-native">https://github.com/keycloak/keycloak/tree/master/examples/cordova-native</a>
				</p></section><section class="section" id="earlier_browsers"><div class="titlepage"><div><div><h3 class="title">2.2.4. Earlier Browsers</h3></div></div></div><p>
					The JavaScript adapter depends on Base64 (window.btoa and window.atob), HTML5 History API and optionally the Promise API. If you need to support browsers that do not have these available (for example, IE9) you need to add polyfillers.
				</p><p>
					Example polyfill libraries:
				</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">
							Base64 - <a class="link" href="https://github.com/davidchambers/Base64.js">https://github.com/davidchambers/Base64.js</a>
						</li><li class="listitem">
							HTML5 History - <a class="link" href="https://github.com/devote/HTML5-History-API">https://github.com/devote/HTML5-History-API</a>
						</li><li class="listitem">
							Promise - <a class="link" href="https://github.com/stefanpenner/es6-promise">https://github.com/stefanpenner/es6-promise</a>
						</li></ul></div></section><section class="section" id="javascript_adapter_reference"><div class="titlepage"><div><div><h3 class="title">2.2.5. JavaScript Adapter Reference</h3></div></div></div><section class="section" id="constructor"><div class="titlepage"><div><div><h4 class="title">2.2.5.1. Constructor</h4></div></div></div><pre class="programlisting language-javascript">new Keycloak();
new Keycloak('http://localhost/keycloak.json');
new Keycloak({ url: 'http://localhost/auth', realm: 'myrealm', clientId: 'myApp' });</pre></section><section class="section" id="properties"><div class="titlepage"><div><div><h4 class="title">2.2.5.2. Properties</h4></div></div></div><div class="variablelist"><dl class="variablelist"><dt><span class="term">authenticated</span></dt><dd>
									Is <code class="literal">true</code> if the user is authenticated, <code class="literal">false</code> otherwise.
								</dd><dt><span class="term">token</span></dt><dd>
									The base64 encoded token that can be sent in the <code class="literal">Authorization</code> header in requests to services.
								</dd><dt><span class="term">tokenParsed</span></dt><dd>
									The parsed token as a JavaScript object.
								</dd><dt><span class="term">subject</span></dt><dd>
									The user id.
								</dd><dt><span class="term">idToken</span></dt><dd>
									The base64 encoded ID token.
								</dd><dt><span class="term">idTokenParsed</span></dt><dd>
									The parsed id token as a JavaScript object.
								</dd><dt><span class="term">realmAccess</span></dt><dd>
									The realm roles associated with the token.
								</dd><dt><span class="term">resourceAccess</span></dt><dd>
									The resource roles associated with the token.
								</dd><dt><span class="term">refreshToken</span></dt><dd>
									The base64 encoded refresh token that can be used to retrieve a new token.
								</dd><dt><span class="term">refreshTokenParsed</span></dt><dd>
									The parsed refresh token as a JavaScript object.
								</dd><dt><span class="term">timeSkew</span></dt><dd>
									The estimated time difference between the browser time and the Red Hat Single Sign-On server in seconds. This value is just an estimation, but is accurate enough when determining if a token is expired or not.
								</dd><dt><span class="term">responseMode</span></dt><dd>
									Response mode passed in init (default value is fragment).
								</dd><dt><span class="term">flow</span></dt><dd>
									Flow passed in init.
								</dd><dt><span class="term">adapter</span></dt><dd><p class="simpara">
									Allows you to override the way that redirects and other browser-related functions will be handled by the library. Available options:
								</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">
											"default" - the library uses the browser api for redirects (this is the default)
										</li><li class="listitem">
											"cordova" - the library will try to use the InAppBrowser cordova plugin to load keycloak login/registration pages (this is used automatically when the library is working in a cordova ecosystem)
										</li><li class="listitem">
											"cordova-native" - the library tries to open the login and registration page using the phone’s system browser using the BrowserTabs cordova plugin. This requires extra setup for redirecting back to the app (see <a class="xref" href="#hybrid-apps-with-cordova" title="2.2.3. Hybrid Apps with Cordova">Section 2.2.3, “Hybrid Apps with Cordova”</a>).
										</li><li class="listitem">
											custom - allows you to implement a custom adapter (only for advanced use cases)
										</li></ul></div></dd><dt><span class="term">responseType</span></dt><dd>
									Response type sent to Red Hat Single Sign-On with login requests. This is determined based on the flow value used during initialization, but can be overridden by setting this value.
								</dd></dl></div></section><section class="section" id="methods"><div class="titlepage"><div><div><h4 class="title">2.2.5.3. Methods</h4></div></div></div><section class="section" id="init_options"><div class="titlepage"><div><div><h5 class="title">2.2.5.3.1. init(options)</h5></div></div></div><p>
							Called to initialize the adapter.
						</p><p>
							Options is an Object, where:
						</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">
									useNonce - Adds a cryptographic nonce to verify that the authentication response matches the request (default is true).
								</li><li class="listitem">
									onLoad - Specifies an action to do on load. Supported values are <code class="literal">login-required</code> or <code class="literal">check-sso</code>.
								</li><li class="listitem">
									silentCheckSsoRedirectUri - Set the redirect uri for silent authentication check if onLoad is set to 'check-sso'.
								</li><li class="listitem">
									token - Set an initial value for the token.
								</li><li class="listitem">
									refreshToken - Set an initial value for the refresh token.
								</li><li class="listitem">
									idToken - Set an initial value for the id token (only together with token or refreshToken).
								</li><li class="listitem">
									timeSkew - Set an initial value for skew between local time and Red Hat Single Sign-On server in seconds (only together with token or refreshToken).
								</li><li class="listitem">
									checkLoginIframe - Set to enable/disable monitoring login state (default is <code class="literal">true</code>).
								</li><li class="listitem">
									checkLoginIframeInterval - Set the interval to check login state (default is 5 seconds).
								</li><li class="listitem">
									responseMode - Set the OpenID Connect response mode send to Red Hat Single Sign-On server at login request. Valid values are <code class="literal">query</code> or <code class="literal">fragment</code>. Default value is <code class="literal">fragment</code>, which means that after successful authentication will Red Hat Single Sign-On redirect to JavaScript application with OpenID Connect parameters added in URL fragment. This is generally safer and recommended over <code class="literal">query</code>.
								</li><li class="listitem">
									flow - Set the OpenID Connect flow. Valid values are <code class="literal">standard</code>, <code class="literal">implicit</code> or <code class="literal">hybrid</code>.
								</li><li class="listitem">
									enableLogging - Enables logging messages from Keycloak to the console (default is <code class="literal">false</code>).
								</li><li class="listitem"><p class="simpara">
									pkceMethod - The method for Proof Key Code Exchange (<a class="link" href="https://tools.ietf.org/html/rfc7636">PKCE</a>) to use. Configuring this value enables the PKCE mechanism. Available options:
								</p><div class="itemizedlist"><ul class="itemizedlist" type="circle"><li class="listitem">
											"S256" - The SHA256 based PKCE method
										</li></ul></div></li></ul></div><p>
							Returns a promise that resolves when initialization completes.
						</p></section><section class="section" id="login_options"><div class="titlepage"><div><div><h5 class="title">2.2.5.3.2. login(options)</h5></div></div></div><p>
							Redirects to login form on (options is an optional object with redirectUri and/or prompt fields).
						</p><p>
							Options is an Object, where:
						</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">
									redirectUri - Specifies the uri to redirect to after login.
								</li><li class="listitem">
									prompt - This parameter allows to slightly customize the login flow on the Red Hat Single Sign-On server side. For example enforce displaying the login screen in case of value <code class="literal">login</code>. See Parameters Forwarding Section for the details and all the possible values of the <code class="literal">prompt</code> parameter.
								</li><li class="listitem">
									maxAge - Used just if user is already authenticated. Specifies maximum time since the authentication of user happened. If user is already authenticated for longer time than <code class="literal">maxAge</code>, the SSO is ignored and he will need to re-authenticate again.
								</li><li class="listitem">
									loginHint - Used to pre-fill the username/email field on the login form.
								</li><li class="listitem">
									scope - Used to forward the scope parameter to the Red Hat Single Sign-On login endpoint. Use a space-delimited list of scopes. Those typically reference <a class="link" href="https://access.redhat.com/documentation/en-us/red_hat_single_sign-on/7.4/html-single/server_administration_guide/#_client_scopes">Client scopes</a> defined on particular client. Note that the scope <code class="literal">openid</code> will be always be added to the list of scopes by the adapter. For example, if you enter the scope options <code class="literal">address phone</code>, then the request to Red Hat Single Sign-On will contain the scope parameter <code class="literal">scope=openid address phone</code>.
								</li><li class="listitem">
									idpHint - Used to tell Red Hat Single Sign-On to skip showing the login page and automatically redirect to the specified identity provider instead. More info in the <a class="link" href="https://access.redhat.com/documentation/en-us/red_hat_single_sign-on/7.4/html-single/server_administration_guide/#_client_suggested_idp">Identity Provider documentation</a>.
								</li><li class="listitem">
									action - If value is <code class="literal">register</code> then user is redirected to registration page, otherwise to login page.
								</li><li class="listitem">
									locale - Sets the 'ui_locales' query param in compliance with <a class="link" href="https://openid.net/specs/openid-connect-core-1_0.html#AuthRequest">section 3.1.2.1 of the OIDC 1.0 specification</a>.
								</li><li class="listitem">
									kcLocale - Specifies the desired Keycloak locale for the UI. This differs from the locale param in that it tells the Keycloak server to set a cookie and update the user’s profile to a new preferred locale.
								</li><li class="listitem">
									cordovaOptions - Specifies the arguments that are passed to the Cordova in-app-browser (if applicable). Options <code class="literal">hidden</code> and <code class="literal">location</code> are not affected by these arguments. All available options are defined at <a class="link" href="https://cordova.apache.org/docs/en/latest/reference/cordova-plugin-inappbrowser/">https://cordova.apache.org/docs/en/latest/reference/cordova-plugin-inappbrowser/</a>. Example of use: <code class="literal">{ zoom: "no", hardwareback: "yes" }</code>;
								</li></ul></div></section><section class="section" id="createloginurl_options"><div class="titlepage"><div><div><h5 class="title">2.2.5.3.3. createLoginUrl(options)</h5></div></div></div><p>
							Returns the URL to login form on (options is an optional object with redirectUri and/or prompt fields).
						</p><p>
							Options is an Object, which supports same options like the function <code class="literal">login</code> .
						</p></section><section class="section" id="logout_options"><div class="titlepage"><div><div><h5 class="title">2.2.5.3.4. logout(options)</h5></div></div></div><p>
							Redirects to logout.
						</p><p>
							Options is an Object, where:
						</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">
									redirectUri - Specifies the uri to redirect to after logout.
								</li></ul></div></section><section class="section" id="createlogouturl_options"><div class="titlepage"><div><div><h5 class="title">2.2.5.3.5. createLogoutUrl(options)</h5></div></div></div><p>
							Returns the URL to logout the user.
						</p><p>
							Options is an Object, where:
						</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">
									redirectUri - Specifies the uri to redirect to after logout.
								</li></ul></div></section><section class="section" id="register_options"><div class="titlepage"><div><div><h5 class="title">2.2.5.3.6. register(options)</h5></div></div></div><p>
							Redirects to registration form. Shortcut for login with option action = 'register'
						</p><p>
							Options are same as for the login method but 'action' is set to 'register'
						</p></section><section class="section" id="createregisterurl_options"><div class="titlepage"><div><div><h5 class="title">2.2.5.3.7. createRegisterUrl(options)</h5></div></div></div><p>
							Returns the url to registration page. Shortcut for createLoginUrl with option action = 'register'
						</p><p>
							Options are same as for the createLoginUrl method but 'action' is set to 'register'
						</p></section><section class="section" id="accountmanagement"><div class="titlepage"><div><div><h5 class="title">2.2.5.3.8. accountManagement()</h5></div></div></div><p>
							Redirects to the Account Management Console.
						</p></section><section class="section" id="createaccounturl"><div class="titlepage"><div><div><h5 class="title">2.2.5.3.9. createAccountUrl()</h5></div></div></div><p>
							Returns the URL to the Account Management Console.
						</p></section><section class="section" id="hasrealmrole_role"><div class="titlepage"><div><div><h5 class="title">2.2.5.3.10. hasRealmRole(role)</h5></div></div></div><p>
							Returns true if the token has the given realm role.
						</p></section><section class="section" id="hasresourcerole_role_resource"><div class="titlepage"><div><div><h5 class="title">2.2.5.3.11. hasResourceRole(role, resource)</h5></div></div></div><p>
							Returns true if the token has the given role for the resource (resource is optional, if not specified clientId is used).
						</p></section><section class="section" id="loaduserprofile"><div class="titlepage"><div><div><h5 class="title">2.2.5.3.12. loadUserProfile()</h5></div></div></div><p>
							Loads the users profile.
						</p><p>
							Returns a promise that resolves with the profile.
						</p><p>
							For example:
						</p><pre class="programlisting language-javascript">keycloak.loadUserProfile()
    .then(function(profile) {
        alert(JSON.stringify(profile, null, "  "))
    }).catch(function() {
        alert('Failed to load user profile');
    });</pre></section><section class="section" id="istokenexpired_minvalidity"><div class="titlepage"><div><div><h5 class="title">2.2.5.3.13. isTokenExpired(minValidity)</h5></div></div></div><p>
							Returns true if the token has less than minValidity seconds left before it expires (minValidity is optional, if not specified 0 is used).
						</p></section><section class="section" id="updatetoken_minvalidity"><div class="titlepage"><div><div><h5 class="title">2.2.5.3.14. updateToken(minValidity)</h5></div></div></div><p>
							If the token expires within minValidity seconds (minValidity is optional, if not specified 5 is used) the token is refreshed. If the session status iframe is enabled, the session status is also checked.
						</p><p>
							Returns a promise that resolves with a boolean indicating whether or not the token has been refreshed.
						</p><p>
							For example:
						</p><pre class="programlisting language-javascript">keycloak.updateToken(5)
    .then(function(refreshed) {
        if (refreshed) {
            alert('Token was successfully refreshed');
        } else {
            alert('Token is still valid');
        }
    }).catch(function() {
        alert('Failed to refresh the token, or the session has expired');
    });</pre></section><section class="section" id="cleartoken"><div class="titlepage"><div><div><h5 class="title">2.2.5.3.15. clearToken()</h5></div></div></div><p>
							Clear authentication state, including tokens. This can be useful if application has detected the session was expired, for example if updating token fails.
						</p><p>
							Invoking this results in onAuthLogout callback listener being invoked.
						</p></section></section><section class="section" id="callback_events"><div class="titlepage"><div><div><h4 class="title">2.2.5.4. Callback Events</h4></div></div></div><p>
						The adapter supports setting callback listeners for certain events.
					</p><p>
						For example:
					</p><pre class="programlisting language-javascript">keycloak.onAuthSuccess = function() { alert('authenticated'); }</pre><p>
						The available events are:
					</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">
								onReady(authenticated) - Called when the adapter is initialized.
							</li><li class="listitem">
								onAuthSuccess - Called when a user is successfully authenticated.
							</li><li class="listitem">
								onAuthError - Called if there was an error during authentication.
							</li><li class="listitem">
								onAuthRefreshSuccess - Called when the token is refreshed.
							</li><li class="listitem">
								onAuthRefreshError - Called if there was an error while trying to refresh the token.
							</li><li class="listitem">
								onAuthLogout - Called if the user is logged out (will only be called if the session status iframe is enabled, or in Cordova mode).
							</li><li class="listitem">
								onTokenExpired - Called when the access token is expired. If a refresh token is available the token can be refreshed with updateToken, or in cases where it is not (that is, with implicit flow) you can redirect to login screen to obtain a new access token.
							</li></ul></div></section></section></section><section class="section" id="nodejs_adapter"><div class="titlepage"><div><div><h2 class="title">2.3. Node.js Adapter</h2></div></div></div><p>
				Red Hat Single Sign-On provides a Node.js adapter built on top of <a class="link" href="https://github.com/senchalabs/connect">Connect</a> to protect server-side JavaScript apps - the goal was to be flexible enough to integrate with frameworks like <a class="link" href="https://expressjs.com/">Express.js</a>.
			</p><p>
				To use the Node.js adapter, first you must create a client for your application in the Red Hat Single Sign-On Administration Console. The adapter supports public, confidential, and bearer-only access type. Which one to choose depends on the use-case scenario.
			</p><p>
				Once the client is created click the <code class="literal">Installation</code> tab, select <code class="literal">Red Hat Single Sign-On OIDC JSON</code> for <code class="literal">Format Option</code>, and then click <code class="literal">Download</code>. The downloaded <code class="literal">keycloak.json</code> file should be at the root folder of your project.
			</p><section class="section" id="installation"><div class="titlepage"><div><div><h3 class="title">2.3.1. Installation</h3></div></div></div><p>
					Assuming you’ve already installed <a class="link" href="https://nodejs.org">Node.js</a>, create a folder for your application:
				</p><pre class="literallayout">mkdir myapp &amp;&amp; cd myapp</pre><p>
					Use <code class="literal">npm init</code> command to create a <code class="literal">package.json</code> for your application. Now add the Red Hat Single Sign-On connect adapter in the dependencies list:
				</p><pre class="programlisting language-json">    "dependencies": {
        "keycloak-connect": "file:keycloak-connect-4.8.3.Final-redhat-00001.tgz"
    }</pre></section><section class="section" id="usage"><div class="titlepage"><div><div><h3 class="title">2.3.2. Usage</h3></div></div></div><div class="variablelist"><dl class="variablelist"><dt><span class="term">Instantiate a Keycloak class</span></dt><dd>
								The <code class="literal">Keycloak</code> class provides a central point for configuration and integration with your application. The simplest creation involves no arguments.
							</dd></dl></div><pre class="programlisting language-javascript">    var session = require('express-session');
    var Keycloak = require('keycloak-connect');

    var memoryStore = new session.MemoryStore();
    var keycloak = new Keycloak({ store: memoryStore });</pre><p>
					By default, this will locate a file named <code class="literal">keycloak.json</code> alongside the main executable of your application to initialize keycloak-specific settings (public key, realm name, various URLs). The <code class="literal">keycloak.json</code> file is obtained from the Red Hat Single Sign-On Admin Console.
				</p><p>
					Instantiation with this method results in all of the reasonable defaults being used. As alternative, it’s also possible to provide a configuration object, rather than the <code class="literal">keycloak.json</code> file:
				</p><pre class="programlisting language-javascript">    let kcConfig = {
        clientId: 'myclient',
        bearerOnly: true,
        serverUrl: 'http://localhost:8080/auth',
        realm: 'myrealm',
        realmPublicKey: 'MIIBIjANB...'
    };

    let keycloak = new Keycloak({ store: memoryStore }, kcConfig);</pre><p>
					Applications can also redirect users to their preferred identity provider by using:
				</p><pre class="programlisting language-javascript">    let keycloak = new Keycloak({ store: memoryStore, idpHint: myIdP }, kcConfig);</pre><div class="variablelist"><dl class="variablelist"><dt><span class="term">Configuring a web session store</span></dt><dd>
								If you want to use web sessions to manage server-side state for authentication, you need to initialize the <code class="literal">Keycloak(…​)</code> with at least a <code class="literal">store</code> parameter, passing in the actual session store that <code class="literal">express-session</code> is using.
							</dd></dl></div><pre class="programlisting language-javascript">    var session = require('express-session');
    var memoryStore = new session.MemoryStore();

    var keycloak = new Keycloak({ store: memoryStore });</pre><div class="variablelist"><dl class="variablelist"><dt><span class="term">Passing a custom scope value</span></dt><dd>
								By default, the scope value <code class="literal">openid</code> is passed as a query parameter to Red Hat Single Sign-On’s login URL, but you can add an additional custom value:
							</dd></dl></div><pre class="programlisting language-javascript">    var keycloak = new Keycloak({ scope: 'offline_access' });</pre></section><section class="section" id="installing_middleware"><div class="titlepage"><div><div><h3 class="title">2.3.3. Installing Middleware</h3></div></div></div><p>
					Once instantiated, install the middleware into your connect-capable app:
				</p><pre class="programlisting language-javascript">    var app = express();

    app.use( keycloak.middleware() );</pre></section><section class="section" id="checking_authentication"><div class="titlepage"><div><div><h3 class="title">2.3.4. Checking Authentication</h3></div></div></div><p>
					To check that a user is authenticated before accessing a resource, simply use <code class="literal">keycloak.checkSso()</code>. It will only authenticate if the user is already logged-in. If the user is not logged-in, the browser will be redirected back to the originally-requested URL and remain unauthenticated:
				</p><pre class="programlisting language-javascript">    app.get( '/check-sso', keycloak.checkSso(), checkSsoHandler );</pre></section><section class="section" id="protecting_resources"><div class="titlepage"><div><div><h3 class="title">2.3.5. Protecting Resources</h3></div></div></div><div class="variablelist"><dl class="variablelist"><dt><span class="term">Simple authentication</span></dt><dd>
								To enforce that a user must be authenticated before accessing a resource, simply use a no-argument version of <code class="literal">keycloak.protect()</code>:
							</dd></dl></div><pre class="programlisting language-javascript">    app.get( '/complain', keycloak.protect(), complaintHandler );</pre><div class="variablelist"><dl class="variablelist"><dt><span class="term">Role-based authorization</span></dt><dd>
								To secure a resource with an application role for the current app:
							</dd></dl></div><pre class="programlisting language-javascript">    app.get( '/special', keycloak.protect('special'), specialHandler );</pre><p>
					To secure a resource with an application role for a <span class="strong strong"><strong>different</strong></span> app:
				</p><pre class="programlisting language-javascript">    app.get( '/extra-special', keycloak.protect('other-app:special'), extraSpecialHandler );</pre><p>
					To secure a resource with a realm role:
				</p><pre class="programlisting language-javascript">    app.get( '/admin', keycloak.protect( 'realm:admin' ), adminHandler );</pre><div class="variablelist"><dl class="variablelist"><dt><span class="term">Resource-Based Authorization</span></dt><dd>
								Resource-Based Authorization allows you to protect resources, and their specific methods/actions,<span class="strong strong"><strong>*</strong></span>* based on a set of policies defined in Keycloak, thus externalizing authorization from your application. This is achieved by exposing a <code class="literal">keycloak.enforcer</code> method which you can use to protect resources.*
							</dd></dl></div><pre class="programlisting language-javascript">    app.get('/apis/me', keycloak.enforcer('user:profile'), userProfileHandler);</pre><p>
					The <code class="literal">keycloak-enforcer</code> method operates in two modes, depending on the value of the <code class="literal">response_mode</code> configuration option.
				</p><pre class="programlisting language-javascript">    app.get('/apis/me', keycloak.enforcer('user:profile', {response_mode: 'token'}), userProfileHandler);</pre><p>
					If <code class="literal">response_mode</code> is set to <code class="literal">token</code>, permissions are obtained from the server on behalf of the subject represented by the bearer token that was sent to your application. In this case, a new access token is issued by Keycloak with the permissions granted by the server. If the server did not respond with a token with the expected permissions, the request is denied. When using this mode, you should be able to obtain the token from the request as follows:
				</p><pre class="programlisting language-javascript">    app.get('/apis/me', keycloak.enforcer('user:profile', {response_mode: 'token'}), function (req, res) {
        var token = var token = req.kauth.grant.access_token.content;
        var permissions = token.authorization ? token.authorization.permissions : undefined;

        // show user profile
    });</pre><p>
					Prefer this mode when your application is using sessions and you want to cache previous decisions from the server, as well automatically handle refresh tokens. This mode is especially useful for applications acting as a client and resource server.
				</p><p>
					If <code class="literal">response_mode</code> is set to <code class="literal">permissions</code> (default mode), the server only returns the list of granted permissions, without issuing a new access token. In addition to not issuing a new token, this method exposes the permissions granted by the server through the <code class="literal">request</code> as follows:
				</p><pre class="programlisting language-javascript">    app.get('/apis/me', keycloak.enforcer('user:profile', {response_mode: 'token'}), function (req, res) {
        var permissions = req.permissions;

        // show user profile
    });</pre><p>
					Regardless of the <code class="literal">response_mode</code> in use, the <code class="literal">keycloak.enforcer</code> method will first try to check the permissions within the bearer token that was sent to your application. If the bearer token already carries the expected permissions, there is no need to interact with the server to obtain a decision. This is specially useful when your clients are capable of obtaining access tokens from the server with the expected permissions before accessing a protected resource, so they can use some capabilities provided by Keycloak Authorization Services such as incremental authorization and avoid additional requests to the server when <code class="literal">keycloak.enforcer</code> is enforcing access to the resource.
				</p><p>
					By default, the policy enforcer will use the <code class="literal">client_id</code> defined to the application (for instance, via <code class="literal">keycloak.json</code>) to reference a client in Keycloak that supports Keycloak Authorization Services. In this case, the client can not be public given that it is actually a resource server.
				</p><p>
					If your application is acting as both a public client(frontend) and resource server(backend), you can use the following configuration to reference a different client in Keycloak with the policies that you want to enforce:
				</p><pre class="programlisting language-javascript">      keycloak.enforcer('user:profile', {resource_server_id: 'my-apiserver'})</pre><p>
					It is recommended to use distinct clients in Keycloak to represent your frontend and backend.
				</p><p>
					If the application you are protecting is enabled with Keycloak authorization services and you have defined client credentials in <code class="literal">keycloak.json</code>, you can push additional claims to the server and make them available to your policies in order to make decisions. For that, you can define a <code class="literal">claims</code> configuration option which expects a <code class="literal">function</code> that returns a JSON with the claims you want to push:
				</p><pre class="programlisting language-javascript">      app.get('/protected/resource', keycloak.enforcer(['resource:view', 'resource:write'], {
          claims: function(request) {
            return {
              "http.uri": ["/protected/resource"],
              "user.agent": // get user agent  from request
            }
          }
        }), function (req, res) {
          // access granted</pre><p>
					For more details about how to configure Keycloak to protected your application resources, please take a look at the <a class="link" href="https://access.redhat.com/documentation/en-us/red_hat_single_sign-on/7.4/html-single/authorization_services_guide/">Authorization Services Guide</a>.
				</p><div class="variablelist"><dl class="variablelist"><dt><span class="term">Advanced authorization</span></dt><dd>
								To secure resources based on parts of the URL itself, assuming a role exists for each section:
							</dd></dl></div><pre class="programlisting language-javascript">    function protectBySection(token, request) {
      return token.hasRole( request.params.section );
    }

    app.get( '/:section/:page', keycloak.protect( protectBySection ), sectionHandler );</pre></section><section class="section" id="additional_urls"><div class="titlepage"><div><div><h3 class="title">2.3.6. Additional URLs</h3></div></div></div><div class="variablelist"><dl class="variablelist"><dt><span class="term">Explicit user-triggered logout</span></dt><dd>
								By default, the middleware catches calls to <code class="literal">/logout</code> to send the user through a Red Hat Single Sign-On-centric logout workflow. This can be changed by specifying a <code class="literal">logout</code> configuration parameter to the <code class="literal">middleware()</code> call:
							</dd></dl></div><pre class="programlisting language-javascript">    app.use( keycloak.middleware( { logout: '/logoff' } ));</pre><div class="variablelist"><dl class="variablelist"><dt><span class="term">Red Hat Single Sign-On Admin Callbacks</span></dt><dd>
								Also, the middleware supports callbacks from the Red Hat Single Sign-On console to log out a single session or all sessions. By default, these type of admin callbacks occur relative to the root URL of <code class="literal">/</code> but can be changed by providing an <code class="literal">admin</code> parameter to the <code class="literal">middleware()</code> call:
							</dd></dl></div><pre class="programlisting language-javascript">    app.use( keycloak.middleware( { admin: '/callbacks' } );</pre></section></section><section class="section" id="other_openid_connect_libraries"><div class="titlepage"><div><div><h2 class="title">2.4. Other OpenID Connect Libraries</h2></div></div></div><p>
				Red Hat Single Sign-On can be secured by supplied adapters that are usually easier to use and provide better integration with Red Hat Single Sign-On. However, if an adapter is not available for your programming language, framework, or platform you might opt to use a generic OpenID Connect Relying Party (RP) library instead. This chapter describes details specific to Red Hat Single Sign-On and does not contain specific protocol details. For more information see the <a class="link" href="https://openid.net/connect/">OpenID Connect specifications</a> and <a class="link" href="https://tools.ietf.org/html/rfc6749">OAuth2 specification</a>.
			</p><section class="section" id="endpoints"><div class="titlepage"><div><div><h3 class="title">2.4.1. Endpoints</h3></div></div></div><p>
					The most important endpoint to understand is the <code class="literal">well-known</code> configuration endpoint. It lists endpoints and other configuration options relevant to the OpenID Connect implementation in Red Hat Single Sign-On. The endpoint is:
				</p><pre class="literallayout">/realms/{realm-name}/.well-known/openid-configuration</pre><p>
					To obtain the full URL, add the base URL for Red Hat Single Sign-On and replace <code class="literal">{realm-name}</code> with the name of your realm. For example:
				</p><p>
					http://localhost:8080/auth/realms/master/.well-known/openid-configuration
				</p><p>
					Some RP libraries retrieve all required endpoints from this endpoint, but for others you might need to list the endpoints individually.
				</p><section class="section" id="authorization_endpoint"><div class="titlepage"><div><div><h4 class="title">2.4.1.1. Authorization Endpoint</h4></div></div></div><pre class="literallayout">/realms/{realm-name}/protocol/openid-connect/auth</pre><p>
						The authorization endpoint performs authentication of the end-user. This is done by redirecting the user agent to this endpoint.
					</p><p>
						For more details see the <a class="link" href="https://openid.net/specs/openid-connect-core-1_0.html#AuthorizationEndpoint">Authorization Endpoint</a> section in the OpenID Connect specification.
					</p></section><section class="section" id="token_endpoint"><div class="titlepage"><div><div><h4 class="title">2.4.1.2. Token Endpoint</h4></div></div></div><pre class="literallayout">/realms/{realm-name}/protocol/openid-connect/token</pre><p>
						The token endpoint is used to obtain tokens. Tokens can either be obtained by exchanging an authorization code or by supplying credentials directly depending on what flow is used. The token endpoint is also used to obtain new access tokens when they expire.
					</p><p>
						For more details see the <a class="link" href="https://openid.net/specs/openid-connect-core-1_0.html#TokenEndpoint">Token Endpoint</a> section in the OpenID Connect specification.
					</p></section><section class="section" id="userinfo_endpoint"><div class="titlepage"><div><div><h4 class="title">2.4.1.3. Userinfo Endpoint</h4></div></div></div><pre class="literallayout">/realms/{realm-name}/protocol/openid-connect/userinfo</pre><p>
						The userinfo endpoint returns standard claims about the authenticated user, and is protected by a bearer token.
					</p><p>
						For more details see the <a class="link" href="https://openid.net/specs/openid-connect-core-1_0.html#UserInfo">Userinfo Endpoint</a> section in the OpenID Connect specification.
					</p></section><section class="section" id="logout_endpoint"><div class="titlepage"><div><div><h4 class="title">2.4.1.4. Logout Endpoint</h4></div></div></div><pre class="literallayout">/realms/{realm-name}/protocol/openid-connect/logout</pre><p>
						The logout endpoint logs out the authenticated user.
					</p><p>
						The user agent can be redirected to the endpoint, in which case the active user session is logged out. Afterward the user agent is redirected back to the application.
					</p><p>
						The endpoint can also be invoked directly by the application. To invoke this endpoint directly the refresh token needs to be included as well as the credentials required to authenticate the client.
					</p></section><section class="section" id="certificate_endpoint"><div class="titlepage"><div><div><h4 class="title">2.4.1.5. Certificate Endpoint</h4></div></div></div><pre class="literallayout">/realms/{realm-name}/protocol/openid-connect/certs</pre><p>
						The certificate endpoint returns the public keys enabled by the realm, encoded as a JSON Web Key (JWK). Depending on the realm settings there can be one or more keys enabled for verifying tokens. For more information see the <a class="link" href="https://access.redhat.com/documentation/en-us/red_hat_single_sign-on/7.4/html-single/server_administration_guide/">Server Administration Guide</a> and the <a class="link" href="https://tools.ietf.org/html/rfc7517">JSON Web Key specification</a>.
					</p></section><section class="section" id="token_introspection_endpoint"><div class="titlepage"><div><div><h4 class="title">2.4.1.6. Introspection Endpoint</h4></div></div></div><pre class="literallayout">/realms/{realm-name}/protocol/openid-connect/token/introspect</pre><p>
						The introspection endpoint is used to retrieve the active state of a token. In other words, you can use it to validate an access or refresh token. It can only be invoked by confidential clients.
					</p><p>
						For more details on how to invoke on this endpoint, see <a class="link" href="https://tools.ietf.org/html/rfc7662">OAuth 2.0 Token Introspection specification</a>.
					</p></section><section class="section" id="dynamic_client_registration_endpoint"><div class="titlepage"><div><div><h4 class="title">2.4.1.7. Dynamic Client Registration Endpoint</h4></div></div></div><pre class="literallayout">/realms/{realm-name}/clients-registrations/openid-connect</pre><p>
						The dynamic client registration endpoint is used to dynamically register clients.
					</p><p>
						For more details see the <a class="link" href="#client_registration" title="Chapter 5. Client Registration">Client Registration chapter</a> and the <a class="link" href="https://openid.net/specs/openid-connect-registration-1_0.html">OpenID Connect Dynamic Client Registration specification</a>.
					</p></section></section><section class="section" id="validating_access_tokens"><div class="titlepage"><div><div><h3 class="title">2.4.2. Validating Access Tokens</h3></div></div></div><p>
					If you need to manually validate access tokens issued by Red Hat Single Sign-On you can invoke the <a class="link" href="#token_introspection_endpoint" title="2.4.1.6. Introspection Endpoint">Introspection Endpoint</a>. The downside to this approach is that you have to make a network invocation to the Red Hat Single Sign-On server. This can be slow and possibily overload the server if you have too many validation requests going on at the same time. Red Hat Single Sign-On issued access tokens are <a class="link" href="https://tools.ietf.org/html/rfc7519">JSON Web Tokens (JWT)</a> digitally signed and encoded using <a class="link" href="https://www.rfc-editor.org/rfc/rfc7515.txt">JSON Web Signature (JWS)</a>. Because they are encoded in this way, this allows you to locally validate access tokens using the public key of the issuing realm. You can either hard code the realm’s public key in your validation code, or lookup and cache the public key using the <a class="link" href="#certificate_endpoint" title="2.4.1.5. Certificate Endpoint">certificate endpoint</a> with the Key ID (KID) embedded within the JWS. Depending what language you code in, there are a multitude of third party libraries out there that can help you with JWS validation.
				</p></section><section class="section" id="flows"><div class="titlepage"><div><div><h3 class="title">2.4.3. Flows</h3></div></div></div><section class="section" id="authorization_code"><div class="titlepage"><div><div><h4 class="title">2.4.3.1. Authorization Code</h4></div></div></div><p>
						The Authorization Code flow redirects the user agent to Red Hat Single Sign-On. Once the user has successfully authenticated with Red Hat Single Sign-On an Authorization Code is created and the user agent is redirected back to the application. The application then uses the authorization code along with its credentials to obtain an Access Token, Refresh Token and ID Token from Red Hat Single Sign-On.
					</p><p>
						The flow is targeted towards web applications, but is also recommended for native applications, including mobile applications, where it is possible to embed a user agent.
					</p><p>
						For more details refer to the <a class="link" href="https://openid.net/specs/openid-connect-core-1_0.html#CodeFlowAuth">Authorization Code Flow</a> in the OpenID Connect specification.
					</p></section><section class="section" id="implicit"><div class="titlepage"><div><div><h4 class="title">2.4.3.2. Implicit</h4></div></div></div><p>
						The Implicit flow redirects works similarly to the Authorization Code flow, but instead of returning an Authorization Code the Access Token and ID Token is returned. This reduces the need for the extra invocation to exchange the Authorization Code for an Access Token. However, it does not include a Refresh Token. This results in the need to either permit Access Tokens with a long expiration, which is problematic as it’s very hard to invalidate these. Or requires a new redirect to obtain new Access Token once the initial Access Token has expired. The Implicit flow is useful if the application only wants to authenticate the user and deals with logout itself.
					</p><p>
						There’s also a Hybrid flow where both the Access Token and an Authorization Code is returned.
					</p><p>
						One thing to note is that both the Implicit flow and Hybrid flow has potential security risks as the Access Token may be leaked through web server logs and browser history. This is somewhat mitigated by using short expiration for Access Tokens.
					</p><p>
						For more details refer to the <a class="link" href="https://openid.net/specs/openid-connect-core-1_0.html#ImplicitFlowAuth">Implicit Flow</a> in the OpenID Connect specification.
					</p></section><section class="section" id="resource_owner_password_credentials_flow"><div class="titlepage"><div><div><h4 class="title">2.4.3.3. Resource Owner Password Credentials</h4></div></div></div><p>
						Resource Owner Password Credentials, referred to as Direct Grant in Red Hat Single Sign-On, allows exchanging user credentials for tokens. It’s not recommended to use this flow unless you absolutely need to. Examples where this could be useful are legacy applications and command-line interfaces.
					</p><p>
						There are a number of limitations of using this flow, including:
					</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">
								User credentials are exposed to the application
							</li><li class="listitem">
								Applications need login pages
							</li><li class="listitem">
								Application needs to be aware of the authentication scheme
							</li><li class="listitem">
								Changes to authentication flow requires changes to application
							</li><li class="listitem">
								No support for identity brokering or social login
							</li><li class="listitem">
								Flows are not supported (user self-registration, required actions, etc.)
							</li></ul></div><p>
						For a client to be permitted to use the Resource Owner Password Credentials grant the client has to have the <code class="literal">Direct Access Grants Enabled</code> option enabled.
					</p><p>
						This flow is not included in OpenID Connect, but is a part of the OAuth 2.0 specification.
					</p><p>
						For more details refer to the <a class="link" href="https://tools.ietf.org/html/rfc6749#section-4.3">Resource Owner Password Credentials Grant</a> chapter in the OAuth 2.0 specification.
					</p><section class="section" id="example_using_curl"><div class="titlepage"><div><div><h5 class="title">2.4.3.3.1. Example using CURL</h5></div></div></div><p>
							The following example shows how to obtain an access token for a user in the realm <code class="literal">master</code> with username <code class="literal">user</code> and password <code class="literal">password</code>. The example is using the confidential client <code class="literal">myclient</code>:
						</p><pre class="programlisting language-bash">curl \
  -d "client_id=myclient" \
  -d "client_secret=40cc097b-2a57-4c17-b36a-8fdf3fc2d578" \
  -d "username=user" \
  -d "password=password" \
  -d "grant_type=password" \
  "http://localhost:8080/auth/realms/master/protocol/openid-connect/token"</pre></section></section><section class="section" id="client_credentials"><div class="titlepage"><div><div><h4 class="title">2.4.3.4. Client Credentials</h4></div></div></div><p>
						Client Credentials is used when clients (applications and services) wants to obtain access on behalf of themselves rather than on behalf of a user. This can for example be useful for background services that applies changes to the system in general rather than for a specific user.
					</p><p>
						Red Hat Single Sign-On provides support for clients to authenticate either with a secret or with public/private keys.
					</p><p>
						This flow is not included in OpenID Connect, but is a part of the OAuth 2.0 specification.
					</p><p>
						For more details refer to the <a class="link" href="https://tools.ietf.org/html/rfc6749#section-4.4">Client Credentials Grant</a> chapter in the OAuth 2.0 specification.
					</p></section></section><section class="section" id="redirect_uris"><div class="titlepage"><div><div><h3 class="title">2.4.4. Redirect URIs</h3></div></div></div><p>
					When using the redirect based flows it’s important to use valid redirect uris for your clients. The redirect uris should be as specific as possible. This especially applies to client-side (public clients) applications. Failing to do so could result in:
				</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">
							Open redirects - this can allow attackers to create spoof links that looks like they are coming from your domain
						</li><li class="listitem">
							Unauthorized entry - when users are already authenticated with Red Hat Single Sign-On an attacker can use a public client where redirect uris have not be configured correctly to gain access by redirecting the user without the users knowledge
						</li></ul></div><p>
					In production for web applications always use <code class="literal">https</code> for all redirect URIs. Do not allow redirects to http.
				</p><p>
					There’s also a few special redirect URIs:
				</p><div class="variablelist" id="installed_applications_url"><dl class="variablelist"><dt><span class="term"><code class="literal">http://localhost</code></span></dt><dd>
								This redirect URI is useful for native applications and allows the native application to create a web server on a random port that can be used to obtain the authorization code. This redirect uri allows any port.
							</dd></dl></div><div class="variablelist" id="installed_applications_urn"><dl class="variablelist"><dt><span class="term"><code class="literal">urn:ietf:wg:oauth:2.0:oob</code></span></dt><dd>
								If its not possible to start a web server in the client (or a browser is not available) it is possible to use the special <code class="literal">urn:ietf:wg:oauth:2.0:oob</code> redirect uri. When this redirect uri is used Red Hat Single Sign-On displays a page with the code in the title and in a box on the page. The application can either detect that the browser title has changed, or the user can copy/paste the code manually to the application. With this redirect uri it is also possible for a user to use a different device to obtain a code to paste back to the application.
							</dd></dl></div></section></section></section><section class="chapter" id="saml_2"><div class="titlepage"><div><div><h1 class="title">Chapter 3. SAML</h1></div></div></div><p>
			This section describes how you can secure applications and services with SAML using either Red Hat Single Sign-On client adapters or generic SAML provider libraries.
		</p><section class="section" id="java_adapters_2"><div class="titlepage"><div><div><h2 class="title">3.1. Java Adapters</h2></div></div></div><p>
				Red Hat Single Sign-On comes with a range of different adapters for Java application. Selecting the correct adapter depends on the target platform.
			</p><section class="section" id="saml-general-config"><div class="titlepage"><div><div><h3 class="title">3.1.1. General Adapter Config</h3></div></div></div><p>
					Each SAML client adapter supported by Red Hat Single Sign-On can be configured by a simple XML text file. This is what one might look like:
				</p><pre class="programlisting language-xml">&lt;keycloak-saml-adapter xmlns="urn:keycloak:saml:adapter"
                       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
                       xsi:schemaLocation="urn:keycloak:saml:adapter https://www.keycloak.org/schema/keycloak_saml_adapter_1_10.xsd"&gt;
    &lt;SP entityID="http://localhost:8081/sales-post-sig/"
        sslPolicy="EXTERNAL"
        nameIDPolicyFormat="urn:oasis:names:tc:SAML:1.1:nameid-format:unspecified"
        logoutPage="/logout.jsp"
        forceAuthentication="false"
        isPassive="false"
        turnOffChangeSessionIdOnLogin="false"
        autodetectBearerOnly="false"&gt;
        &lt;Keys&gt;
            &lt;Key signing="true" &gt;
                &lt;KeyStore resource="/WEB-INF/keystore.jks" password="store123"&gt;
                    &lt;PrivateKey alias="http://localhost:8080/sales-post-sig/" password="test123"/&gt;
                    &lt;Certificate alias="http://localhost:8080/sales-post-sig/"/&gt;
                &lt;/KeyStore&gt;
            &lt;/Key&gt;
        &lt;/Keys&gt;
        &lt;PrincipalNameMapping policy="FROM_NAME_ID"/&gt;
        &lt;RoleIdentifiers&gt;
            &lt;Attribute name="Role"/&gt;
        &lt;/RoleIdentifiers&gt;
        &lt;RoleMappingsProvider id="properties-based-role-mapper"&gt;
            &lt;Property name="properties.resource.location" value="/WEB-INF/role-mappings.properties"/&gt;
        &lt;/RoleMappingsProvider&gt;
        &lt;IDP entityID="idp"
             signaturesRequired="true"&gt;
        &lt;SingleSignOnService requestBinding="POST"
                             bindingUrl="http://localhost:8081/auth/realms/demo/protocol/saml"
                    /&gt;

            &lt;SingleLogoutService
                    requestBinding="POST"
                    responseBinding="POST"
                    postBindingUrl="http://localhost:8081/auth/realms/demo/protocol/saml"
                    redirectBindingUrl="http://localhost:8081/auth/realms/demo/protocol/saml"
                    /&gt;
            &lt;Keys&gt;
                &lt;Key signing="true"&gt;
                    &lt;KeyStore resource="/WEB-INF/keystore.jks" password="store123"&gt;
                        &lt;Certificate alias="demo"/&gt;
                    &lt;/KeyStore&gt;
                &lt;/Key&gt;
            &lt;/Keys&gt;
        &lt;/IDP&gt;
     &lt;/SP&gt;
&lt;/keycloak-saml-adapter&gt;</pre><p>
					Some of these configuration switches may be adapter specific and some are common across all adapters. For Java adapters you can use <code class="literal">${…​}</code> enclosure as System property replacement. For example <code class="literal">${jboss.server.config.dir}</code>.
				</p><section class="section" id="sp_element"><div class="titlepage"><div><div><h4 class="title">3.1.1.1. SP Element</h4></div></div></div><p>
						Here is the explanation of the SP element attributes:
					</p><pre class="programlisting language-xml">&lt;SP entityID="sp"
    sslPolicy="ssl"
    nameIDPolicyFormat="format"
    forceAuthentication="true"
    isPassive="false"
    keepDOMAssertion="true"
    autodetectBearerOnly="false"&gt;
...
&lt;/SP&gt;</pre><div class="variablelist"><dl class="variablelist"><dt><span class="term">entityID</span></dt><dd>
									This is the identifier for this client. The IdP needs this value to determine who the client is that is communicating with it. This setting is <span class="emphasis"><em>REQUIRED</em></span>.
								</dd><dt><span class="term">sslPolicy</span></dt><dd>
									This is the SSL policy the adapter will enforce. Valid values are: <code class="literal">ALL</code>, <code class="literal">EXTERNAL</code>, and <code class="literal">NONE</code>. For <code class="literal">ALL</code>, all requests must come in via HTTPS. For <code class="literal">EXTERNAL</code>, only non-private IP addresses must come over the wire via HTTPS. For <code class="literal">NONE</code>, no requests are required to come over via HTTPS. This setting is <span class="emphasis"><em>OPTIONAL</em></span>. Default value is <code class="literal">EXTERNAL</code>.
								</dd><dt><span class="term">nameIDPolicyFormat</span></dt><dd>
									SAML clients can request a specific NameID Subject format. Fill in this value if you want a specific format. It must be a standard SAML format identifier: <code class="literal">urn:oasis:names:tc:SAML:2.0:nameid-format:transient</code>. This setting is <span class="emphasis"><em>OPTIONAL</em></span>. By default, no special format is requested.
								</dd><dt><span class="term">forceAuthentication</span></dt><dd>
									SAML clients can request that a user is re-authenticated even if they are already logged in at the IdP. Set this to <code class="literal">true</code> to enable. This setting is <span class="emphasis"><em>OPTIONAL</em></span>. Default value is <code class="literal">false</code>.
								</dd><dt><span class="term">isPassive</span></dt><dd>
									SAML clients can request that a user is never asked to authenticate even if they are not logged in at the IdP. Set this to <code class="literal">true</code> if you want this. Do not use together with <code class="literal">forceAuthentication</code> as they are opposite. This setting is <span class="emphasis"><em>OPTIONAL</em></span>. Default value is <code class="literal">false</code>.
								</dd><dt><span class="term">turnOffChangeSessionIdOnLogin</span></dt><dd>
									The session ID is changed by default on a successful login on some platforms to plug a security attack vector. Change this to <code class="literal">true</code> to disable this. It is recommended you do not turn it off. Default value is <code class="literal">false</code>.
								</dd><dt><span class="term">autodetectBearerOnly</span></dt><dd>
									This should be set to <span class="emphasis"><em>true</em></span> if your application serves both a web application and web services (e.g. SOAP or REST). It allows you to redirect unauthenticated users of the web application to the Keycloak login page, but send an HTTP <code class="literal">401</code> status code to unauthenticated SOAP or REST clients instead as they would not understand a redirect to the login page. Keycloak auto-detects SOAP or REST clients based on typical headers like <code class="literal">X-Requested-With</code>, <code class="literal">SOAPAction</code> or <code class="literal">Accept</code>. The default value is <span class="emphasis"><em>false</em></span>.
								</dd><dt><span class="term">logoutPage</span></dt><dd>
									This sets the page to display after logout. If the page is a full URL, such as <code class="literal"><a class="link" href="http://web.example.com/logout.html">http://web.example.com/logout.html</a></code>, the user is redirected after logout to that page using the HTTP <code class="literal">302</code> status code. If a link without scheme part is specified, such as <code class="literal">/logout.jsp</code>, the page is displayed after logout, <span class="emphasis"><em>regardless of whether it lies in a protected area according to <code class="literal">security-constraint</code> declarations in web.xml</em></span>, and the page is resolved relative to the deployment context root.
								</dd><dt><span class="term">keepDOMAssertion</span></dt><dd>
									This attribute should be set to <span class="emphasis"><em>true</em></span> to make the adapter store the DOM representation of the assertion in its original form inside the <code class="literal">SamlPrincipal</code> associated to the request. The assertion document can be retrieved using the method <code class="literal">getAssertionDocument</code> inside the principal. This is specially useful when re-playing a signed assertion. The returned document is the one that was generated parsing the SAML response received by the Red Hat Single Sign-On server. This setting is <span class="emphasis"><em>OPTIONAL</em></span> and its default value is <span class="emphasis"><em>false</em></span> (the document is not saved inside the principal).
								</dd></dl></div></section><section class="section" id="saml-sp-keys"><div class="titlepage"><div><div><h4 class="title">3.1.1.2. Service Provider Keys and Key Elements</h4></div></div></div><p>
						If the IdP requires that the client application (or SP) sign all of its requests and/or if the IdP will encrypt assertions, you must define the keys used to do this. For client-signed documents you must define both the private and public key or certificate that is used to sign documents. For encryption, you only have to define the private key that is used to decrypt it.
					</p><p>
						There are two ways to describe your keys. They can be stored within a Java KeyStore or you can copy/paste the keys directly within <code class="literal">keycloak-saml.xml</code> in the PEM format.
					</p><pre class="programlisting language-xml">        &lt;Keys&gt;
            &lt;Key signing="true" &gt;
               ...
            &lt;/Key&gt;
        &lt;/Keys&gt;</pre><p>
						The <code class="literal">Key</code> element has two optional attributes <code class="literal">signing</code> and <code class="literal">encryption</code>. When set to true these tell the adapter what the key will be used for. If both attributes are set to true, then the key will be used for both signing documents and decrypting encrypted assertions. You must set at least one of these attributes to true.
					</p><section class="section" id="saml-keystore"><div class="titlepage"><div><div><h5 class="title">3.1.1.2.1. KeyStore element</h5></div></div></div><p>
							Within the <code class="literal">Key</code> element you can load your keys and certificates from a Java Keystore. This is declared within a <code class="literal">KeyStore</code> element.
						</p><pre class="programlisting language-xml">        &lt;Keys&gt;
            &lt;Key signing="true" &gt;
                &lt;KeyStore resource="/WEB-INF/keystore.jks" password="store123"&gt;
                    &lt;PrivateKey alias="myPrivate" password="test123"/&gt;
                    &lt;Certificate alias="myCertAlias"/&gt;
                &lt;/KeyStore&gt;
            &lt;/Key&gt;
        &lt;/Keys&gt;</pre><p>
							Here are the XML config attributes that are defined with the <code class="literal">KeyStore</code> element.
						</p><div class="variablelist"><dl class="variablelist"><dt><span class="term">file</span></dt><dd>
										File path to the key store. This option is <span class="emphasis"><em>OPTIONAL</em></span>. The file or resource attribute must be set.
									</dd><dt><span class="term">resource</span></dt><dd>
										WAR resource path to the KeyStore. This is a path used in method call to ServletContext.getResourceAsStream(). This option is <span class="emphasis"><em>OPTIONAL</em></span>. The file or resource attribute must be set.
									</dd><dt><span class="term">password</span></dt><dd>
										The password of the KeyStore. This option is <span class="emphasis"><em>REQUIRED</em></span>.
									</dd></dl></div><p>
							If you are defining keys that the SP will use to sign document, you must also specify references to your private keys and certificates within the Java KeyStore. The <code class="literal">PrivateKey</code> and <code class="literal">Certificate</code> elements in the above example define an <code class="literal">alias</code> that points to the key or cert within the keystore. Keystores require an additional password to access private keys. In the <code class="literal">PrivateKey</code> element you must define this password within a <code class="literal">password</code> attribute.
						</p></section><section class="section" id="key_pems"><div class="titlepage"><div><div><h5 class="title">3.1.1.2.2. Key PEMS</h5></div></div></div><p>
							Within the <code class="literal">Key</code> element you declare your keys and certificates directly using the sub elements <code class="literal">PrivateKeyPem</code>, <code class="literal">PublicKeyPem</code>, and <code class="literal">CertificatePem</code>. The values contained in these elements must conform to the PEM key format. You usually use this option if you are generating keys using <code class="literal">openssl</code> or similar command line tool.
						</p><pre class="programlisting language-xml">&lt;Keys&gt;
   &lt;Key signing="true"&gt;
      &lt;PrivateKeyPem&gt;
         2341251234AB31234==231BB998311222423522334
      &lt;/PrivateKeyPem&gt;
      &lt;CertificatePem&gt;
         211111341251234AB31234==231BB998311222423522334
      &lt;/CertificatePem&gt;
   &lt;/Key&gt;
&lt;/Keys&gt;</pre></section></section><section class="section" id="sp_principalnamemapping_element"><div class="titlepage"><div><div><h4 class="title">3.1.1.3. SP PrincipalNameMapping element</h4></div></div></div><p>
						This element is optional. When creating a Java Principal object that you obtain from methods such as <code class="literal">HttpServletRequest.getUserPrincipal()</code>, you can define what name is returned by the <code class="literal">Principal.getName()</code> method.
					</p><pre class="programlisting language-xml">&lt;SP ...&gt;
  &lt;PrincipalNameMapping policy="FROM_NAME_ID"/&gt;
&lt;/SP&gt;

&lt;SP ...&gt;
  &lt;PrincipalNameMapping policy="FROM_ATTRIBUTE" attribute="email" /&gt;
&lt;/SP&gt;</pre><p>
						The <code class="literal">policy</code> attribute defines the policy used to populate this value. The possible values for this attribute are:
					</p><div class="variablelist"><dl class="variablelist"><dt><span class="term">FROM_NAME_ID</span></dt><dd>
									This policy just uses whatever the SAML subject value is. This is the default setting
								</dd><dt><span class="term">FROM_ATTRIBUTE</span></dt><dd>
									This will pull the value from one of the attributes declared in the SAML assertion received from the server. You’ll need to specify the name of the SAML assertion attribute to use within the <code class="literal">attribute</code> XML attribute.
								</dd></dl></div></section><section class="section" id="roleidentifiers_element"><div class="titlepage"><div><div><h4 class="title">3.1.1.4. RoleIdentifiers Element</h4></div></div></div><p>
						The <code class="literal">RoleIdentifiers</code> element defines what SAML attributes within the assertion received from the user should be used as role identifiers within the Java EE Security Context for the user.
					</p><pre class="programlisting language-xml">&lt;RoleIdentifiers&gt;
     &lt;Attribute name="Role"/&gt;
     &lt;Attribute name="member"/&gt;
     &lt;Attribute name="memberOf"/&gt;
&lt;/RoleIdentifiers&gt;</pre><p>
						By default <code class="literal">Role</code> attribute values are converted to Java EE roles. Some IdPs send roles using a <code class="literal">member</code> or <code class="literal">memberOf</code> attribute assertion. You can define one or more <code class="literal">Attribute</code> elements to specify which SAML attributes must be converted into roles.
					</p></section><section class="section" id="rolemappingsprovider_element"><div class="titlepage"><div><div><h4 class="title">3.1.1.5. RoleMappingsProvider Element</h4></div></div></div><p>
						The <code class="literal">RoleMappingsProvider</code> is an optional element that allows for the specification of the id and configuration of the <code class="literal">org.keycloak.adapters.saml.RoleMappingsProvider</code> SPI implementation that is to be used by the SAML adapter.
					</p><p>
						When Red Hat Single Sign-On is used as the IDP, it is possible to use the built in role mappers to map any roles before adding them to the SAML assertion. However, the SAML adapters can be used to send SAML requests to third party IDPs and in this case it might be necessary to map the roles extracted from the assertion into a different set of roles as required by the SP. The <code class="literal">RoleMappingsProvider</code> SPI allows for the configuration of pluggable role mappers that can be used to perform the necessary mappings.
					</p><p>
						The configuration of the provider looks as follows:
					</p><pre class="programlisting language-xml">...
&lt;RoleIdentifiers&gt;
    ...
&lt;/RoleIdentifiers&gt;
&lt;RoleMappingsProvider id="properties-based-role-mapper"&gt;
    &lt;Property name="properties.resource.location" value="/WEB-INF/role-mappings.properties"/&gt;
&lt;/RoleMappingsProvider&gt;
&lt;IDP&gt;
    ...
&lt;/IDP&gt;</pre><p>
						The <code class="literal">id</code> attribute identifies which of the installed providers is to be used. The <code class="literal">Property</code> sub-element can be used multiple times to specify configuration properties for the provider.
					</p><section class="section" id="properties_based_role_mappings_provider"><div class="titlepage"><div><div><h5 class="title">3.1.1.5.1. Properties Based Role Mappings Provider</h5></div></div></div><p>
							Red Hat Single Sign-On includes a <code class="literal">RoleMappingsProvider</code> implementation that performs the role mappings using a <code class="literal">properties</code> file. This provider is identified by the id <code class="literal">properties-based-role-mapper</code> and is implemented by the <code class="literal">org.keycloak.adapters.saml.PropertiesBasedRoleMapper</code> class.
						</p><p>
							This provider relies on two configuration properties that can be used to specify the location of the <code class="literal">properties</code> file that will be used. First, it checks if the <code class="literal">properties.file.location</code> property has been specified, using the configured value to locate the <code class="literal">properties</code> file in the filesystem. If the configured file is not located, the provider throws a <code class="literal">RuntimeException</code>. The following snippet shows an example of provider using the <code class="literal">properties.file.configuration</code> option to load the <code class="literal">roles.properties</code> file from the <code class="literal">/opt/mappers/</code> directory in the filesystem:
						</p><pre class="programlisting language-xml">    &lt;RoleMappingsProvider id="properties-based-role-mapper"&gt;
        &lt;Property name="properties.file.location" value="/opt/mappers/roles.properties"/&gt;
    &lt;/RoleMappingsProvider&gt;</pre><p>
							If the <code class="literal">properties.file.location</code> configuration has not been set, the provider checks the <code class="literal">properties.resource.location</code> property, using the configured value to load the <code class="literal">properties</code> file from the <code class="literal">WAR</code> resource. If this configuration property is also not present, the provider attempts to load the file from <code class="literal">/WEB-INF/role-mappings.properties</code> by default. Failure to load the file from the resource will result in the provider throwing a <code class="literal">RuntimeException</code>. The following snippet shows an example of provider using the <code class="literal">properties.resource.location</code> to load the <code class="literal">roles.properties</code> file from the application’s <code class="literal">/WEB-INF/conf/</code> directory:
						</p><pre class="programlisting language-xml">    &lt;RoleMappingsProvider id="properties-based-role-mapper"&gt;
        &lt;Property name="properties.resource.location" value="/WEB-INF/conf/roles.properties"/&gt;
    &lt;/RoleMappingsProvider&gt;</pre><p>
							The <code class="literal">properties</code> file can contain both roles and principals as keys, and a list of zero or more roles separated by comma as values. When invoked, the implementation iterates through the set of roles that were extracted from the assertion and checks, for each role, if a mapping exists. If the role maps to an empty role, it is discarded. If it maps to a set of one ore more different roles, then these roles are set in the result set. If no mapping is found for the role then it is included as is in the result set.
						</p><p>
							Once the roles have been processed, the implementation checks if the principal extracted from the assertion contains an entry <code class="literal">properties</code> file. If a mapping for the principal exists, any roles listed as value are added to the result set. This allows the assignment of extra roles to a principal.
						</p><p>
							As an example, let’s assume the provider has been configured with the following properties file:
						</p><pre class="screen">roleA=roleX,roleY
roleB=

kc_user=roleZ</pre><p>
							If the principal <code class="literal">kc_user</code> is extracted from the assertion with roles <code class="literal">roleA</code>, <code class="literal">roleB</code> and <code class="literal">roleC</code>, the final set of roles assigned to the principal will be <code class="literal">roleC</code>, <code class="literal">roleX</code>, <code class="literal">roleY</code> and <code class="literal">roleZ</code> because <code class="literal">roleA</code> is being mapped into both <code class="literal">roleX</code> and <code class="literal">roleY</code>, <code class="literal">roleB</code> was mapped into an empty role - thus being discarded, <code class="literal">roleC</code> is used as is and finally an additional role was added to the <code class="literal">kc_user</code> principal (<code class="literal">roleZ</code>).
						</p></section><section class="section" id="adding_your_own_role_mappings_provider"><div class="titlepage"><div><div><h5 class="title">3.1.1.5.2. Adding Your Own Role Mappings Provider</h5></div></div></div><p>
							To add a custom role mappings provider one simply needs to implement the <code class="literal">org.keycloak.adapters.saml.RoleMappingsProvider</code> SPI. For more details see the <code class="literal">SAML Role Mappings SPI</code> section in <a class="link" href="https://access.redhat.com/documentation/en-us/red_hat_single_sign-on/7.4/html-single/server_developer_guide/">Server Developer Guide</a>.
						</p></section></section><section class="section" id="idp_element"><div class="titlepage"><div><div><h4 class="title">3.1.1.6. IDP Element</h4></div></div></div><p>
						Everything in the IDP element describes the settings for the identity provider (authentication server) the SP is communicating with.
					</p><pre class="programlisting language-xml">&lt;IDP entityID="idp"
     signaturesRequired="true"
     signatureAlgorithm="RSA_SHA1"
     signatureCanonicalizationMethod="http://www.w3.org/2001/10/xml-exc-c14n#"&gt;
...
&lt;/IDP&gt;</pre><p>
						Here are the attribute config options you can specify within the <code class="literal">IDP</code> element declaration.
					</p><div class="variablelist"><dl class="variablelist"><dt><span class="term">entityID</span></dt><dd>
									This is the issuer ID of the IDP. This setting is <span class="emphasis"><em>REQUIRED</em></span>.
								</dd><dt><span class="term">signaturesRequired</span></dt><dd>
									If set to <code class="literal">true</code>, the client adapter will sign every document it sends to the IDP. Also, the client will expect that the IDP will be signing any documents sent to it. This switch sets the default for all request and response types, but you will see later that you have some fine grain control over this. This setting is <span class="emphasis"><em>OPTIONAL</em></span> and will default to <code class="literal">false</code>.
								</dd><dt><span class="term">signatureAlgorithm</span></dt><dd>
									This is the signature algorithm that the IDP expects signed documents to use. Allowed values are: <code class="literal">RSA_SHA1</code>, <code class="literal">RSA_SHA256</code>, <code class="literal">RSA_SHA512</code>, and <code class="literal">DSA_SHA1</code>. This setting is <span class="emphasis"><em>OPTIONAL</em></span> and defaults to <code class="literal">RSA_SHA256</code>.
								</dd><dt><span class="term">signatureCanonicalizationMethod</span></dt><dd>
									This is the signature canonicalization method that the IDP expects signed documents to use. This setting is <span class="emphasis"><em>OPTIONAL</em></span>. The default value is <code class="literal">http://www.w3.org/2001/10/xml-exc-c14n#</code> and should be good for most IDPs.
								</dd><dt><span class="term">metadataUrl</span></dt><dd>
									The URL used to retrieve the IDP metadata, currently this is only used to pick up signing and encryption keys periodically which allow cycling of these keys on the IDP without manual changes on the SP side.
								</dd></dl></div></section><section class="section" id="sp-idp-allowedclockskew"><div class="titlepage"><div><div><h4 class="title">3.1.1.7. IDP AllowedClockSkew sub element</h4></div></div></div><p>
						The <code class="literal">AllowedClockSkew</code> optional sub element defines the allowed clock skew between IDP and SP. The default value is 0.
					</p><pre class="programlisting language-xml">&lt;AllowedClockSkew unit="MILLISECONDS"&gt;3500&lt;/AllowedClockSkew&gt;</pre><div class="variablelist"><dl class="variablelist"><dt><span class="term">unit</span></dt><dd>
									It is possible to define the time unit attached to the value for this element. Allowed values are MICROSECONDS, MILLISECONDS, MINUTES, NANOSECONDS and SECONDS. This is <span class="emphasis"><em>OPTIONAL</em></span>. The default value is <code class="literal">SECONDS</code>.
								</dd></dl></div></section><section class="section" id="sp-idp-singlesignonservice"><div class="titlepage"><div><div><h4 class="title">3.1.1.8. IDP SingleSignOnService sub element</h4></div></div></div><p>
						The <code class="literal">SingleSignOnService</code> sub element defines the login SAML endpoint of the IDP. The client adapter will send requests to the IDP formatted via the settings within this element when it wants to login.
					</p><pre class="programlisting language-xml">&lt;SingleSignOnService signRequest="true"
                     validateResponseSignature="true"
                     requestBinding="post"
                     bindingUrl="url"/&gt;</pre><p>
						Here are the config attributes you can define on this element:
					</p><div class="variablelist"><dl class="variablelist"><dt><span class="term">signRequest</span></dt><dd>
									Should the client sign authn requests? This setting is <span class="emphasis"><em>OPTIONAL</em></span>. Defaults to whatever the IDP <code class="literal">signaturesRequired</code> element value is.
								</dd><dt><span class="term">validateResponseSignature</span></dt><dd>
									Should the client expect the IDP to sign the assertion response document sent back from an auhtn request? This setting <span class="emphasis"><em>OPTIONAL</em></span>. Defaults to whatever the IDP <code class="literal">signaturesRequired</code> element value is.
								</dd><dt><span class="term">requestBinding</span></dt><dd>
									This is the SAML binding type used for communicating with the IDP. This setting is <span class="emphasis"><em>OPTIONAL</em></span>. The default value is <code class="literal">POST</code>, but you can set it to <code class="literal">REDIRECT</code> as well.
								</dd><dt><span class="term">responseBinding</span></dt><dd>
									SAML allows the client to request what binding type it wants authn responses to use. The values of this can be <code class="literal">POST</code> or <code class="literal">REDIRECT</code>. This setting is <span class="emphasis"><em>OPTIONAL</em></span>. The default is that the client will not request a specific binding type for responses.
								</dd><dt><span class="term">assertionConsumerServiceUrl</span></dt><dd>
									URL of the assertion consumer service (ACS) where the IDP login service should send responses to. This setting is <span class="emphasis"><em>OPTIONAL</em></span>. By default it is unset, relying on the configuration in the IdP. When set, it must end in <code class="literal">/saml</code>, e.g. <code class="literal">http://sp.domain.com/my/endpoint/for/saml</code>. The value of this property is sent in <code class="literal">AssertionConsumerServiceURL</code> attribute of SAML <code class="literal">AuthnRequest</code> message. This property is typically accompanied by the <code class="literal">responseBinding</code> attribute.
								</dd><dt><span class="term">bindingUrl</span></dt><dd>
									This is the URL for the IDP login service that the client will send requests to. This setting is <span class="emphasis"><em>REQUIRED</em></span>.
								</dd></dl></div></section><section class="section" id="idp_singlelogoutservice_sub_element"><div class="titlepage"><div><div><h4 class="title">3.1.1.9. IDP SingleLogoutService sub element</h4></div></div></div><p>
						The <code class="literal">SingleLogoutService</code> sub element defines the logout SAML endpoint of the IDP. The client adapter will send requests to the IDP formatted via the settings within this element when it wants to logout.
					</p><pre class="programlisting language-xml">&lt;SingleLogoutService validateRequestSignature="true"
                     validateResponseSignature="true"
                     signRequest="true"
                     signResponse="true"
                     requestBinding="redirect"
                     responseBinding="post"
                     postBindingUrl="posturl"
                     redirectBindingUrl="redirecturl"&gt;</pre><div class="variablelist"><dl class="variablelist"><dt><span class="term">signRequest</span></dt><dd>
									Should the client sign logout requests it makes to the IDP? This setting is <span class="emphasis"><em>OPTIONAL</em></span>. Defaults to whatever the IDP <code class="literal">signaturesRequired</code> element value is.
								</dd><dt><span class="term">signResponse</span></dt><dd>
									Should the client sign logout responses it sends to the IDP requests? This setting is <span class="emphasis"><em>OPTIONAL</em></span>. Defaults to whatever the IDP <code class="literal">signaturesRequired</code> element value is.
								</dd><dt><span class="term">validateRequestSignature</span></dt><dd>
									Should the client expect signed logout request documents from the IDP? This setting is <span class="emphasis"><em>OPTIONAL</em></span>. Defaults to whatever the IDP <code class="literal">signaturesRequired</code> element value is.
								</dd><dt><span class="term">validateResponseSignature</span></dt><dd>
									Should the client expect signed logout response documents from the IDP? This setting is <span class="emphasis"><em>OPTIONAL</em></span>. Defaults to whatever the IDP <code class="literal">signaturesRequired</code> element value is.
								</dd><dt><span class="term">requestBinding</span></dt><dd>
									This is the SAML binding type used for communicating SAML requests to the IDP. This setting is <span class="emphasis"><em>OPTIONAL</em></span>. The default value is <code class="literal">POST</code>, but you can set it to REDIRECT as well.
								</dd><dt><span class="term">responseBinding</span></dt><dd>
									This is the SAML binding type used for communicating SAML responses to the IDP. The values of this can be <code class="literal">POST</code> or <code class="literal">REDIRECT</code>. This setting is <span class="emphasis"><em>OPTIONAL</em></span>. The default value is <code class="literal">POST</code>, but you can set it to <code class="literal">REDIRECT</code> as well.
								</dd><dt><span class="term">postBindingUrl</span></dt><dd>
									This is the URL for the IDP’s logout service when using the POST binding. This setting is <span class="emphasis"><em>REQUIRED</em></span> if using the <code class="literal">POST</code> binding.
								</dd><dt><span class="term">redirectBindingUrl</span></dt><dd>
									This is the URL for the IDP’s logout service when using the REDIRECT binding. This setting is <span class="emphasis"><em>REQUIRED</em></span> if using the REDIRECT binding.
								</dd></dl></div></section><section class="section" id="sp-idp-keys"><div class="titlepage"><div><div><h4 class="title">3.1.1.10. IDP Keys sub element</h4></div></div></div><p>
						The Keys sub element of IDP is only used to define the certificate or public key to use to verify documents signed by the IDP. It is defined in the same way as the <a class="link" href="#saml-sp-keys" title="3.1.1.2. Service Provider Keys and Key Elements">SP’s Keys element</a>. But again, you only have to define one certificate or public key reference. Note that, if both IDP and SP are realized by Red Hat Single Sign-On server and adapter, respectively, there is no need to specify the keys for signature validation, see below.
					</p><p id="sp-idp-keys-automatic">
						It is possible to configure SP to obtain public keys for IDP signature validation from published certificates automatically, provided both SP and IDP are implemented by Red Hat Single Sign-On. This is done by removing all declarations of signature validation keys in Keys sub element. If the Keys sub element would then remain empty, it can be omitted completely. The keys are then automatically obtained by SP from SAML descriptor, location of which is derived from SAML endpoint URL specified in the <a class="link" href="#sp-idp-singlesignonservice" title="3.1.1.8. IDP SingleSignOnService sub element">IDP SingleSignOnService sub element</a>. Settings of the HTTP client that is used for SAML descriptor retrieval usually needs no additional configuration, however it can be configured in the <a class="link" href="#sp-idp-httpclient" title="3.1.1.11. IDP HttpClient sub element">IDP HttpClient sub element</a>.
					</p><p>
						It is also possible to specify multiple keys for signature verification. This is done by declaring multiple Key elements within Keys sub element that have <code class="literal">signing</code> attribute set to <code class="literal">true</code>. This is useful for example in situation when the IDP signing keys are rotated: There is usually a transition period when new SAML protocol messages and assertions are signed with the new key but those signed by previous key should still be accepted.
					</p><p>
						It is not possible to configure Red Hat Single Sign-On to both obtain the keys for signature verification automatically and define additional static signature verification keys.
					</p><pre class="programlisting language-xml">       &lt;IDP entityID="idp"&gt;
            ...
            &lt;Keys&gt;
                &lt;Key signing="true"&gt;
                    &lt;KeyStore resource="/WEB-INF/keystore.jks" password="store123"&gt;
                        &lt;Certificate alias="demo"/&gt;
                    &lt;/KeyStore&gt;
                &lt;/Key&gt;
            &lt;/Keys&gt;
        &lt;/IDP&gt;</pre></section><section class="section" id="sp-idp-httpclient"><div class="titlepage"><div><div><h4 class="title">3.1.1.11. IDP HttpClient sub element</h4></div></div></div><p>
						The <code class="literal">HttpClient</code> optional sub element defines the properties of HTTP client used for automatic obtaining of certificates containing public keys for IDP signature verification via SAML descriptor of the IDP when <a class="link" href="#sp-idp-keys-automatic">enabled</a>.
					</p><pre class="programlisting language-xml">&lt;HttpClient connectionPoolSize="10"
            disableTrustManager="false"
            allowAnyHostname="false"
            clientKeystore="classpath:keystore.jks"
            clientKeystorePassword="pwd"
            truststore="classpath:truststore.jks"
            truststorePassword="pwd"
            proxyUrl="http://proxy/" /&gt;</pre><div class="variablelist"><dl class="variablelist"><dt><span class="term">connectionPoolSize</span></dt><dd>
									This config option defines how many connections to the Red Hat Single Sign-On server should be pooled. This is <span class="emphasis"><em>OPTIONAL</em></span>. The default value is <code class="literal">10</code>.
								</dd><dt><span class="term">disableTrustManager</span></dt><dd>
									If the Red Hat Single Sign-On server requires HTTPS and this config option is set to <code class="literal">true</code> you do not have to specify a truststore. This setting should only be used during development and <span class="strong strong"><strong>never</strong></span> in production as it will disable verification of SSL certificates. This is <span class="emphasis"><em>OPTIONAL</em></span>. The default value is <code class="literal">false</code>.
								</dd><dt><span class="term">allowAnyHostname</span></dt><dd>
									If the Red Hat Single Sign-On server requires HTTPS and this config option is set to <code class="literal">true</code> the Red Hat Single Sign-On server’s certificate is validated via the truststore, but host name validation is not done. This setting should only be used during development and <span class="strong strong"><strong>never</strong></span> in production as it will partly disable verification of SSL certificates. This seting may be useful in test environments. This is <span class="emphasis"><em>OPTIONAL</em></span>. The default value is <code class="literal">false</code>.
								</dd><dt><span class="term">truststore</span></dt><dd>
									The value is the file path to a truststore file. If you prefix the path with <code class="literal">classpath:</code>, then the truststore will be obtained from the deployment’s classpath instead. Used for outgoing HTTPS communications to the Red Hat Single Sign-On server. Client making HTTPS requests need a way to verify the host of the server they are talking to. This is what the trustore does. The keystore contains one or more trusted host certificates or certificate authorities. You can create this truststore by extracting the public certificate of the Red Hat Single Sign-On server’s SSL keystore. This is <span class="emphasis"><em>REQUIRED</em></span> unless <code class="literal">disableTrustManager</code> is <code class="literal">true</code>.
								</dd><dt><span class="term">truststorePassword</span></dt><dd>
									Password for the truststore. This is <span class="emphasis"><em>REQUIRED</em></span> if <code class="literal">truststore</code> is set and the truststore requires a password.
								</dd><dt><span class="term">clientKeystore</span></dt><dd>
									This is the file path to a keystore file. This keystore contains client certificate for two-way SSL when the adapter makes HTTPS requests to the Red Hat Single Sign-On server. This is <span class="emphasis"><em>OPTIONAL</em></span>.
								</dd><dt><span class="term">clientKeystorePassword</span></dt><dd>
									Password for the client keystore and for the client’s key. This is <span class="emphasis"><em>REQUIRED</em></span> if <code class="literal">clientKeystore</code> is set.
								</dd><dt><span class="term">proxyUrl</span></dt><dd>
									URL to HTTP proxy to use for HTTP connections. This is <span class="emphasis"><em>OPTIONAL</em></span>.
								</dd></dl></div></section></section><section class="section" id="saml_jboss_adapter"><div class="titlepage"><div><div><h3 class="title">3.1.2. JBoss EAP Adapter</h3></div></div></div><p>
					To be able to secure WAR apps deployed on JBoss EAP, you must install and configure the Red Hat Single Sign-On SAML Adapter Subsystem.
				</p><p>
					You then provide a keycloak config, <code class="literal">/WEB-INF/keycloak-saml.xml</code> file in your WAR and change the auth-method to KEYCLOAK-SAML within web.xml. Both methods are described in this section.
				</p><section class="section" id="saml-jboss-adapter-installation"><div class="titlepage"><div><div><h4 class="title">3.1.2.1. Adapter Installation</h4></div></div></div><p>
						Each adapter is a separate download on the Red Hat Single Sign-On download site.
					</p><p>
						Install on JBoss EAP 7.x:
					</p><pre class="screen">$ cd $EAP_HOME
$ unzip rh-sso-saml-eap7-adapter.zip</pre><p>
						Install on JBoss EAP 6.x:
					</p><pre class="screen">$ cd $EAP_HOME
$ unzip rh-sso-saml-eap6-adapter.zip</pre><p>
						These zip files create new JBoss Modules specific to the JBoss EAP SAML Adapter within your JBoss EAP distro.
					</p><p>
						After adding the modules, you must then enable the Red Hat Single Sign-On SAML Subsystem within your app server’s server configuration: <code class="literal">domain.xml</code> or <code class="literal">standalone.xml</code>.
					</p><p>
						There is a CLI script that will help you modify your server configuration. Start the server and run the script from the server’s bin directory:
					</p><div class="formalpara"><p class="title"><strong>JBoss EAP 7.1 or newer</strong></p><p>
							
<pre class="screen">$ cd $JBOSS_HOME
$ ./bin/jboss-cli.sh -c --file=bin/adapter-elytron-install-saml.cli</pre>
						</p></div><div class="formalpara"><p class="title"><strong>JBoss EAP 7.0 and EAP 6.4</strong></p><p>
							
<pre class="screen">$ cd $JBOSS_HOME
$ ./bin/boss-cli.sh -c --file=bin/adapter-install-saml.cli</pre>
						</p></div><div class="admonition note"><div class="admonition_header">Note</div><div><p>
							It is possible to use the legacy non-Elytron adapter on JBoss EAP 7.1 or newer as well, meaning you can use <code class="literal">adapter-install-saml.cli</code> even on those versions. However, we recommend to use the newer Elytron adapter.
						</p></div></div><p>
						The script will add the extension, subsystem, and optional security-domain as described below.
					</p><pre class="programlisting language-xml">&lt;server xmlns="urn:jboss:domain:1.4"&gt;

    &lt;extensions&gt;
        &lt;extension module="org.keycloak.keycloak-saml-adapter-subsystem"/&gt;
          ...
    &lt;/extensions&gt;

    &lt;profile&gt;
        &lt;subsystem xmlns="urn:jboss:domain:keycloak-saml:1.1"/&gt;
         ...
    &lt;/profile&gt;</pre><p>
						The <code class="literal">keycloak</code> security domain should be used with EJBs and other components when you need the security context created in the secured web tier to be propagated to the EJBs (other EE component) you are invoking. Otherwise this configuration is optional.
					</p><pre class="programlisting language-xml">&lt;server xmlns="urn:jboss:domain:1.4"&gt;
 &lt;subsystem xmlns="urn:jboss:domain:security:1.2"&gt;
    &lt;security-domains&gt;
...
      &lt;security-domain name="keycloak"&gt;
         &lt;authentication&gt;
           &lt;login-module code="org.keycloak.adapters.jboss.KeycloakLoginModule"
                         flag="required"/&gt;
          &lt;/authentication&gt;
      &lt;/security-domain&gt;
    &lt;/security-domains&gt;</pre><p>
						The security context is propagated to the EJB tier automatically.
					</p></section><section class="section" id="jboss_sso_2"><div class="titlepage"><div><div><h4 class="title">3.1.2.2. JBoss SSO</h4></div></div></div><p>
						JBoss EAP has built-in support for single sign-on for web applications deployed to the same JBoss EAP instance. This should not be enabled when using Red Hat Single Sign-On.
					</p></section></section><section class="section" id="jboss_adapter_rpm_saml"><div class="titlepage"><div><div><h3 class="title">3.1.3. Installing JBoss EAP Adapter from an RPM</h3></div></div></div><p>
					Install the EAP 7 Adapters from an RPM:
				</p><div class="admonition note"><div class="admonition_header">Note</div><div><p>
						With Red Hat Enterprise Linux 7, the term channel was replaced with the term repository. In these instructions only the term repository is used.
					</p></div></div><p>
					You must subscribe to the JBoss EAP 7 repository before you can install the EAP 7 adapters from an RPM.
				</p><div class="orderedlist"><p class="title"><strong>Prerequisites</strong></p><ol class="orderedlist" type="1"><li class="listitem">
							Ensure that your Red Hat Enterprise Linux system is registered to your account using Red Hat Subscription Manager. For more information see the <a class="link" href="https://access.redhat.com/documentation/en-us/red_hat_subscription_management/1/html-single/quick_registration_for_rhel/index">Red Hat Subscription Management documentation</a>.
						</li><li class="listitem">
							If you are already subscribed to another JBoss EAP repository, you must unsubscribe from that repository first.
						</li></ol></div><p>
					For Red Hat Enterprise Linux 6, 7: Using Red Hat Subscription Manager, subscribe to the JBoss EAP 7.2 repository using the following command. Replace &lt;RHEL_VERSION&gt; with either 6 or 7 depending on your Red Hat Enterprise Linux version.
				</p><pre class="programlisting language-bash">$ sudo subscription-manager repos --enable=jb-eap-7-for-rhel-&lt;RHEL_VERSION&gt;-server-rpms</pre><p>
					For Red Hat Enterprise Linux 8: Using Red Hat Subscription Manager, subscribe to the JBoss EAP 7.2 repository using the following command:
				</p><pre class="programlisting language-bash">$ sudo subscription-manager repos --enable=jb-eap-7.2-for-rhel-8-x86_64-rpms --enable=rhel-8-for-x86_64-baseos-rpms --enable=rhel-8-for-x86_64-appstream-rpms</pre><p>
					Install the EAP 7 adapters for SAML using the following command:
				</p><pre class="screen">$ sudo yum install eap7-keycloak-saml-adapter-sso7_3</pre><p>
					or use following one for Red Hat Enterprise Linux 8:
				</p><pre class="screen">$ sudo dnf install eap7-keycloak-adapter-sso7_3</pre><div class="admonition note"><div class="admonition_header">Note</div><div><p>
						The default EAP_HOME path for the RPM installation is /opt/rh/eap7/root/usr/share/wildfly.
					</p></div></div><p>
					Run the appropriate module installation script.
				</p><p>
					For the SAML module, enter the following command:
				</p><pre class="screen">$ $EAP_HOME/bin/jboss-cli.sh -c --file=$EAP_HOME/bin/adapter-install-saml.cli</pre><p>
					Your installation is complete.
				</p><p>
					Install the EAP 6 Adapters from an RPM:
				</p><div class="admonition note"><div class="admonition_header">Note</div><div><p>
						With Red Hat Enterprise Linux 7, the term channel was replaced with the term repository. In these instructions only the term repository is used.
					</p></div></div><p>
					You must subscribe to the JBoss EAP 6 repository before you can install the EAP 6 adapters from an RPM.
				</p><div class="orderedlist"><p class="title"><strong>Prerequisites</strong></p><ol class="orderedlist" type="1"><li class="listitem">
							Ensure that your Red Hat Enterprise Linux system is registered to your account using Red Hat Subscription Manager. For more information see the <a class="link" href="https://access.redhat.com/documentation/en-us/red_hat_subscription_management/1/html-single/quick_registration_for_rhel/index">Red Hat Subscription Management documentation</a>.
						</li><li class="listitem">
							If you are already subscribed to another JBoss EAP repository, you must unsubscribe from that repository first.
						</li></ol></div><p>
					Using Red Hat Subscription Manager, subscribe to the JBoss EAP 6 repository using the following command. Replace &lt;RHEL_VERSION&gt; with either 6 or 7 depending on your Red Hat Enterprise Linux version.
				</p><pre class="screen">$ sudo subscription-manager repos --enable=jb-eap-6-for-rhel-&lt;RHEL_VERSION&gt;-server-rpms</pre><p>
					Install the EAP 6 adapters for SAML using the following command:
				</p><pre class="screen">$ sudo yum install keycloak-saml-adapter-sso7_3-eap6</pre><div class="admonition note"><div class="admonition_header">Note</div><div><p>
						The default EAP_HOME path for the RPM installation is /opt/rh/eap6/root/usr/share/wildfly.
					</p></div></div><p>
					Run the appropriate module installation script.
				</p><p>
					For the SAML module, enter the following command:
				</p><pre class="screen">$ $EAP_HOME/bin/jboss-cli.sh -c --file=$EAP_HOME/bin/adapter-install-saml.cli</pre><p>
					Your installation is complete.
				</p><section class="section" id="per_war_configuration"><div class="titlepage"><div><div><h4 class="title">3.1.3.1. Per WAR Configuration</h4></div></div></div><p>
						This section describes how to secure a WAR directly by adding config and editing files within your WAR package.
					</p><p>
						The first thing you must do is create a <code class="literal">keycloak-saml.xml</code> adapter config file within the <code class="literal">WEB-INF</code> directory of your WAR. The format of this config file is described in the <a class="link" href="#saml-general-config" title="3.1.1. General Adapter Config">General Adapter Config</a> section.
					</p><p>
						Next you must set the <code class="literal">auth-method</code> to <code class="literal">KEYCLOAK-SAML</code> in <code class="literal">web.xml</code>. You also have to use standard servlet security to specify role-base constraints on your URLs. Here’s an example <span class="emphasis"><em>web.xml</em></span> file:
					</p><pre class="programlisting language-xml">&lt;web-app xmlns="http://java.sun.com/xml/ns/javaee"
      xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
      xsi:schemaLocation="http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/web-app_3_0.xsd"
      version="3.0"&gt;

	&lt;module-name&gt;customer-portal&lt;/module-name&gt;

    &lt;security-constraint&gt;
        &lt;web-resource-collection&gt;
            &lt;web-resource-name&gt;Admins&lt;/web-resource-name&gt;
            &lt;url-pattern&gt;/admin/*&lt;/url-pattern&gt;
        &lt;/web-resource-collection&gt;
        &lt;auth-constraint&gt;
            &lt;role-name&gt;admin&lt;/role-name&gt;
        &lt;/auth-constraint&gt;
        &lt;user-data-constraint&gt;
            &lt;transport-guarantee&gt;CONFIDENTIAL&lt;/transport-guarantee&gt;
        &lt;/user-data-constraint&gt;
    &lt;/security-constraint&gt;
    &lt;security-constraint&gt;
        &lt;web-resource-collection&gt;
            &lt;web-resource-name&gt;Customers&lt;/web-resource-name&gt;
            &lt;url-pattern&gt;/customers/*&lt;/url-pattern&gt;
        &lt;/web-resource-collection&gt;
        &lt;auth-constraint&gt;
            &lt;role-name&gt;user&lt;/role-name&gt;
        &lt;/auth-constraint&gt;
        &lt;user-data-constraint&gt;
            &lt;transport-guarantee&gt;CONFIDENTIAL&lt;/transport-guarantee&gt;
        &lt;/user-data-constraint&gt;
    &lt;/security-constraint&gt;

    &lt;login-config&gt;
        &lt;auth-method&gt;KEYCLOAK-SAML&lt;/auth-method&gt;
        &lt;realm-name&gt;this is ignored currently&lt;/realm-name&gt;
    &lt;/login-config&gt;

    &lt;security-role&gt;
        &lt;role-name&gt;admin&lt;/role-name&gt;
    &lt;/security-role&gt;
    &lt;security-role&gt;
        &lt;role-name&gt;user&lt;/role-name&gt;
    &lt;/security-role&gt;
&lt;/web-app&gt;</pre><p>
						All standard servlet settings except the <code class="literal">auth-method</code> setting.
					</p></section><section class="section" id="securing_wars_via_red_hat_single_sign_on_saml_subsystem"><div class="titlepage"><div><div><h4 class="title">3.1.3.2. Securing WARs via Red Hat Single Sign-On SAML Subsystem</h4></div></div></div><p>
						You do not have to crack open a WAR to secure it with Red Hat Single Sign-On. Alternatively, you can externally secure it via the Red Hat Single Sign-On SAML Adapter Subsystem. While you don’t have to specify KEYCLOAK-SAML as an <code class="literal">auth-method</code>, you still have to define the <code class="literal">security-constraints</code> in <code class="literal">web.xml</code>. You do not, however, have to create a <code class="literal">WEB-INF/keycloak-saml.xml</code> file. This metadata is instead defined within the XML in your server’s <code class="literal">domain.xml</code> or <code class="literal">standalone.xml</code> subsystem configuration section.
					</p><pre class="programlisting language-xml">&lt;extensions&gt;
  &lt;extension module="org.keycloak.keycloak-saml-adapter-subsystem"/&gt;
&lt;/extensions&gt;

&lt;profile&gt;
  &lt;subsystem xmlns="urn:jboss:domain:keycloak-saml:1.1"&gt;
    &lt;secure-deployment name="WAR MODULE NAME.war"&gt;
      &lt;SP entityID="APPLICATION URL"&gt;
        ...
      &lt;/SP&gt;
    &lt;/secure-deployment&gt;
  &lt;/subsystem&gt;
&lt;/profile&gt;</pre><p>
						The <code class="literal">secure-deployment</code> <code class="literal">name</code> attribute identifies the WAR you want to secure. Its value is the <code class="literal">module-name</code> defined in <code class="literal">web.xml</code> with <code class="literal">.war</code> appended. The rest of the configuration uses the same XML syntax as <code class="literal">keycloak-saml.xml</code> configuration defined in <a class="link" href="#saml-general-config" title="3.1.1. General Adapter Config">General Adapter Config</a>.
					</p><p>
						An example configuration:
					</p><pre class="programlisting language-xml">&lt;subsystem xmlns="urn:jboss:domain:keycloak-saml:1.1"&gt;
  &lt;secure-deployment name="saml-post-encryption.war"&gt;
    &lt;SP entityID="http://localhost:8080/sales-post-enc/"
        sslPolicy="EXTERNAL"
        nameIDPolicyFormat="urn:oasis:names:tc:SAML:1.1:nameid-format:unspecified"
        logoutPage="/logout.jsp"
        forceAuthentication="false"&gt;
      &lt;Keys&gt;
        &lt;Key signing="true" encryption="true"&gt;
          &lt;KeyStore resource="/WEB-INF/keystore.jks" password="store123"&gt;
            &lt;PrivateKey alias="http://localhost:8080/sales-post-enc/" password="test123"/&gt;
            &lt;Certificate alias="http://localhost:8080/sales-post-enc/"/&gt;
          &lt;/KeyStore&gt;
        &lt;/Key&gt;
      &lt;/Keys&gt;
      &lt;PrincipalNameMapping policy="FROM_NAME_ID"/&gt;
      &lt;RoleIdentifiers&gt;
        &lt;Attribute name="Role"/&gt;
      &lt;/RoleIdentifiers&gt;
      &lt;IDP entityID="idp"&gt;
        &lt;SingleSignOnService signRequest="true"
            validateResponseSignature="true"
            requestBinding="POST"
            bindingUrl="http://localhost:8080/auth/realms/saml-demo/protocol/saml"/&gt;

        &lt;SingleLogoutService
            validateRequestSignature="true"
            validateResponseSignature="true"
            signRequest="true"
            signResponse="true"
            requestBinding="POST"
            responseBinding="POST"
            postBindingUrl="http://localhost:8080/auth/realms/saml-demo/protocol/saml"
            redirectBindingUrl="http://localhost:8080/auth/realms/saml-demo/protocol/saml"/&gt;
        &lt;Keys&gt;
          &lt;Key signing="true" &gt;
            &lt;KeyStore resource="/WEB-INF/keystore.jks" password="store123"&gt;
              &lt;Certificate alias="saml-demo"/&gt;
            &lt;/KeyStore&gt;
          &lt;/Key&gt;
        &lt;/Keys&gt;
      &lt;/IDP&gt;
    &lt;/SP&gt;
   &lt;/secure-deployment&gt;
&lt;/subsystem&gt;</pre></section></section><section class="section" id="java_servlet_filter_adapter"><div class="titlepage"><div><div><h3 class="title">3.1.4. Java Servlet Filter Adapter</h3></div></div></div><p>
					If you want to use SAML with a Java servlet application that doesn’t have an adapter for that servlet platform, you can opt to use the servlet filter adapter that Red Hat Single Sign-On has. This adapter works a little differently than the other adapters. You still have to specify a <code class="literal">/WEB-INF/keycloak-saml.xml</code> file as defined in the <a class="link" href="#saml-general-config" title="3.1.1. General Adapter Config">General Adapter Config</a> section, but you do not define security constraints in <span class="emphasis"><em>web.xml</em></span>. Instead you define a filter mapping using the Red Hat Single Sign-On servlet filter adapter to secure the url patterns you want to secure.
				</p><div class="admonition note"><div class="admonition_header">Note</div><div><p>
						Backchannel logout works a bit differently than the standard adapters. Instead of invalidating the http session it instead marks the session ID as logged out. There’s just no way of arbitrarily invalidating an http session based on a session ID.
					</p></div></div><div class="admonition warning"><div class="admonition_header">Warning</div><div><p>
						Backchannel logout does not currently work when you have a clustered application that uses the SAML filter.
					</p></div></div><pre class="programlisting language-xml">&lt;web-app xmlns="http://java.sun.com/xml/ns/javaee"
      xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
      xsi:schemaLocation="http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/web-app_3_0.xsd"
      version="3.0"&gt;

	&lt;module-name&gt;customer-portal&lt;/module-name&gt;

    &lt;filter&gt;
        &lt;filter-name&gt;Keycloak Filter&lt;/filter-name&gt;
        &lt;filter-class&gt;org.keycloak.adapters.saml.servlet.SamlFilter&lt;/filter-class&gt;
    &lt;/filter&gt;
    &lt;filter-mapping&gt;
        &lt;filter-name&gt;Keycloak Filter&lt;/filter-name&gt;
        &lt;url-pattern&gt;/*&lt;/url-pattern&gt;
    &lt;/filter-mapping&gt;
&lt;/web-app&gt;</pre><p>
					The Red Hat Single Sign-On filter has the same configuration parameters available as the other adapters except you must define them as filter init params instead of context params.
				</p><p>
					You can define multiple filter mappings if you have various different secure and unsecure url patterns.
				</p><div class="admonition warning"><div class="admonition_header">Warning</div><div><p>
						You must have a filter mapping that covers <code class="literal">/saml</code>. This mapping covers all server callbacks.
					</p></div></div><p>
					When registering SPs with an IdP, you must register <code class="literal">http[s]://hostname/{context-root}/saml</code> as your Assert Consumer Service URL and Single Logout Service URL.
				</p><p>
					To use this filter, include this maven artifact in your WAR poms:
				</p><pre class="programlisting language-xml">&lt;dependency&gt;
   &lt;groupId&gt;org.keycloak&lt;/groupId&gt;
   &lt;artifactId&gt;keycloak-saml-servlet-filter-adapter&lt;/artifactId&gt;
   &lt;version&gt;4.8.3.Final-redhat-00001&lt;/version&gt;
&lt;/dependency&gt;</pre><p>
					In order to use <a class="link" href="#saml_multi_tenancy" title="3.1.10. Multi Tenancy">Multi Tenancy</a> the <code class="literal">keycloak.config.resolver</code> parameter should be passed as a filter parameter.
				</p><pre class="programlisting language-xml">    &lt;filter&gt;
        &lt;filter-name&gt;Keycloak Filter&lt;/filter-name&gt;
        &lt;filter-class&gt;org.keycloak.adapters.saml.servlet.SamlFilter&lt;/filter-class&gt;
        &lt;init-param&gt;
            &lt;param-name&gt;keycloak.config.resolver&lt;/param-name&gt;
            &lt;param-value&gt;example.SamlMultiTenantResolver&lt;/param-value&gt;
        &lt;/init-param&gt;
    &lt;/filter&gt;</pre></section><section class="section" id="registering_with_an_identity_provider"><div class="titlepage"><div><div><h3 class="title">3.1.5. Registering with an Identity Provider</h3></div></div></div><p>
					For each servlet-based adapter, the endpoint you register for the assert consumer service URL and single logout service must be the base URL of your servlet application with <code class="literal">/saml</code> appended to it, that is, <code class="literal">https://example.com/contextPath/saml</code>.
				</p></section><section class="section" id="logout_2"><div class="titlepage"><div><div><h3 class="title">3.1.6. Logout</h3></div></div></div><p>
					There are multiple ways you can logout from a web application. For Java EE servlet containers, you can call <code class="literal">HttpServletRequest.logout()</code>. For any other browser application, you can point the browser at any url of your web application that has a security constraint and pass in a query parameter GLO, i.e. <code class="literal">http://myapp?GLO=true</code>. This will log you out if you have an SSO session with your browser.
				</p><section class="section" id="saml_logout_in_cluster"><div class="titlepage"><div><div><h4 class="title">3.1.6.1. Logout in Clustered Environment</h4></div></div></div><p>
						Internally, the SAML adapter stores a mapping between the SAML session index, principal name (when known), and HTTP session ID. This mapping can be maintained in JBoss application server family (WildFly 10/11, EAP 6/7) across cluster for distributable applications. As a precondition, the HTTP sessions need to be distributed across cluster (i.e. application is marked with <code class="literal">&lt;distributable/&gt;</code> tag in application’s <code class="literal">web.xml</code>).
					</p><p>
						To enable the functionality, add the following section to your <code class="literal">/WEB_INF/web.xml</code> file:
					</p><p>
						For EAP 7, WildFly 10/11:
					</p><pre class="programlisting language-xml">&lt;context-param&gt;
    &lt;param-name&gt;keycloak.sessionIdMapperUpdater.classes&lt;/param-name&gt;
    &lt;param-value&gt;org.keycloak.adapters.saml.wildfly.infinispan.InfinispanSessionCacheIdMapperUpdater&lt;/param-value&gt;
&lt;/context-param&gt;</pre><p>
						For EAP 6:
					</p><pre class="programlisting language-xml">&lt;context-param&gt;
    &lt;param-name&gt;keycloak.sessionIdMapperUpdater.classes&lt;/param-name&gt;
    &lt;param-value&gt;org.keycloak.adapters.saml.jbossweb.infinispan.InfinispanSessionCacheIdMapperUpdater&lt;/param-value&gt;
&lt;/context-param&gt;</pre><p>
						If the session cache of the deployment is named <code class="literal"><span class="emphasis"><em>deployment-cache</em></span></code>, the cache used for SAML mapping will be named as <code class="literal"><span class="emphasis"><em>deployment-cache</em></span>.ssoCache</code>. The name of the cache can be overridden by a context parameter <code class="literal">keycloak.sessionIdMapperUpdater.infinispan.cacheName</code>. The cache container containing the cache will be the same as the one containing the deployment session cache, but can be overridden by a context parameter <code class="literal">keycloak.sessionIdMapperUpdater.infinispan.containerName</code>.
					</p><p>
						By default, the configuration of the SAML mapping cache will be derived from session cache. The configuration can be manually overridden in cache configuration section of the server just the same as other caches.
					</p><p>
						Currently, to provide reliable service, it is recommended to use replicated cache for the SAML session cache. Using distributed cache may lead to results where the SAML logout request would land to a node with no access to SAML session index to HTTP session mapping which would lead to unsuccessful logout.
					</p></section><section class="section" id="saml_logout_in_cross_dc"><div class="titlepage"><div><div><h4 class="title">3.1.6.2. Logout in Cross DC Scenario</h4></div></div></div><p>
						The cross DC scenario only applies to WildFly 10 and higher, and EAP 7 and higher.
					</p><p>
						Special handling is needed for handling sessions that span multiple data centers. Imagine the following scenario:
					</p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem">
								Login requests are handled within cluster in data center 1.
							</li><li class="listitem">
								Admin issues logout request for a particular SAML session, the request lands in data center 2.
							</li></ol></div><p>
						The data center 2 has to log out all sessions that are present in data center 1 (and all other data centers that share HTTP sessions).
					</p><p>
						To cover this case, the SAML session cache described <a class="link" href="#saml_logout_in_cluster" title="3.1.6.1. Logout in Clustered Environment">above</a> needs to be replicated not only within individual clusters but across all the data centers e.g. <a class="link" href="https://access.redhat.com/documentation/en-us/red_hat_data_grid/6.6/html/administration_and_configuration_guide/chap-externalize_sessions#Externalize_HTTP_Session_from_JBoss_EAP_6.x_to_JBoss_Data_Grid">via standalone Infinispan/JDG server</a>:
					</p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem">
								A cache has to be added to the standalone Infinispan/JDG server.
							</li><li class="listitem">
								The cache from previous item has to be added as a remote store for the respective SAML session cache.
							</li></ol></div><p>
						Once remote store is found to be present on SAML session cache during deployment, it is watched for changes and the local SAML session cache is updated accordingly.
					</p></section></section><section class="section" id="obtaining_assertion_attributes"><div class="titlepage"><div><div><h3 class="title">3.1.7. Obtaining Assertion Attributes</h3></div></div></div><p>
					After a successful SAML login, your application code may want to obtain attribute values passed with the SAML assertion. <code class="literal">HttpServletRequest.getUserPrincipal()</code> returns a <code class="literal">Principal</code> object that you can typecast into a Red Hat Single Sign-On specific class called <code class="literal">org.keycloak.adapters.saml.SamlPrincipal</code>. This object allows you to look at the raw assertion and also has convenience functions to look up attribute values.
				</p><pre class="programlisting language-java">package org.keycloak.adapters.saml;

public class SamlPrincipal implements Serializable, Principal {
    /**
     * Get full saml assertion
     *
     * @return
     */
    public AssertionType getAssertion() {
       ...
    }

    /**
     * Get SAML subject sent in assertion
     *
     * @return
     */
    public String getSamlSubject() {
        ...
    }

    /**
     * Subject nameID format
     *
     * @return
     */
    public String getNameIDFormat() {
        ...
    }

    @Override
    public String getName() {
        ...
    }

    /**
     * Convenience function that gets Attribute value by attribute name
     *
     * @param name
     * @return
     */
    public List&lt;String&gt; getAttributes(String name) {
        ...

    }

    /**
     * Convenience function that gets Attribute value by attribute friendly name
     *
     * @param friendlyName
     * @return
     */
    public List&lt;String&gt; getFriendlyAttributes(String friendlyName) {
        ...
    }

    /**
     * Convenience function that gets first  value of an attribute by attribute name
     *
     * @param name
     * @return
     */
    public String getAttribute(String name) {
        ...
    }

    /**
     * Convenience function that gets first  value of an attribute by attribute name
     *
     *
     * @param friendlyName
     * @return
     */
    public String getFriendlyAttribute(String friendlyName) {
        ...
    }

    /**
     * Get set of all assertion attribute names
     *
     * @return
     */
    public Set&lt;String&gt; getAttributeNames() {
        ...
    }

    /**
     * Get set of all assertion friendly attribute names
     *
     * @return
     */
    public Set&lt;String&gt; getFriendlyNames() {
        ...
    }
}</pre></section><section class="section" id="error_handling"><div class="titlepage"><div><div><h3 class="title">3.1.8. Error Handling</h3></div></div></div><p>
					Red Hat Single Sign-On has some error handling facilities for servlet based client adapters. When an error is encountered in authentication, the client adapter will call <code class="literal">HttpServletResponse.sendError()</code>. You can set up an <code class="literal">error-page</code> within your <code class="literal">web.xml</code> file to handle the error however you want. The client adapter can throw 400, 401, 403, and 500 errors.
				</p><pre class="programlisting language-xml">&lt;error-page&gt;
    &lt;error-code&gt;403&lt;/error-code&gt;
    &lt;location&gt;/ErrorHandler&lt;/location&gt;
&lt;/error-page&gt;</pre><p>
					The client adapter also sets an <code class="literal">HttpServletRequest</code> attribute that you can retrieve. The attribute name is <code class="literal">org.keycloak.adapters.spi.AuthenticationError</code>. Typecast this object to: <code class="literal">org.keycloak.adapters.saml.SamlAuthenticationError</code>. This class can tell you exactly what happened. If this attribute is not set, then the adapter was not responsible for the error code.
				</p><pre class="programlisting language-java">public class SamlAuthenticationError implements AuthenticationError {
    public static enum Reason {
        EXTRACTION_FAILURE,
        INVALID_SIGNATURE,
        ERROR_STATUS
    }

    public Reason getReason() {
        return reason;
    }
    public StatusResponseType getStatus() {
        return status;
    }
}</pre></section><section class="section" id="troubleshooting"><div class="titlepage"><div><div><h3 class="title">3.1.9. Troubleshooting</h3></div></div></div><p>
					The best way to troubleshoot problems is to turn on debugging for SAML in both the client adapter and Red Hat Single Sign-On Server. Using your logging framework, set the log level to <code class="literal">DEBUG</code> for the <code class="literal">org.keycloak.saml</code> package. Turning this on allows you to see the SAML requests and response documents being sent to and from the server.
				</p></section><section class="section" id="saml_multi_tenancy"><div class="titlepage"><div><div><h3 class="title">3.1.10. Multi Tenancy</h3></div></div></div><p>
					SAML offers the same functionality as OIDC for <a class="link" href="#multi_tenancy" title="2.1.13. Multi Tenancy">Multi Tenancy</a>, meaning that a single target application (WAR) can be secured with multiple Red Hat Single Sign-On realms. The realms can be located on the same Red Hat Single Sign-On instance or on different instances.
				</p><p>
					To do this, the application must have multiple <code class="literal">keycloak-saml.xml</code> adapter configuration files.
				</p><p>
					While you could have multiple instances of your WAR with different adapter configuration files deployed to different context-paths, this may be inconvenient and you may also want to select the realm based on something other than context-path.
				</p><p>
					Red Hat Single Sign-On makes it possible to have a custom config resolver, so you can choose which adapter config is used for each request. In SAML, the configuration is only interesting in the login processing; once the user is logged in, the session is authenticated and it does not matter if the <code class="literal">keycloak-saml.xml</code> returned is different. For that reason, returning the same configuration for the same session is the correct way to go.
				</p><p>
					To achieve this, create an implementation of <code class="literal">org.keycloak.adapters.saml.SamlConfigResolver</code>. The following example uses the <code class="literal">Host</code> header to locate the proper configuration and load it and the associated elements from the applications’s Java classpath:
				</p><pre class="programlisting language-java">package example;

import java.io.InputStream;
import org.keycloak.adapters.saml.SamlConfigResolver;
import org.keycloak.adapters.saml.SamlDeployment;
import org.keycloak.adapters.saml.config.parsers.DeploymentBuilder;
import org.keycloak.adapters.saml.config.parsers.ResourceLoader;
import org.keycloak.adapters.spi.HttpFacade;
import org.keycloak.saml.common.exceptions.ParsingException;

public class SamlMultiTenantResolver implements SamlConfigResolver {

    @Override
    public SamlDeployment resolve(HttpFacade.Request request) {
        String host = request.getHeader("Host");
        String realm = null;
        if (host.contains("tenant1")) {
            realm = "tenant1";
        } else if (host.contains("tenant2")) {
            realm = "tenant2";
        } else {
            throw new IllegalStateException("Not able to guess the keycloak-saml.xml to load");
        }

        InputStream is = getClass().getResourceAsStream("/" + realm + "-keycloak-saml.xml");
        if (is == null) {
            throw new IllegalStateException("Not able to find the file /" + realm + "-keycloak-saml.xml");
        }

        ResourceLoader loader = new ResourceLoader() {
            @Override
            public InputStream getResourceAsStream(String path) {
                return getClass().getResourceAsStream(path);
            }
        };

        try {
            return new DeploymentBuilder().build(is, loader);
        } catch (ParsingException e) {
            throw new IllegalStateException("Cannot load SAML deployment", e);
        }
    }
}</pre><p>
					You must also configure which <code class="literal">SamlConfigResolver</code> implementation to use with the <code class="literal">keycloak.config.resolver</code> context-param in your <code class="literal">web.xml</code>:
				</p><pre class="programlisting language-xml">&lt;web-app&gt;
    ...
    &lt;context-param&gt;
        &lt;param-name&gt;keycloak.config.resolver&lt;/param-name&gt;
        &lt;param-value&gt;example.SamlMultiTenantResolver&lt;/param-value&gt;
    &lt;/context-param&gt;
&lt;/web-app&gt;</pre></section></section><section class="section" id="mod_auth_mellon"><div class="titlepage"><div><div><h2 class="title">3.2. mod_auth_mellon Apache HTTPD Module</h2></div></div></div><p>
				The <a class="link" href="https://github.com/UNINETT/mod_auth_mellon">mod_auth_mellon</a> module is an Apache HTTPD plugin for SAML. If your language/environment supports using Apache HTTPD as a proxy, then you can use mod_auth_mellon to secure your web application with SAML. For more details on this module see the <span class="emphasis"><em>mod_auth_mellon</em></span> GitHub repo.
			</p><p>
				To configure mod_auth_mellon you’ll need:
			</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">
						An Identity Provider (IdP) entity descriptor XML file, which describes the connection to Red Hat Single Sign-On or another SAML IdP
					</li><li class="listitem">
						An SP entity descriptor XML file, which describes the SAML connections and configuration for the application you are securing.
					</li><li class="listitem">
						A private key PEM file, which is a text file in the PEM format that defines the private key the application uses to sign documents.
					</li><li class="listitem">
						A certificate PEM file, which is a text file that defines the certificate for your application.
					</li><li class="listitem">
						mod_auth_mellon-specific Apache HTTPD module configuration.
					</li></ul></div><section class="section" id="configuring_mod_auth_mellon_with_red_hat_single_sign_on"><div class="titlepage"><div><div><h3 class="title">3.2.1. Configuring mod_auth_mellon with Red Hat Single Sign-On</h3></div></div></div><p>
					There are two hosts involved:
				</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">
							The host on which Red Hat Single Sign-On is running, which will be referred to as $idp_host because Red Hat Single Sign-On is a SAML identity provider (IdP).
						</li><li class="listitem">
							The host on which the web application is running, which will be referred to as $sp_host. In SAML an application using an IdP is called a service provider (SP).
						</li></ul></div><p>
					All of the following steps need to performed on $sp_host with root privileges.
				</p><section class="section" id="installing_the_packages"><div class="titlepage"><div><div><h4 class="title">3.2.1.1. Installing the Packages</h4></div></div></div><p>
						To install the necessary packages, you will need:
					</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">
								Apache Web Server (httpd)
							</li><li class="listitem">
								Mellon SAML SP add-on module for Apache
							</li><li class="listitem">
								Tools to create X509 certificates
							</li></ul></div><p>
						To install the necessary packages, run this command:
					</p><pre class="literallayout">yum install httpd mod_auth_mellon mod_ssl openssl</pre></section><section class="section" id="creating_a_configuration_directory_for_apache_saml"><div class="titlepage"><div><div><h4 class="title">3.2.1.2. Creating a Configuration Directory for Apache SAML</h4></div></div></div><p>
						It is advisable to keep configuration files related to Apache’s use of SAML in one location.
					</p><p>
						Create a new directory named saml2 located under the Apache configuration root /etc/httpd:
					</p><pre class="literallayout">mkdir /etc/httpd/saml2</pre></section><section class="section" id="configuring_the_mellon_service_provider"><div class="titlepage"><div><div><h4 class="title">3.2.1.3. Configuring the Mellon Service Provider</h4></div></div></div><p>
						Configuration files for Apache add-on modules are located in the /etc/httpd/conf.d directory and have a file name extension of .conf. You need to create the /etc/httpd/conf.d/mellon.conf file and place Mellon’s configuration directives in it.
					</p><p>
						Mellon’s configuration directives can roughly be broken down into two classes of information:
					</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">
								Which URLs to protect with SAML authentication
							</li><li class="listitem">
								What SAML parameters will be used when a protected URL is referenced.
							</li></ul></div><p>
						Apache configuration directives typically follow a hierarchical tree structure in the URL space, which are known as locations. You need to specify one or more URL locations for Mellon to protect. You have flexibility in how you add the configuration parameters that apply to each location. You can either add all the necessary parameters to the location block or you can add Mellon parameters to a common location high up in the URL location hierarchy that specific protected locations inherit (or some combination of the two). Since it is common for an SP to operate in the same way no matter which location triggers SAML actions, the example configuration used here places common Mellon configuration directives in the root of the hierarchy and then specific locations to be protected by Mellon can be defined with minimal directives. This strategy avoids duplicating the same parameters for each protected location.
					</p><p>
						This example has just one protected location: https://$sp_host/private.
					</p><p>
						To configure the Mellon service provider, complete the following steps:
					</p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem">
								Create the file /etc/httpd/conf.d/mellon.conf with this content:
							</li></ol></div><pre class="programlisting language-xml"> &lt;Location / &gt;
    MellonEnable info
    MellonEndpointPath /mellon/
    MellonSPMetadataFile /etc/httpd/saml2/mellon_metadata.xml
    MellonSPPrivateKeyFile /etc/httpd/saml2/mellon.key
    MellonSPCertFile /etc/httpd/saml2/mellon.crt
    MellonIdPMetadataFile /etc/httpd/saml2/idp_metadata.xml
 &lt;/Location&gt;
 &lt;Location /private &gt;
    AuthType Mellon
    MellonEnable auth
    Require valid-user
 &lt;/Location&gt;</pre><div class="admonition note"><div class="admonition_header">Note</div><div><p>
							Some of the files referenced in the code above are created in later steps.
						</p></div></div></section><section class="section" id="creating_the_service_provider_metadata"><div class="titlepage"><div><div><h4 class="title">3.2.1.4. Creating the Service Provider Metadata</h4></div></div></div><p>
						In SAML IdPs and SPs exchange SAML metadata, which is in XML format. The schema for the metadata is a standard, thus assuring participating SAML entities can consume each other’s metadata. You need:
					</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">
								Metadata for the IdP that the SP utilizes
							</li><li class="listitem">
								Metadata describing the SP provided to the IdP
							</li></ul></div><p>
						One of the components of SAML metadata is X509 certificates. These certificates are used for two purposes:
					</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">
								Sign SAML messages so the receiving end can prove the message originated from the expected party.
							</li><li class="listitem">
								Encrypt the message during transport (seldom used because SAML messages typically occur on TLS-protected transports)
							</li></ul></div><p>
						You can use your own certificates if you already have a Certificate Authority (CA) or you can generate a self-signed certificate. For simplicity in this example a self-signed certificate is used.
					</p><p>
						Because Mellon’s SP metadata must reflect the capabilities of the installed version of mod_auth_mellon, must be valid SP metadata XML, and must contain an X509 certificate (whose creation can be obtuse unless you are familiar with X509 certificate generation) the most expedient way to produce the SP metadata is to use a tool included in the mod_auth_mellon package (mellon_create_metadata.sh). The generated metadata can always be edited later because it is a text file. The tool also creates your X509 key and certificate.
					</p><p>
						SAML IdPs and SPs identify themselves using a unique name known as an EntityID. To use the Mellon metadata creation tool you need:
					</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">
								The EntityID, which is typically the URL of the SP, and often the URL of the SP where the SP metadata can be retrieved
							</li><li class="listitem">
								The URL where SAML messages for the SP will be consumed, which Mellon calls the MellonEndPointPath.
							</li></ul></div><p>
						To create the SP metadata, complete the following steps:
					</p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p class="simpara">
								Create a few helper shell variables:
							</p><pre class="screen">fqdn=`hostname`
mellon_endpoint_url="https://${fqdn}/mellon"
mellon_entity_id="${mellon_endpoint_url}/metadata"
file_prefix="$(echo "$mellon_entity_id" | sed 's/[^A-Za-z.]/_/g' | sed 's/__*/_/g')"</pre></li><li class="listitem"><p class="simpara">
								Invoke the Mellon metadata creation tool by running this command:
							</p><pre class="screen">/usr/libexec/mod_auth_mellon/mellon_create_metadata.sh $mellon_entity_id $mellon_endpoint_url</pre></li><li class="listitem"><p class="simpara">
								Move the generated files to their destination (referenced in the /etc/httpd/conf.d/mellon.conf file created above):
							</p><pre class="screen">mv ${file_prefix}.cert /etc/httpd/saml2/mellon.crt
mv ${file_prefix}.key /etc/httpd/saml2/mellon.key
mv ${file_prefix}.xml /etc/httpd/saml2/mellon_metadata.xml</pre></li></ol></div></section><section class="section" id="adding_the_mellon_service_provider_to_the_red_hat_single_sign_on_identity_provider"><div class="titlepage"><div><div><h4 class="title">3.2.1.5. Adding the Mellon Service Provider to the Red Hat Single Sign-On Identity Provider</h4></div></div></div><p>
						Assumption: The Red Hat Single Sign-On IdP has already been installed on the $idp_host.
					</p><p>
						Red Hat Single Sign-On supports multiple tenancy where all users, clients, and so on are grouped in what is called a realm. Each realm is independent of other realms. You can use an existing realm in your Red Hat Single Sign-On, but this example shows how to create a new realm called test_realm and use that realm.
					</p><p>
						All these operations are performed using the Red Hat Single Sign-On administration web console. You must have the admin username and password for $idp_host.
					</p><p>
						To complete the following steps:
					</p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p class="simpara">
								Open the Admin Console and log on by entering the admin username and password.
							</p><p class="simpara">
								After logging into the administration console there will be an existing realm. When Red Hat Single Sign-On is first set up a root realm, master, is created by default. Any previously created realms are listed in the upper left corner of the administration console in a drop-down list.
							</p></li><li class="listitem">
								From the realm drop-down list select <span class="strong strong"><strong>Add realm</strong></span>.
							</li><li class="listitem">
								In the Name field type <code class="literal">test_realm</code> and click <span class="strong strong"><strong>Create</strong></span>.
							</li></ol></div><section class="section" id="adding_the_mellon_service_provider_as_a_client_of_the_realm"><div class="titlepage"><div><div><h5 class="title">3.2.1.5.1. Adding the Mellon Service Provider as a Client of the Realm</h5></div></div></div><p>
							In Red Hat Single Sign-On SAML SPs are known as clients. To add the SP we must be in the Clients section of the realm.
						</p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem">
									Click the Clients menu item on the left and click <span class="strong strong"><strong>Create</strong></span> in the upper right corner to create a new client.
								</li></ol></div></section><section class="section" id="adding_the_mellon_sp_client"><div class="titlepage"><div><div><h5 class="title">3.2.1.5.2. Adding the Mellon SP Client</h5></div></div></div><p>
							To add the Mellon SP client, complete the following steps:
						</p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem">
									Set the client protocol to SAML. From the Client Protocol drop down list, select <span class="strong strong"><strong>saml</strong></span>.
								</li><li class="listitem">
									Provide the Mellon SP metadata file created above (/etc/httpd/saml2/mellon_metadata.xml). Depending on where your browser is running you might have to copy the SP metadata from $sp_host to the machine on which your browser is running so the browser can find the file.
								</li><li class="listitem">
									Click <span class="strong strong"><strong>Save</strong></span>.
								</li></ol></div></section><section class="section" id="editing_the_mellon_sp_client"><div class="titlepage"><div><div><h5 class="title">3.2.1.5.3. Editing the Mellon SP Client</h5></div></div></div><p>
							There are several client configuration parameters we suggest setting:
						</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">
									Ensure "Force POST Binding" is On.
								</li><li class="listitem"><p class="simpara">
									Add paosResponse to the Valid Redirect URIs list:
								</p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem">
											Copy the postResponse URL in "Valid Redirect URIs" and paste it into the empty add text fields just below the "+".
										</li><li class="listitem">
											Change "postResponse" to "paosResponse". (The paosResponse URL is needed for SAML ECP.)
										</li><li class="listitem">
											Click <span class="strong strong"><strong>Save</strong></span> at the bottom.
										</li></ol></div></li></ul></div><p>
							Many SAML SPs determine authorization based on a user’s membership in a group. The Red Hat Single Sign-On IdP can manage user group information but it does not supply the user’s groups unless the IdP is configured to supply it as a SAML attribute.
						</p><p>
							To configure the IdP to supply the user’s groups as as a SAML attribute, complete the following steps:
						</p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem">
									Click the Mappers tab of the client.
								</li><li class="listitem">
									In the upper right corner of the Mappers page, click <span class="strong strong"><strong>Create</strong></span>.
								</li><li class="listitem">
									From the Mapper Type drop-down list select <span class="strong strong"><strong>Group list</strong></span>.
								</li><li class="listitem">
									Set Name to "group list".
								</li><li class="listitem">
									Set the SAML attribute name to "groups".
								</li><li class="listitem">
									Click <span class="strong strong"><strong>Save</strong></span>.
								</li></ol></div><p>
							The remaining steps are performed on $sp_host.
						</p></section><section class="section" id="retrieving_the_identity_provider_metadata"><div class="titlepage"><div><div><h5 class="title">3.2.1.5.4. Retrieving the Identity Provider Metadata</h5></div></div></div><p>
							Now that you have created the realm on the IdP you need to retrieve the IdP metadata associated with it so the Mellon SP recognizes it. In the /etc/httpd/conf.d/mellon.conf file created previously, the MellonIdPMetadataFile is specified as /etc/httpd/saml2/idp_metadata.xml but until now that file has not existed on $sp_host. To get that file we will retrieve it from the IdP.
						</p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p class="simpara">
									Retrieve the file from the IdP by substituting $idp_host with the correct value:
								</p><pre class="screen">curl -k -o /etc/httpd/saml2/idp_metadata.xml \
https://$idp_host/auth/realms/test_realm/protocol/saml/descriptor</pre><p class="simpara">
									Mellon is now fully configured.
								</p></li><li class="listitem"><p class="simpara">
									To run a syntax check for Apache configuration files:
								</p><pre class="screen">apachectl configtest</pre><div class="admonition note"><div class="admonition_header">Note</div><div><p>
										Configtest is equivalent to the -t argument to apachectl. If the configuration test shows any errors, correct them before proceeding.
									</p></div></div></li><li class="listitem"><p class="simpara">
									Restart the Apache server:
								</p><pre class="screen">systemctl restart httpd.service</pre></li></ol></div><p>
							You have now set up both Red Hat Single Sign-On as a SAML IdP in the test_realm and mod_auth_mellon as SAML SP protecting the URL $sp_host/protected (and everything beneath it) by authenticating against the <code class="literal">$idp_host</code> IdP.
						</p></section></section></section></section></section><section class="chapter" id="docker_registry_configuration"><div class="titlepage"><div><div><h1 class="title">Chapter 4. Docker Registry Configuration</h1></div></div></div><div class="admonition note"><div class="admonition_header">Note</div><div><p>
				Docker authentication is disabled by default. To enable see <a class="link" href="https://access.redhat.com/documentation/en-us/red_hat_single_sign-on/7.4/html-single/server_installation_and_configuration_guide/#profiles">Profiles</a>.
			</p></div></div><p>
			This section describes how you can configure a Docker registry to use Red Hat Single Sign-On as its authentication server.
		</p><p>
			For more information on how to set up and configure a Docker registry, see the <a class="link" href="https://docs.docker.com/registry/configuration/">Docker Registry Configuration Guide</a>.
		</p><section class="section" id="docker_registry_configuration_file_installation"><div class="titlepage"><div><div><h2 class="title">4.1. Docker Registry Configuration File Installation</h2></div></div></div><p>
				For users with more advanced Docker registry configurations, it is generally recommended to provide your own registry configuration file. The Red Hat Single Sign-On Docker provider supports this mechanism via the <span class="emphasis"><em>Registry Config File</em></span> Format Option. Choosing this option will generate output similar to the following:
			</p><pre class="literallayout">auth:
  token:
    realm: http://localhost:8080/auth/realms/master/protocol/docker-v2/auth
    service: docker-test
    issuer: http://localhost:8080/auth/realms/master</pre><p>
				This output can then be copied into any existing registry config file. See the <a class="link" href="https://docs.docker.com/registry/configuration/">registry config file specification</a> for more information on how the file should be set up, or start with <a class="link" href="https://github.com/docker/distribution/blob/master/cmd/registry/config-example.yml">a basic example</a>.
			</p><div class="admonition warning"><div class="admonition_header">Warning</div><div><p>
					Don’t forget to configure the <code class="literal">rootcertbundle</code> field with the location of the Red Hat Single Sign-On realm’s public certificate. The auth configuration will not work without this argument.
				</p></div></div></section><section class="section" id="docker_registry_environment_variable_override_installation"><div class="titlepage"><div><div><h2 class="title">4.2. Docker Registry Environment Variable Override Installation</h2></div></div></div><p>
				Often times it is appropriate to use a simple environment variable override for develop or POC Docker registries. While this approach is usually not recommended for production use, it can be helpful when one requires quick-and-dirty way to stand up a registry. Simply use the <span class="emphasis"><em>Variable Override</em></span> Format Option from the client installation tab, and an output should appear like the one below:
			</p><pre class="literallayout">REGISTRY_AUTH_TOKEN_REALM: http://localhost:8080/auth/realms/master/protocol/docker-v2/auth
REGISTRY_AUTH_TOKEN_SERVICE: docker-test
REGISTRY_AUTH_TOKEN_ISSUER: http://localhost:8080/auth/realms/master</pre><div class="admonition warning"><div class="admonition_header">Warning</div><div><p>
					Don’t forget to configure the <code class="literal">REGISTRY_AUTH_TOKEN_ROOTCERTBUNDLE</code> override with the location of the Red Hat Single Sign-On realm’s public certificate. The auth configuration will not work without this argument.
				</p></div></div></section><section class="section" id="docker_compose_yaml_file"><div class="titlepage"><div><div><h2 class="title">4.3. Docker Compose YAML File</h2></div></div></div><div class="admonition warning"><div class="admonition_header">Warning</div><div><p>
					This installation method is meant to be an easy way to get a docker registry authenticating against a Red Hat Single Sign-On server. It is intended for development purposes only and should never be used in a production or production-like environment.
				</p></div></div><p>
				The zip file installation mechanism provides a quickstart for developers who want to understand how the Red Hat Single Sign-On server can interact with the Docker registry. In order to configure:
			</p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem">
						From the desired realm, create a client configuration. At this point you won’t have a Docker registry - the quickstart will take care of that part.
					</li><li class="listitem">
						Choose the "Docker Compose YAML" option from the installation tab and download the .zip file
					</li><li class="listitem">
						Unzip the archive to the desired location, and open the directory.
					</li><li class="listitem">
						Start the Docker registry with <code class="literal">docker-compose up</code>
					</li></ol></div><div class="admonition note"><div class="admonition_header">Note</div><div><p>
					it is recommended that you configure the Docker registry client in a realm other than 'master', since the HTTP Basic auth flow will not present forms.
				</p></div></div><p>
				Once the above configuration has taken place, and the keycloak server and Docker registry are running, docker authentication should be successful:
			</p><pre class="literallayout">[user ~]# docker login localhost:5000 -u $username
Password: *******
Login Succeeded</pre></section></section><section class="chapter" id="client_registration"><div class="titlepage"><div><div><h1 class="title">Chapter 5. Client Registration</h1></div></div></div><p>
			In order for an application or service to utilize Red Hat Single Sign-On it has to register a client in Red Hat Single Sign-On. An admin can do this through the admin console (or admin REST endpoints), but clients can also register themselves through the Red Hat Single Sign-On client registration service.
		</p><p>
			The Client Registration Service provides built-in support for Red Hat Single Sign-On Client Representations, OpenID Connect Client Meta Data and SAML Entity Descriptors. The Client Registration Service endpoint is <code class="literal">/auth/realms/&lt;realm&gt;/clients-registrations/&lt;provider&gt;</code>.
		</p><p>
			The built-in supported <code class="literal">providers</code> are:
		</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">
					default - Red Hat Single Sign-On Client Representation (JSON)
				</li><li class="listitem">
					install - Red Hat Single Sign-On Adapter Configuration (JSON)
				</li><li class="listitem">
					openid-connect - OpenID Connect Client Metadata Description (JSON)
				</li><li class="listitem">
					saml2-entity-descriptor - SAML Entity Descriptor (XML)
				</li></ul></div><p>
			The following sections will describe how to use the different providers.
		</p><section class="section" id="authentication"><div class="titlepage"><div><div><h2 class="title">5.1. Authentication</h2></div></div></div><p>
				To invoke the Client Registration Services you usually need a token. The token can be a bearer token, an initial access token or a registration access token. There is an alternative to register new client without any token as well, but then you need to configure Client Registration Policies (see below).
			</p><section class="section" id="bearer_token"><div class="titlepage"><div><div><h3 class="title">5.1.1. Bearer Token</h3></div></div></div><p>
					The bearer token can be issued on behalf of a user or a Service Account. The following permissions are required to invoke the endpoints (see <a class="link" href="https://access.redhat.com/documentation/en-us/red_hat_single_sign-on/7.4/html-single/server_administration_guide/">Server Administration Guide</a> for more details):
				</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">
							create-client or manage-client - To create clients
						</li><li class="listitem">
							view-client or manage-client - To view clients
						</li><li class="listitem">
							manage-client - To update or delete client
						</li></ul></div><p>
					If you are using a bearer token to create clients it’s recommend to use a token from a Service Account with only the <code class="literal">create-client</code> role (see <a class="link" href="https://access.redhat.com/documentation/en-us/red_hat_single_sign-on/7.4/html-single/server_administration_guide/">Server Administration Guide</a> for more details).
				</p></section><section class="section" id="initial_access_token"><div class="titlepage"><div><div><h3 class="title">5.1.2. Initial Access Token</h3></div></div></div><p>
					The recommended approach to registering new clients is by using initial access tokens. An initial access token can only be used to create clients and has a configurable expiration as well as a configurable limit on how many clients can be created.
				</p><p>
					An initial access token can be created through the admin console. To create a new initial access token first select the realm in the admin console, then click on <code class="literal">Realm Settings</code> in the menu on the left, followed by <code class="literal">Client Registration</code> in the tabs displayed in the page. Then finally click on <code class="literal">Initial Access Tokens</code> sub-tab.
				</p><p>
					You will now be able to see any existing initial access tokens. If you have access you can delete tokens that are no longer required. You can only retrieve the value of the token when you are creating it. To create a new token click on <code class="literal">Create</code>. You can now optionally add how long the token should be valid, also how many clients can be created using the token. After you click on <code class="literal">Save</code> the token value is displayed.
				</p><p>
					It is important that you copy/paste this token now as you won’t be able to retrieve it later. If you forget to copy/paste it, then delete the token and create another one.
				</p><p>
					The token value is used as a standard bearer token when invoking the Client Registration Services, by adding it to the Authorization header in the request. For example:
				</p><pre class="screen">Authorization: bearer eyJhbGciOiJSUz...</pre></section><section class="section" id="registration_access_token"><div class="titlepage"><div><div><h3 class="title">5.1.3. Registration Access Token</h3></div></div></div><p>
					When you create a client through the Client Registration Service the response will include a registration access token. The registration access token provides access to retrieve the client configuration later, but also to update or delete the client. The registration access token is included with the request in the same way as a bearer token or initial access token. Registration access tokens are only valid once, when it’s used the response will include a new token.
				</p><p>
					If a client was created outside of the Client Registration Service it won’t have a registration access token associated with it. You can create one through the admin console. This can also be useful if you lose the token for a particular client. To create a new token find the client in the admin console and click on <code class="literal">Credentials</code>. Then click on <code class="literal">Generate registration access token</code>.
				</p></section></section><section class="section" id="red_hat_single_sign_on_representations"><div class="titlepage"><div><div><h2 class="title">5.2. Red Hat Single Sign-On Representations</h2></div></div></div><p>
				The <code class="literal">default</code> client registration provider can be used to create, retrieve, update and delete a client. It uses Red Hat Single Sign-On Client Representation format which provides support for configuring clients exactly as they can be configured through the admin console, including for example configuring protocol mappers.
			</p><p>
				To create a client create a Client Representation (JSON) then perform an HTTP POST request to <code class="literal">/auth/realms/&lt;realm&gt;/clients-registrations/default</code>.
			</p><p>
				It will return a Client Representation that also includes the registration access token. You should save the registration access token somewhere if you want to retrieve the config, update or delete the client later.
			</p><p>
				To retrieve the Client Representation perform an HTTP GET request to <code class="literal">/auth/realms/&lt;realm&gt;/clients-registrations/default/&lt;client id&gt;</code>.
			</p><p>
				It will also return a new registration access token.
			</p><p>
				To update the Client Representation perform an HTTP PUT request with the updated Client Representation to: <code class="literal">/auth/realms/&lt;realm&gt;/clients-registrations/default/&lt;client id&gt;</code>.
			</p><p>
				It will also return a new registration access token.
			</p><p>
				To delete the Client Representation perform an HTTP DELETE request to: <code class="literal">/auth/realms/&lt;realm&gt;/clients-registrations/default/&lt;client id&gt;</code>
			</p></section><section class="section" id="red_hat_single_sign_on_adapter_configuration"><div class="titlepage"><div><div><h2 class="title">5.3. Red Hat Single Sign-On Adapter Configuration</h2></div></div></div><p>
				The <code class="literal">installation</code> client registration provider can be used to retrieve the adapter configuration for a client. In addition to token authentication you can also authenticate with client credentials using HTTP basic authentication. To do this include the following header in the request:
			</p><pre class="screen">Authorization: basic BASE64(client-id + ':' + client-secret)</pre><p>
				To retrieve the Adapter Configuration then perform an HTTP GET request to <code class="literal">/auth/realms/&lt;realm&gt;/clients-registrations/install/&lt;client id&gt;</code>.
			</p><p>
				No authentication is required for public clients. This means that for the JavaScript adapter you can load the client configuration directly from Red Hat Single Sign-On using the above URL.
			</p></section><section class="section" id="openid_connect_dynamic_client_registration"><div class="titlepage"><div><div><h2 class="title">5.4. OpenID Connect Dynamic Client Registration</h2></div></div></div><p>
				Red Hat Single Sign-On implements <a class="link" href="https://openid.net/specs/openid-connect-registration-1_0.html">OpenID Connect Dynamic Client Registration</a>, which extends <a class="link" href="https://tools.ietf.org/html/rfc7591">OAuth 2.0 Dynamic Client Registration Protocol</a> and <a class="link" href="https://tools.ietf.org/html/rfc7592">OAuth 2.0 Dynamic Client Registration Management Protocol</a>.
			</p><p>
				The endpoint to use these specifications to register clients in Red Hat Single Sign-On is <code class="literal">/auth/realms/&lt;realm&gt;/clients-registrations/openid-connect[/&lt;client id&gt;]</code>.
			</p><p>
				This endpoint can also be found in the OpenID Connect Discovery endpoint for the realm, <code class="literal">/auth/realms/&lt;realm&gt;/.well-known/openid-configuration</code>.
			</p></section><section class="section" id="saml_entity_descriptors"><div class="titlepage"><div><div><h2 class="title">5.5. SAML Entity Descriptors</h2></div></div></div><p>
				The SAML Entity Descriptor endpoint only supports using SAML v2 Entity Descriptors to create clients. It doesn’t support retrieving, updating or deleting clients. For those operations the Red Hat Single Sign-On representation endpoints should be used. When creating a client a Red Hat Single Sign-On Client Representation is returned with details about the created client, including a registration access token.
			</p><p>
				To create a client perform an HTTP POST request with the SAML Entity Descriptor to <code class="literal">/auth/realms/&lt;realm&gt;/clients-registrations/saml2-entity-descriptor</code>.
			</p></section><section class="section" id="example_using_curl_2"><div class="titlepage"><div><div><h2 class="title">5.6. Example using CURL</h2></div></div></div><p>
				The following example creates a client with the clientId <code class="literal">myclient</code> using CURL. You need to replace <code class="literal">eyJhbGciOiJSUz…​</code> with a proper initial access token or bearer token.
			</p><pre class="programlisting language-bash">curl -X POST \
    -d '{ "clientId": "myclient" }' \
    -H "Content-Type:application/json" \
    -H "Authorization: bearer eyJhbGciOiJSUz..." \
    http://localhost:8080/auth/realms/master/clients-registrations/default</pre></section><section class="section" id="example_using_java_client_registration_api"><div class="titlepage"><div><div><h2 class="title">5.7. Example using Java Client Registration API</h2></div></div></div><p>
				The Client Registration Java API makes it easy to use the Client Registration Service using Java. To use include the dependency <code class="literal">org.keycloak:keycloak-client-registration-api:&gt;VERSION&lt;</code> from Maven.
			</p><p>
				For full instructions on using the Client Registration refer to the JavaDocs. Below is an example of creating a client. You need to replace <code class="literal">eyJhbGciOiJSUz…​</code> with a proper initial access token or bearer token.
			</p><pre class="programlisting language-java">String token = "eyJhbGciOiJSUz...";

ClientRepresentation client = new ClientRepresentation();
client.setClientId(CLIENT_ID);

ClientRegistration reg = ClientRegistration.create()
    .url("http://localhost:8080/auth", "myrealm")
    .build();

reg.auth(Auth.token(token));

client = reg.create(client);

String registrationAccessToken = client.getRegistrationAccessToken();</pre></section><section class="section" id="client_registration_policies"><div class="titlepage"><div><div><h2 class="title">5.8. Client Registration Policies</h2></div></div></div><p>
				Red Hat Single Sign-On currently supports 2 ways how can be new clients registered through Client Registration Service.
			</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">
						Authenticated requests - Request to register new client must contain either <code class="literal">Initial Access Token</code> or <code class="literal">Bearer Token</code> as mentioned above.
					</li><li class="listitem">
						Anonymous requests - Request to register new client doesn’t need to contain any token at all
					</li></ul></div><p>
				Anonymous client registration requests are very interesting and powerful feature, however you usually don’t want that anyone is able to register new client without any limitations. Hence we have <code class="literal">Client Registration Policy SPI</code>, which provide a way to limit who can register new clients and under which conditions.
			</p><p>
				In Red Hat Single Sign-On admin console, you can click to <code class="literal">Client Registration</code> tab and then <code class="literal">Client Registration Policies</code> sub-tab. Here you will see what policies are configured by default for anonymous requests and what policies are configured for authenticated requests.
			</p><div class="admonition note"><div class="admonition_header">Note</div><div><p>
					The anonymous requests (requests without any token) are allowed just for creating (registration) of new clients. So when you register new client through anonymous request, the response will contain Registration Access Token, which must be used for Read, Update or Delete request of particular client. However using this Registration Access Token from anonymous registration will be then subject to Anonymous Policy too! This means that for example request for update client also needs to come from Trusted Host if you have <code class="literal">Trusted Hosts</code> policy. Also for example it won’t be allowed to disable <code class="literal">Consent Required</code> when updating client and when <code class="literal">Consent Required</code> policy is present etc.
				</p></div></div><p>
				Currently we have these policy implementations:
			</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">
						Trusted Hosts Policy - You can configure list of trusted hosts and trusted domains. Request to Client Registration Service can be sent just from those hosts or domains. Request sent from some untrusted IP will be rejected. URLs of newly registered client must also use just those trusted hosts or domains. For example it won’t be allowed to set <code class="literal">Redirect URI</code> of client pointing to some untrusted host. By default, there is not any whitelisted host, so anonymous client registration is de-facto disabled.
					</li><li class="listitem">
						Consent Required Policy - Newly registered clients will have <code class="literal">Consent Allowed</code> switch enabled. So after successful authentication, user will always see consent screen when he needs to approve permissions (client scopes). It means that client won’t have access to any personal info or permission of user unless user approves it.
					</li><li class="listitem">
						Protocol Mappers Policy - Allows to configure list of whitelisted protocol mapper implementations. New client can’t be registered or updated if it contains some non-whitelisted protocol mapper. Note that this policy is used for authenticated requests as well, so even for authenticated request there are some limitations which protocol mappers can be used.
					</li><li class="listitem">
						Client Scope Policy - Allow to whitelist <code class="literal">Client Scopes</code>, which can be used with newly registered or updated clients. There are no whitelisted scopes by default; only the client scopes, which are defined as <code class="literal">Realm Default Client Scopes</code> are whitelisted by default.
					</li><li class="listitem">
						Full Scope Policy - Newly registered clients will have <code class="literal">Full Scope Allowed</code> switch disabled. This means they won’t have any scoped realm roles or client roles of other clients.
					</li><li class="listitem">
						Max Clients Policy - Rejects registration if current number of clients in the realm is same or bigger than specified limit. It’s 200 by default for anonymous registrations.
					</li><li class="listitem">
						Client Disabled Policy - Newly registered client will be disabled. This means that admin needs to manually approve and enable all newly registered clients. This policy is not used by default even for anonymous registration.
					</li></ul></div></section></section><section class="chapter" id="client_registration_cli"><div class="titlepage"><div><div><h1 class="title">Chapter 6. Client Registration CLI</h1></div></div></div><p>
			The Client Registration CLI is a command-line interface (CLI) tool for application developers to configure new clients in a self-service manner when integrating with Red Hat Single Sign-On. It is specifically designed to interact with Red Hat Single Sign-On Client Registration REST endpoints.
		</p><p>
			It is necessary to create or obtain a client configuration for any application to be able to use Red Hat Single Sign-On. You usually configure a new client for each new application hosted on a unique host name. When an application interacts with Red Hat Single Sign-On, the application identifies itself with a client ID so Red Hat Single Sign-On can provide a login page, single sign-on (SSO) session management, and other services.
		</p><p>
			You can configure application clients from a command line with the Client Registration CLI, and you can use it in shell scripts.
		</p><p>
			To allow a particular user to use <code class="literal">Client Registration CLI</code> the Red Hat Single Sign-On administrator typically uses the Admin Console to configure a new user with proper roles or to configure a new client and client secret to grant access to the Client Registration REST API.
		</p><section class="section" id="configuring_a_user_for_client_registration_cli"><div class="titlepage"><div><div><h2 class="title">6.1. Configuring a new regular user for use with Client Registration CLI</h2></div></div></div><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem">
						Log in to the Admin Console (for example, <a class="link" href="http://localhost:8080/auth/admin">http://localhost:8080/auth/admin</a>) as <code class="literal command">admin</code>.
					</li><li class="listitem">
						Select a realm to administer.
					</li><li class="listitem">
						If you want to use an existing user, select that user to edit; otherwise, create a new user.
					</li><li class="listitem">
						Select <span class="strong strong"><strong>Role Mappings &gt; Client Roles &gt; realm-management</strong></span>. If you are in the master realm, select <span class="strong strong"><strong>NAME-realm</strong></span>, where <code class="literal">NAME</code> is the name of the target realm. You can grant access to any other realm to users in the master realm.
					</li><li class="listitem"><p class="simpara">
						Select <span class="strong strong"><strong>Available Roles &gt; manage-client</strong></span> to grant a full set of client management permissions. Another option is to choose <span class="strong strong"><strong>view-clients</strong></span> for read-only or <span class="strong strong"><strong>create-client</strong></span> to create new clients.
					</p><div class="admonition note"><div class="admonition_header">Note</div><div><p>
							These permissions grant the user the capability to perform operations without the use of <a class="link" href="#initial_access_token" title="5.1.2. Initial Access Token">Initial Access Token</a> or <a class="link" href="#registration_access_token" title="5.1.3. Registration Access Token">Registration Access Token</a>.
						</p></div></div></li></ol></div><p>
				It is possible to not assign any <code class="literal command">realm-management</code> roles to a user. In that case, a user can still log in with the Client Registration CLI but cannot use it without an Initial Access Token. Trying to perform any operations without a token results in a <span class="strong strong"><strong>403 Forbidden</strong></span> error.
			</p><p>
				The Administrator can issue Initial Access Tokens from the Admin Console through the <span class="strong strong"><strong>Realm Settings &gt; Client Registration &gt; Initial Access Token</strong></span> menu.
			</p></section><section class="section" id="configuring_a_client_for_use_with_client_registration_cli"><div class="titlepage"><div><div><h2 class="title">6.2. Configuring a client for use with the Client Registration CLI</h2></div></div></div><p>
				By default, the server recognizes the Client Registration CLI as the <code class="literal filename">admin-cli</code> client, which is configured automatically for every new realm. No additional client configuration is necessary when logging in with a user name.
			</p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem">
						Create a new client (for example, <code class="literal filename">reg-cli</code>) if you want to use a separate client configuration for the Client Registration CLI.
					</li><li class="listitem">
						Toggle the <span class="strong strong"><strong>Standard Flow Enabled</strong></span> setting it to <span class="strong strong"><strong>Off</strong></span>.
					</li><li class="listitem"><p class="simpara">
						Strengthen the security by configuring the client <code class="literal filename">Access Type</code> as <code class="literal filename">Confidential</code> and selecting <span class="strong strong"><strong>Credentials &gt; ClientId and Secret</strong></span>.
					</p><div class="admonition note"><div class="admonition_header">Note</div><div><p>
							You can configure either <code class="literal filename">Client Id and Secret</code> or <code class="literal filename">Signed JWT</code> under the <span class="strong strong"><strong>Credentials</strong></span> tab .
						</p></div></div></li><li class="listitem"><p class="simpara">
						Enable service accounts if you want to use a service account associated with the client by selecting a client to edit in the <span class="strong strong"><strong>Clients</strong></span> section of the <code class="literal">Admin Console</code>.
					</p><div class="orderedlist"><ol class="orderedlist" type="a"><li class="listitem">
								Under <span class="strong strong"><strong>Settings</strong></span>, change the <span class="strong strong"><strong>Access Type</strong></span> to <span class="strong strong"><strong>Confidential</strong></span>, toggle the <span class="strong strong"><strong>Service Accounts Enabled</strong></span> setting to <span class="strong strong"><strong>On</strong></span>, and click <span class="strong strong"><strong>Save</strong></span>.
							</li><li class="listitem">
								Click <span class="strong strong"><strong>Service Account Roles</strong></span> and select desired roles to configure the access for the service account. For the details on what roles to select, see <a class="xref" href="#configuring_a_user_for_client_registration_cli" title="6.1. Configuring a new regular user for use with Client Registration CLI">Section 6.1, “Configuring a new regular user for use with Client Registration CLI”</a>.
							</li></ol></div></li><li class="listitem">
						Toggle the <span class="strong strong"><strong>Direct Access Grants Enabled</strong></span> setting it to <span class="strong strong"><strong>On</strong></span> if you want to use a regular user account instead of a service account.
					</li><li class="listitem">
						If the client is configured as <code class="literal filename">Confidential</code>, provide the configured secret when running <code class="literal command">kcreg config credentials</code> by using the <code class="literal command">--secret</code> option.
					</li><li class="listitem">
						Specify which <code class="literal filename">clientId</code> to use (for example, <code class="literal command">--client reg-cli</code>) when running <code class="literal command">kcreg config credentials</code>.
					</li><li class="listitem">
						With the service account enabled, you can omit specifying the user when running <code class="literal command">kcreg config credentials</code> and only provide the client secret or keystore information.
					</li></ol></div></section><section class="section" id="installing_client_registration_cli"><div class="titlepage"><div><div><h2 class="title">6.3. Installing the Client Registration CLI</h2></div></div></div><p>
				The Client Registration CLI is packaged inside the Red Hat Single Sign-On Server distribution. You can find execution scripts inside the <code class="literal filename">bin</code> directory. The Linux script is called <code class="literal filename">kcreg.sh</code>, and the Windows script is called <code class="literal filename">kcreg.bat</code>.
			</p><p>
				Add the Red Hat Single Sign-On server directory to your <code class="literal filename">PATH</code> when setting up the client for use from any location on the file system.
			</p><p>
				For example, on:
			</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">
						Linux:
					</li></ul></div><pre class="screen">$ export PATH=$PATH:$KEYCLOAK_HOME/bin
$ kcreg.sh</pre><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">
						Windows:
					</li></ul></div><pre class="screen">c:\&gt; set PATH=%PATH%;%KEYCLOAK_HOME%\bin
c:\&gt; kcreg</pre><p>
				<code class="literal filename">KEYCLOAK_HOME</code> refers to a directory where the Red Hat Single Sign-On Server distribution was unpacked.
			</p></section><section class="section" id="using_client_registration_cli"><div class="titlepage"><div><div><h2 class="title">6.4. Using the Client Registration CLI</h2></div></div></div><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem">
						Start an authenticated session by logging in with your credentials.
					</li><li class="listitem"><p class="simpara">
						Run commands on the <code class="literal filename">Client Registration REST</code> endpoint.
					</p><p class="simpara">
						For example, on:
					</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p class="simpara">
								Linux:
							</p><pre class="screen">$ kcreg.sh config credentials --server http://localhost:8080/auth --realm demo --user user --client reg-cli
$ kcreg.sh create -s clientId=my_client -s 'redirectUris=["http://localhost:8980/myapp/*"]'
$ kcreg.sh get my_client</pre></li><li class="listitem"><p class="simpara">
								Windows:
							</p><pre class="screen">c:\&gt; kcreg config credentials --server http://localhost:8080/auth --realm demo --user user --client reg-cli
c:\&gt; kcreg create -s clientId=my_client -s "redirectUris=[\"http://localhost:8980/myapp/*\"]"
c:\&gt; kcreg get my_client</pre><div class="admonition note"><div class="admonition_header">Note</div><div><p>
									In a production environment, Red Hat Single Sign-On has to be accessed with <code class="literal filename">https:</code> to avoid exposing tokens to network sniffers.
								</p></div></div></li></ul></div></li><li class="listitem"><p class="simpara">
						If a server’s certificate is not issued by one of the trusted certificate authorities (CAs) that are included in Java’s default certificate truststore, prepare a <code class="literal filename">truststore.jks</code> file and instruct the Client Registration CLI to use it.
					</p><p class="simpara">
						For example, on:
					</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p class="simpara">
								Linux:
							</p><pre class="screen">$ kcreg.sh config truststore --trustpass $PASSWORD ~/.keycloak/truststore.jks</pre></li><li class="listitem"><p class="simpara">
								Windows:
							</p><pre class="screen">c:\&gt; kcreg config truststore --trustpass %PASSWORD% %HOMEPATH%\.keycloak\truststore.jks</pre></li></ul></div></li></ol></div><section class="section" id="logging_in"><div class="titlepage"><div><div><h3 class="title">6.4.1. Logging in</h3></div></div></div><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem">
							Specify a server endpoint URL and a realm when you log in with the Client Registration CLI.
						</li><li class="listitem">
							Specify a user name or a client id, which results in a special service account being used. When using a user name, you must use a password for the specified user. When using a client ID, you use a client secret or a <code class="literal filename">Signed JWT</code> instead of a password.
						</li></ol></div><p>
					Regardless of the login method, the account that logs in needs proper permissions to be able to perform client registration operations. Keep in mind that any account in a non-master realm can only have permissions to manage clients within the same realm. If you need to manage different realms, you can either configure multiple users in different realms, or you can create a single user in the <code class="literal filename">master</code> realm and add roles for managing clients in different realms.
				</p><p>
					You cannot configure users with the Client Registration CLI. Use the Admin Console web interface or the Admin Client CLI to configure users. See <a class="link" href="https://access.redhat.com/documentation/en-us/red_hat_single_sign-on/7.4/html-single/server_administration_guide/">Server Administration Guide</a> for more details.
				</p><p>
					When <code class="literal filename">kcreg</code> successfully logs in, it receives authorization tokens and saves them in a private configuration file so the tokens can be used for subsequent invocations. See <a class="xref" href="#working_with_alternative_configurations" title="6.4.2. Working with alternative configurations">Section 6.4.2, “Working with alternative configurations”</a> for more information on configuration files.
				</p><p>
					See the built-in help for more information on using the Client Registration CLI.
				</p><p>
					For example, on:
				</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">
							Linux:
						</li></ul></div><pre class="screen">$ kcreg.sh help</pre><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">
							Windows:
						</li></ul></div><pre class="screen">c:\&gt; kcreg help</pre><p>
					See <code class="literal filename">kcreg config credentials --help</code> for more information about starting an authenticated session.
				</p></section><section class="section" id="working_with_alternative_configurations"><div class="titlepage"><div><div><h3 class="title">6.4.2. Working with alternative configurations</h3></div></div></div><p>
					By default, the Client Registration CLI automatically maintains a configuration file at a default location, <code class="literal filename">./.keycloak/kcreg.config</code>, under the user’s home directory. You can use the <code class="literal command">--config</code> option to point to a different file or location to mantain multiple authenticated sessions in parallel. It is the safest way to perform operations tied to a single configuration file from a single thread.
				</p><div class="admonition important"><div class="admonition_header">Important</div><div><p>
						Do not make the configuration file visible to other users on the system. The configuration file contains access tokens and secrets that should be kept private.
					</p></div></div><p>
					You might want to avoid storing secrets inside a configuration file by using the <code class="literal command">--no-config</code> option with all of your commands, even though it is less convenient and requires more token requests to do so. Specify all authentication information with each <code class="literal command">kcreg</code> invocation.
				</p></section><section class="section" id="initial_access_and_registration_access_tokens"><div class="titlepage"><div><div><h3 class="title">6.4.3. Initial Access and Registration Access Tokens</h3></div></div></div><p>
					Developers who do not have an account configured at the Red Hat Single Sign-On server they want to use can use the Client Registration CLI. This is possible only when the realm administrator issues a developer an Initial Access Token. It is up to the realm administrator to decide how and when to issue and distribute these tokens. The realm administrator can limit the maximum age of the Initial Access Token and the total number of clients that can be created with it.
				</p><p>
					Once a developer has an Initial Access Token, the developer can use it to create new clients without authenticating with <code class="literal command">kcreg config credentials</code>. The Initial Access Token can be stored in the configuration file or specified as part of the <code class="literal command">kcreg create</code> command.
				</p><p>
					For example, on:
				</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">
							Linux:
						</li></ul></div><pre class="screen">$ kcreg.sh config initial-token $TOKEN
$ kcreg.sh create -s clientId=myclient</pre><p>
					or
				</p><pre class="screen">$ kcreg.sh create -s clientId=myclient -t $TOKEN</pre><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">
							Windows:
						</li></ul></div><pre class="screen">c:\&gt; kcreg config initial-token %TOKEN%
c:\&gt; kcreg create -s clientId=myclient</pre><p>
					or
				</p><pre class="screen">c:\&gt; kcreg create -s clientId=myclient -t %TOKEN%</pre><p>
					When using an Initial Access Token, the server response includes a newly issued Registration Access Token. Any subsequent operation for that client needs to be performed by authenticating with that token, which is only valid for that client.
				</p><p>
					The Client Registration CLI automatically uses its private configuration file to save and use this token with its associated client. As long as the same configuration file is used for all client operations, the developer does not need to authenticate to read, update, or delete a client that was created this way.
				</p><p>
					See <a class="link" href="#client_registration" title="Chapter 5. Client Registration">Client Registration</a> for more information about Initial Access and Registration Access Tokens.
				</p><p>
					Run the <code class="literal command">kcreg config initial-token --help</code> and <code class="literal command">kcreg config registration-token --help</code> commands for more information on how to configure tokens with the Client Registration CLI.
				</p></section><section class="section" id="performing_crud_operations"><div class="titlepage"><div><div><h3 class="title">6.4.4. Creating a client configuration</h3></div></div></div><p>
					The first task after authenticating with credentials or configuring an Initial Access Token is usually to create a new client. Often you might want to use a prepared JSON file as a template and set or override some of the attributes.
				</p><p>
					The following example shows how to read a JSON file, override any client id it may contain, set any other attributes, and print the configuration to a standard output after successful creation.
				</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">
							Linux:
						</li></ul></div><pre class="screen">$ kcreg.sh create -f client-template.json -s clientId=myclient -s baseUrl=/myclient -s 'redirectUris=["/myclient/*"]' -o</pre><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">
							Windows:
						</li></ul></div><pre class="screen">C:\&gt; kcreg create -f client-template.json -s clientId=myclient -s baseUrl=/myclient -s "redirectUris=[\"/myclient/*\"]" -o</pre><p>
					Run the <code class="literal command">kcreg create --help</code> for more information about the <code class="literal command">kcreg create</code> command.
				</p><p>
					You can use <code class="literal command">kcreg attrs</code> to list available attributes. Keep in mind that many configuration attributes are not checked for validity or consistency. It is up to you to specify proper values. Remember that you should not have any id fields in your template and should not specify them as arguments to the <code class="literal command">kcreg create</code> command.
				</p></section><section class="section" id="retrieving_a_client_configuration"><div class="titlepage"><div><div><h3 class="title">6.4.5. Retrieving a client configuration</h3></div></div></div><p>
					You can retrieve an existing client by using the <code class="literal command">kcreg get</code> command.
				</p><p>
					For example, on:
				</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">
							Linux:
						</li></ul></div><pre class="screen">$ kcreg.sh get myclient</pre><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">
							Windows:
						</li></ul></div><pre class="screen">C:\&gt; kcreg get myclient</pre><p>
					You can also retrieve the client configuration as an adapter configuration file, which you can package with your web application.
				</p><p>
					For example, on:
				</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">
							Linux:
						</li></ul></div><pre class="screen">$ kcreg.sh get myclient -e install &gt; keycloak.json</pre><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">
							Windows:
						</li></ul></div><pre class="screen">C:\&gt; kcreg get myclient -e install &gt; keycloak.json</pre><p>
					Run the <code class="literal command">kcreg get --help</code> command for more information about the <code class="literal command">kcreg get</code> command.
				</p></section><section class="section" id="modifying_a_client_configuration"><div class="titlepage"><div><div><h3 class="title">6.4.6. Modifying a client configuration</h3></div></div></div><p>
					There are two methods for updating a client configuration.
				</p><p>
					One method is to submit a complete new state to the server after getting the current configuration, saving it to a file, editing it, and posting it back to the server.
				</p><p>
					For example, on:
				</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">
							Linux:
						</li></ul></div><pre class="screen">$ kcreg.sh get myclient &gt; myclient.json
$ vi myclient.json
$ kcreg.sh update myclient -f myclient.json</pre><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">
							Windows:
						</li></ul></div><pre class="screen">C:\&gt; kcreg get myclient &gt; myclient.json
C:\&gt; notepad myclient.json
C:\&gt; kcreg update myclient -f myclient.json</pre><p>
					The second method fetches the current client, sets or deletes fields on it, and posts it back in one step.
				</p><p>
					For example, on:
				</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">
							Linux:
						</li></ul></div><pre class="screen">$ kcreg.sh update myclient -s enabled=false -d redirectUris</pre><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">
							Windows:
						</li></ul></div><pre class="screen">C:\&gt; kcreg update myclient -s enabled=false -d redirectUris</pre><p>
					You can also use a file that contains only changes to be applied so you do not have to specify too many values as arguments. In this case, specify <code class="literal command">--merge</code> to tell the Client Registration CLI that rather than treating the JSON file as a full, new configuration, it should treat it as a set of attributes to be applied over the existing configuration.
				</p><p>
					For example, on:
				</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">
							Linux:
						</li></ul></div><pre class="screen">$ kcreg.sh update myclient --merge -d redirectUris -f mychanges.json</pre><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">
							Windows:
						</li></ul></div><pre class="screen">C:\&gt; kcreg update myclient --merge -d redirectUris -f mychanges.json</pre><p>
					Run the <code class="literal command">kcreg update --help</code> command for more information about the <code class="literal command">kcreg update</code> command.
				</p></section><section class="section" id="deleting_a_client_configuration"><div class="titlepage"><div><div><h3 class="title">6.4.7. Deleting a client configuration</h3></div></div></div><p>
					Use the following example to delete a client.
				</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">
							Linux:
						</li></ul></div><pre class="screen">$ kcreg.sh delete myclient</pre><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">
							Windows:
						</li></ul></div><pre class="screen">C:\&gt; kcreg delete myclient</pre><p>
					Run the <code class="literal command">kcreg delete --help</code> command for more information about the <code class="literal command">kcreg delete</code> command.
				</p></section><section class="section" id="refreshing_invalid_registration_access_tokens"><div class="titlepage"><div><div><h3 class="title">6.4.8. Refreshing invalid Registration Access Tokens</h3></div></div></div><p>
					When performing a create, read, update, and delete (CRUD) operation using the <code class="literal command">--no-config</code> mode, the Client Registration CLI cannot handle Registration Access Tokens for you. In that case, it is possible to lose track of the most recently issued Registration Access Token for a client, which makes it impossible to perform any further CRUD operations on that client without authenticating with an account that has <span class="strong strong"><strong>manage-clients</strong></span> permissions.
				</p><p>
					If you have permissions, you can issue a new Registration Access Token for the client and have it printed to a standard output or saved to a configuration file of your choice. Otherwise, you have to ask the realm administrator to issue a new Registration Access Token for your client and send it to you. You can then pass it to any CRUD command via the <code class="literal command">--token</code> option. You can also use the <code class="literal command">kcreg config registration-token</code> command to save the new token in a configuration file and have the Client Registration CLI automatically handle it for you from that point on.
				</p><p>
					Run the <code class="literal command">kcreg update-token --help</code> command for more information about the <code class="literal command">kcreg update-token</code> command.
				</p></section></section><section class="section" id="troubleshooting_2"><div class="titlepage"><div><div><h2 class="title">6.5. Troubleshooting</h2></div></div></div><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p class="simpara">
						Q: When logging in, I get an error: <span class="strong strong"><strong>Parameter client_assertion_type is missing [invalid_client]</strong></span>.
					</p><p class="simpara">
						A: This error means your client is configured with <code class="literal filename">Signed JWT</code> token credentials, which means you have to use the <code class="literal command">--keystore</code> parameter when logging in.
					</p></li></ul></div></section></section><section class="chapter" id="token-exchange"><div class="titlepage"><div><div><h1 class="title">Chapter 7. Token Exchange</h1></div></div></div><div class="admonition note"><div class="admonition_header">Note</div><div><p>
				Token Exchange is <span class="strong strong"><strong>Technology Preview</strong></span> and is not fully supported. This feature is disabled by default.
			</p><p>
				To enable start the server with <code class="literal">-Dkeycloak.profile=preview</code> or <code class="literal">-Dkeycloak.profile.feature.token_exchange=enabled</code> . For more details see <a class="link" href="https://access.redhat.com/documentation/en-us/red_hat_single_sign-on/7.4/html-single/server_installation_and_configuration_guide/#profiles">Profiles</a>.
			</p></div></div><p>
			In Red Hat Single Sign-On, token exchange is the process of using a set of credentials or token to obtain an entirely different token. A client may want to invoke on a less trusted application so it may want to downgrade the current token it has. A client may want to exchange a Red Hat Single Sign-On token for a token stored for a linked social provider account. You may want to trust external tokens minted by other Red Hat Single Sign-On realms or foreign IDPs. A client may have a need to impersonate a user. Here’s a short summary of the current capabilities of Red Hat Single Sign-On around token exchange.
		</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">
					A client can exchange an existing Red Hat Single Sign-On token created for a specific client for a new token targeted to a different client
				</li><li class="listitem">
					A client can exchange an existing Red Hat Single Sign-On token for an external token, i.e. a linked Facebook account
				</li><li class="listitem">
					A client can exchange an external token for a Red Hat Single Sign-On token.
				</li><li class="listitem">
					A client can impersonate a user
				</li></ul></div><p>
			Token exchange in Red Hat Single Sign-On is a very loose implementation of the <a class="link" href="https://tools.ietf.org/html/draft-ietf-oauth-token-exchange-16">OAuth Token Exchange</a> specification at the IETF. We have extended it a little, ignored some of it, and loosely interpreted other parts of the specification. It is a simple grant type invocation on a realm’s OpenID Connect token endpoint.
		</p><pre class="screen">/auth/realms/{realm}/protocol/openid-connect/token</pre><p>
			It accepts form parameters (<code class="literal">application/x-www-form-urlencoded</code>) as input and the output depends on the type of token you requested an exchange for. Token exchange is a client endpoint so requests must provide authentication information for the calling client. Public clients specify their client identifier as a form parameter. Confidential clients can also use form parameters to pass their client id and secret, Basic Auth, or however your admin has configured the client authentication flow in your realm. Here’s a list of form parameters
		</p><div class="variablelist"><dl class="variablelist"><dt><span class="term">client_id</span></dt><dd>
						<span class="emphasis"><em>REQUIRED MAYBE.</em></span> This parameter is required for clients using form parameters for authentication. If you are using Basic Auth, a client JWT token, or client cert authentication, then do not specify this parameter.
					</dd><dt><span class="term">client_secret</span></dt><dd>
						<span class="emphasis"><em>REQUIRED MAYBE</em></span>. This parameter is required for clients using form parameters for authentication and using a client secret as a credential. Do not specify this parameter if client invocations in your realm are authenticated by a different means.
					</dd><dt><span class="term">grant_type</span></dt><dd>
						<span class="emphasis"><em>REQUIRED.</em></span> The value of the parameter must be <code class="literal">urn:ietf:params:oauth:grant-type:token-exchange</code>.
					</dd><dt><span class="term">subject_token</span></dt><dd>
						<span class="emphasis"><em>OPTIONAL.</em></span> A security token that represents the identity of the party on behalf of whom the request is being made. It is required if you are exchanging an existing token for a new one.
					</dd><dt><span class="term">subject_issuer</span></dt><dd>
						<span class="emphasis"><em>OPTIONAL.</em></span> Identifies the issuer of the <code class="literal">subject_token</code>. It can be left blank if the token comes from the current realm or if the issuer can be determined from the <code class="literal">subject_token_type</code>. Otherwise it is required to be specified. Valid values are the alias of an <code class="literal">Identity Provider</code> configured for your realm. Or an issuer claim identifier configured by a specific <code class="literal">Identity Provider</code>.
					</dd><dt><span class="term">subject_token_type</span></dt><dd>
						<span class="emphasis"><em>OPTIONAL.</em></span> This parameter is the type of the token passed with the <code class="literal">subject_token</code> parameter. This defaults to <code class="literal">urn:ietf:params:oauth:token-type:access_token</code> if the <code class="literal">subject_token</code> comes from the realm and is an access token. If it is an external token, this parameter may or may not have to be specified depending on the requirements of the <code class="literal">subject_issuer</code>.
					</dd><dt><span class="term">requested_token_type</span></dt><dd>
						<span class="emphasis"><em>OPTIONAL.</em></span> This parameter represents the type of token the client wants to exchange for. Currently only oauth and OpenID Connect token types are supported. The default value for this depends on whether the is <code class="literal">urn:ietf:params:oauth:token-type:refresh_token</code> in which case you will be returned both an access token and refresh token within the response. Other appropriate values are <code class="literal">urn:ietf:params:oauth:token-type:access_token</code> and <code class="literal">urn:ietf:params:oauth:token-type:id_token</code>
					</dd><dt><span class="term">audience</span></dt><dd>
						<span class="emphasis"><em>OPTIONAL.</em></span> This parameter specifies the target client you want the new token minted for.
					</dd><dt><span class="term">requested_issuer</span></dt><dd>
						<span class="emphasis"><em>OPTIONAL.</em></span> This parameter specifies that the client wants a token minted by an external provider. It must be the alias of an <code class="literal">Identity Provider</code> configured within the realm.
					</dd><dt><span class="term">requested_subject</span></dt><dd>
						<span class="emphasis"><em>OPTIONAL.</em></span> This specifies a username or user id if your client wants to impersonate a different user.
					</dd><dt><span class="term">scope</span></dt><dd>
						<span class="emphasis"><em>NOT IMPLEMENTED.</em></span> This parameter represents the target set of OAuth and OpenID Connect scopes the client is requesting. It is not implemented at this time but will be once Red Hat Single Sign-On has better support for scopes in general.
					</dd></dl></div><div class="admonition note"><div class="admonition_header">Note</div><div><p>
				We currently only support OpenID Connect and OAuth exchanges. Support for SAML based clients and identity providers may be added in the future depending on user demand.
			</p></div></div><p>
			A successful response from an exchange invocation will return the HTTP 200 response code with a content type that depends on the <code class="literal">requested-token-type</code> and <code class="literal">requested_issuer</code> the client asks for. OAuth requested token types will return a JSON document as described in the <a class="link" href="https://tools.ietf.org/html/draft-ietf-oauth-token-exchange-16">OAuth Token Exchange</a> specification.
		</p><pre class="programlisting language-json">{
   "access_token" : ".....",
   "refresh_token" : ".....",
   "expires_in" : "...."
 }</pre><p>
			Clients requesting a refresh token will get back both an access and refresh token in the response. Clients requesting only access token type will only get an access token in the response. Expiration information may or may not be included for clients requesting an external issuer through the <code class="literal">requested_issuer</code> paramater.
		</p><p>
			Error responses generally fall under the 400 HTTP response code category, but other error status codes may be returned depending on the severity of the error. Error responses may include content depending on the <code class="literal">requested_issuer</code>. OAuth based exchanges may return a JSON document as follows:
		</p><pre class="programlisting language-json">{
   "error" : "...."
   "error_description" : "...."
}</pre><p>
			Additional error claims may be returned depending on the exchange type. For example, OAuth Identity Providers may include an additional <code class="literal">account-link-url</code> claim if the user does not have a link to an identity provider. This link can be used for a client initiated link request.
		</p><div class="admonition note"><div class="admonition_header">Note</div><div><p>
				Token exchange setup requires knowledge of fine grain admin permissions (See the <a class="link" href="https://access.redhat.com/documentation/en-us/red_hat_single_sign-on/7.4/html-single/server_administration_guide/">Server Administration Guide</a> for more information). You will need to grant clients permission to exchange. This is discussed more later in this chapter.
			</p></div></div><p>
			The rest of this chapter discusses the setup requirements and provides examples for different exchange scenarios. For simplicity’s sake, let’s call a token minted by the current realm as an <span class="emphasis"><em>internal</em></span> token and a token minted by an external realm or identity provider as an <span class="emphasis"><em>external</em></span> token.
		</p><section class="section" id="internal_token_to_internal_token_exchange"><div class="titlepage"><div><div><h2 class="title">7.1. Internal Token to Internal Token Exchange</h2></div></div></div><p>
				With an internal token to token exchange you have an existing token minted to a specific client and you want to exchange this token for a new one minted for a different target client. Why would you want to do this? This generally happens when a client has a token minted for itself, and needs to make additional requests to other applications that require different claims and permissions within the access token. Other reasons this type of exchange might be required is if you need to perform a "permission downgrade" where your app needs to invoke on a less trusted app and you don’t want to propagate your current access token.
			</p><section class="section" id="client_to_client_permission"><div class="titlepage"><div><div><h3 class="title">7.1.1. Granting Permission for the Exchange</h3></div></div></div><p>
					Clients that want to exchange tokens for a different client need to be authorized in the admin console to do so. You’ll need to define a <code class="literal">token-exchange</code> fine grain permission in the target client you want permission to exchange to.
				</p><div class="formalpara"><p class="title"><strong>Target Client Permission</strong></p><p>
						<span class="inlinemediaobject"><img src="images/rhsso-images/exchange-target-client-permission-unset.png" alt="exchange target client permission unset"/></span>
					</p></div><p>
					Toggle the <code class="literal">Permissions Enabled</code> switch to ON.
				</p><div class="formalpara"><p class="title"><strong>Target Client Permission</strong></p><p>
						<span class="inlinemediaobject"><img src="images/rhsso-images/exchange-target-client-permission-set.png" alt="exchange target client permission set"/></span>
					</p></div><p>
					You should see a <code class="literal">token-exchange</code> link on the page. Click that to start defining the permission. It will bring you to this page.
				</p><div class="formalpara"><p class="title"><strong>Target Client Exchange Permission Setup</strong></p><p>
						<span class="inlinemediaobject"><img src="images/rhsso-images/exchange-target-client-permission-setup.png" alt="exchange target client permission setup"/></span>
					</p></div><p>
					You’ll have to define a policy for this permission. Click the <code class="literal">Authorization</code> link, go to the <code class="literal">Policies</code> tab and create a <code class="literal">Client</code> Policy.
				</p><div class="formalpara"><p class="title"><strong>Client Policy Creation</strong></p><p>
						<span class="inlinemediaobject"><img src="images/rhsso-images/exchange-target-client-policy.png" alt="exchange target client policy"/></span>
					</p></div><p>
					Here you enter in the starting client, that is the authenticated client that is requesting a token exchange. After you create this policy, go back to the target client’s <code class="literal">token-exchange</code> permission and add the client policy you just defined.
				</p><div class="formalpara"><p class="title"><strong>Apply Client Policy</strong></p><p>
						<span class="inlinemediaobject"><img src="images/rhsso-images/exchange-target-client-exchange-apply-policy.png" alt="exchange target client exchange apply policy"/></span>
					</p></div><p>
					Your client now has permission to invoke. If you do not do this correctly, you will get a 403 Forbidden response if you try to make an exchange.
				</p></section><section class="section" id="making_the_request"><div class="titlepage"><div><div><h3 class="title">7.1.2. Making the Request</h3></div></div></div><p>
					When your client is exchanging an existing token for a token targeting another client, you must use the <code class="literal">audience</code> parameter. This parameter must be the client identifier for the target client that you configured in the admin console.
				</p><pre class="programlisting language-bash">curl -X POST \
    -d "client_id=starting-client" \
    -d "client_secret=geheim" \
    --data-urlencode "grant_type=urn:ietf:params:oauth:grant-type:token-exchange" \
    -d "subject_token=...." \
    --data-urlencode "requested_token_type=urn:ietf:params:oauth:token-type:refresh_token" \
    -d "audience=target-client" \
    http://localhost:8080/auth/realms/myrealm/protocol/openid-connect/token</pre><p>
					The <code class="literal">subject_token</code> parameter must be an access token for the target realm. If your <code class="literal">requested_token_type</code> parameter is a refresh token type, then the response will contain both an access token, refresh token, and expiration. Here’s an example JSON response you get back from this call.
				</p><pre class="programlisting language-json">{
   "access_token" : "....",
   "refresh_token" : "....",
   "expires_in" : 3600
}</pre></section></section><section class="section" id="internal_token_to_external_token_exchange"><div class="titlepage"><div><div><h2 class="title">7.2. Internal Token to External Token Exchange</h2></div></div></div><p>
				You can exchange a realm token for an externl token minted by an external identity provider. This external identity provider must be configured within the <code class="literal">Identity Provider</code> section of the admin console. Currently only OAuth/OpenID Connect based external identity providers are supported, this includes all social providers. Red Hat Single Sign-On does not perform a backchannel exchange to the external provider. So if the account is not linked, you will not be able to get the external token. To be able to obtain an external token one of these conditions must be met:
			</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">
						The user must have logged in with the external identity provider at least once
					</li><li class="listitem">
						The user must have linked with the external identity provider through the User Account Service
					</li><li class="listitem">
						The user account was linked through the external identity provider using <a class="link" href="https://access.redhat.com/documentation/en-us/red_hat_single_sign-on/7.4/html-single/server_developer_guide/">Client Initiated Account Linking</a> API.
					</li></ul></div><p>
				Finally, the external identity provider must have been configured to store tokens, or, one of the above actions must have been performed with the same user session as the internal token you are exchanging.
			</p><p>
				If the account is not linked, the exchange response will contain a link you can use to establish it. This is discussed more in the <a class="link" href="#internal_external_making_request" title="7.2.2. Making the Request">Making the Request</a> section.
			</p><section class="section" id="grant_permission_external_exchange"><div class="titlepage"><div><div><h3 class="title">7.2.1. Granting Permission for the Exchange</h3></div></div></div><p>
					Internal to external token exchange requests will be denied with a 403, Forbidden response until you grant permission for the calling client to exchange tokens with the external identity provider. To grant permission to the client you must go to the identity provider’s configuration page to the <code class="literal">Permissions</code> tab.
				</p><div class="formalpara"><p class="title"><strong>Identity Provider Permission</strong></p><p>
						<span class="inlinemediaobject"><img src="images/rhsso-images/exchange-idp-permission-unset.png" alt="exchange idp permission unset"/></span>
					</p></div><p>
					Toggle the <code class="literal">Permissions Enabled</code> switch to true.
				</p><div class="formalpara"><p class="title"><strong>Identity Provider Permission</strong></p><p>
						<span class="inlinemediaobject"><img src="images/rhsso-images/exchange-idp-permission-set.png" alt="exchange idp permission set"/></span>
					</p></div><p>
					You should see a <code class="literal">token-exchange</code> link on the page. Click that to start defining the permission. It will bring you to this page.
				</p><div class="formalpara"><p class="title"><strong>Identity Provider Exchange Permission Setup</strong></p><p>
						<span class="inlinemediaobject"><img src="images/rhsso-images/exchange-idp-permission-setup.png" alt="exchange idp permission setup"/></span>
					</p></div><p>
					You’ll have to define a policy for this permission. Click the <code class="literal">Authorization</code> link, go to the <code class="literal">Policies</code> tab and create a <code class="literal">Client</code> Policy.
				</p><div class="formalpara"><p class="title"><strong>Client Policy Creation</strong></p><p>
						<span class="inlinemediaobject"><img src="images/rhsso-images/exchange-idp-client-policy.png" alt="exchange idp client policy"/></span>
					</p></div><p>
					Here you enter in the starting client, that is the authenticated client that is requesting a token exchange. After you create this policy, go back to the identity providers’s <code class="literal">token-exchange</code> permission and add the client policy you just defined.
				</p><div class="formalpara"><p class="title"><strong>Apply Client Policy</strong></p><p>
						<span class="inlinemediaobject"><img src="images/rhsso-images/exchange-idp-apply-policy.png" alt="exchange idp apply policy"/></span>
					</p></div><p>
					Your client now has permission to invoke. If you do not do this correctly, you will get a 403 Forbidden response if you try to make an exchange.
				</p></section><section class="section" id="internal_external_making_request"><div class="titlepage"><div><div><h3 class="title">7.2.2. Making the Request</h3></div></div></div><p>
					When your client is exchanging an existing internal token to an external one, you must provide the <code class="literal">requested_issuer</code> parameter. The parameter must be the alias of a configured identity provider.
				</p><pre class="programlisting language-bash">curl -X POST \
    -d "client_id=starting-client" \
    -d "client_secret=geheim" \
    --data-urlencode "grant_type=urn:ietf:params:oauth:grant-type:token-exchange" \
    -d "subject_token=...." \
    --data-urlencode "requested_token_type=urn:ietf:params:oauth:token-type:access_token" \
    -d "requested_issuer=google" \
    http://localhost:8080/auth/realms/myrealm/protocol/openid-connect/token</pre><p>
					The <code class="literal">subject_token</code> parameter must be an access token for the target realm. The <code class="literal">requested_token_type</code> parameter must be <code class="literal">urn:ietf:params:oauth:token-type:access_token</code> or left blank. No other requested token type is supported at this time. Here’s an example successful JSON response you get back from this call.
				</p><pre class="programlisting language-json">{
   "access_token" : "....",
   "expires_in" : 3600
   "account-link-url" : "https://...."
}</pre><p>
					If the external identity provider is not linked for whatever reason, you will get an HTTP 400 response code with this JSON document:
				</p><pre class="programlisting language-json">{
   "error" : "....",
   "error_description" : "..."
   "account-link-url" : "https://...."
}</pre><p>
					The <code class="literal">error</code> claim will be either <code class="literal">token_expired</code> or <code class="literal">not_linked</code>. The <code class="literal">account-link-url</code> claim is provided so that the client can perform <a class="link" href="https://access.redhat.com/documentation/en-us/red_hat_single_sign-on/7.4/html-single/server_developer_guide/">Client Initiated Account Linking</a>. Most (all?) providers are requiring linking through browser OAuth protocol. With the <code class="literal">account-link-url</code> just add a <code class="literal">redirect_uri</code> query parameter to it and you can forward browsers to perform the link.
				</p></section></section><section class="section" id="external_token_to_internal_token_exchange"><div class="titlepage"><div><div><h2 class="title">7.3. External Token to Internal Token Exchange</h2></div></div></div><p>
				You can trust and exchange external tokens minted by external identity providers for internal tokens. This can be used to bridge between realms or just to trust tokens from your social provider. It works similarly to an identity provider browser login in that a new user is imported into your realm if it doesn’t exist.
			</p><div class="admonition note"><div class="admonition_header">Note</div><div><p>
					The current limitation on external token exchanges is that if the external token maps to an existing user an exchange will not be allowed unless the existing user already has an account link to the external identity provider.
				</p></div></div><p>
				When the exchange is complete, a user session will be created within the realm, and you will receive an access and or refresh token depending on the <code class="literal">requested_token_type</code> parameter value. You should note that this new user session will remain active until it times out or until you call the logout endpoint of the realm passing this new access token.
			</p><p>
				These types of changes required a configured identity provider in the admin console.
			</p><div class="admonition note"><div class="admonition_header">Note</div><div><p>
					SAML identity providers are not supported at this time. Twitter tokens cannot be exchanged either.
				</p></div></div><section class="section" id="granting_permission_for_the_exchange"><div class="titlepage"><div><div><h3 class="title">7.3.1. Granting Permission for the Exchange</h3></div></div></div><p>
					Before external token exchanges can be done, you must grant permission for the calling client to make the exchange. This permission is granted in the same manner as <a class="link" href="#grant_permission_external_exchange" title="7.2.1. Granting Permission for the Exchange">internal to external permission is granted</a>.
				</p><p>
					If you also provide an <code class="literal">audience</code> parameter whose value points to a different client other than the calling one, you must also grant the calling client permission to exchange to the target client specific in the <code class="literal">audience</code> parameter. How to do this is <a class="link" href="#client_to_client_permission" title="7.1.1. Granting Permission for the Exchange">discussed earlier</a> in this section.
				</p></section><section class="section" id="making_the_request_2"><div class="titlepage"><div><div><h3 class="title">7.3.2. Making the Request</h3></div></div></div><p>
					The <code class="literal">subject_token_type</code> must either be <code class="literal">urn:ietf:params:oauth:token-type:access_token</code> or <code class="literal">urn:ietf:params:oauth:token-type:jwt</code>. If the type is <code class="literal">urn:ietf:params:oauth:token-type:access_token</code> you must specify the <code class="literal">subject_issuer</code> parameter and it must be the alias of the configured identity provider. If the type is <code class="literal">urn:ietf:params:oauth:token-type:jwt</code>, the provider will be matched via the <code class="literal">issuer</code> claim within the JWT which must be the alias of the provider, or a registered issuer within the providers configuration.
				</p><p>
					For validation, if the token is an access token, the provider’s user info service will be invoked to validate the token. A successful call will mean that the access token is valid. If the subject token is a JWT and if the provider has signature validation enabled, that will be attempted, otherwise, it will default to also invoking on the user info service to validate the token.
				</p><p>
					By default, the internal token minted will use the calling client to determine what’s in the token using the protocol mappers defined for the calling client. Alternatively, you can specify a different target client using the <code class="literal">audience</code> parameter.
				</p><pre class="programlisting language-bash">curl -X POST \
    -d "client_id=starting-client" \
    -d "client_secret=geheim" \
    --data-urlencode "grant_type=urn:ietf:params:oauth:grant-type:token-exchange" \
    -d "subject_token=...." \
    -d "subject_issuer=myOidcProvider" \
    --data-urlencode "subject_token_type=urn:ietf:params:oauth:token-type:access_token" \
    -d "audience=target-client" \
    http://localhost:8080/auth/realms/myrealm/protocol/openid-connect/token</pre><p>
					If your <code class="literal">requested_token_type</code> parameter is a refresh token type, then the response will contain both an access token, refresh token, and expiration. Here’s an example JSON response you get back from this call.
				</p><pre class="programlisting language-json">{
   "access_token" : "....",
   "refresh_token" : "....",
   "expires_in" : 3600
}</pre></section></section><section class="section" id="impersonation"><div class="titlepage"><div><div><h2 class="title">7.4. Impersonation</h2></div></div></div><p>
				For internal and external token exchanges, the client can request on behalf of a user to impersonate a different user. For example, you may have an admin application that needs to impersonate a user so that a support engineer can debug a problem.
			</p><section class="section" id="granting_permission_for_the_exchange_2"><div class="titlepage"><div><div><h3 class="title">7.4.1. Granting Permission for the Exchange</h3></div></div></div><p>
					The user that the subject token represents must have permission to impersonate other users. See the <a class="link" href="https://access.redhat.com/documentation/en-us/red_hat_single_sign-on/7.4/html-single/server_administration_guide/">Server Administration Guide</a> on how to enable this permission. It can be done through a role or through fine grain admin permissions.
				</p></section><section class="section" id="making_the_request_3"><div class="titlepage"><div><div><h3 class="title">7.4.2. Making the Request</h3></div></div></div><p>
					Make the request as described in other chapters except additionally specify the <code class="literal">requested_subject</code> parameter. The value of this parameter must be a username or user id.
				</p><pre class="programlisting language-bash">curl -X POST \
    -d "client_id=starting-client" \
    -d "client_secret=geheim" \
    --data-urlencode "grant_type=urn:ietf:params:oauth:grant-type:token-exchange" \
    -d "subject_token=...." \
    --data-urlencode "requested_token_type=urn:ietf:params:oauth:token-type:access_token" \
    -d "audience=target-client" \
    -d "requested_subject=wburke" \
    http://localhost:8080/auth/realms/myrealm/protocol/openid-connect/token</pre></section></section><section class="section" id="direct_naked_impersonation"><div class="titlepage"><div><div><h2 class="title">7.5. Direct Naked Impersonation</h2></div></div></div><p>
				You can make an internal token exchange request without providing a <code class="literal">subject_token</code>. This is called a direct naked impersonation because it places a lot of trust in a client as that client can impersonate any user in the realm. You might need this to bridge for applications where it is impossible to obtain a subject token to exchange. For example, you may be integrating a legacy application that performs login directly with LDAP. In that case, the legacy app is able to authenticate users itself, but not able to obtain a token.
			</p><div class="admonition warning"><div class="admonition_header">Warning</div><div><p>
					It is very risky to enable direct naked impersonation for a client. If the client’s credentials are ever stolen, that client can impersonate any user in the system.
				</p></div></div><section class="section" id="granting_permission_for_the_exchange_3"><div class="titlepage"><div><div><h3 class="title">7.5.1. Granting Permission for the Exchange</h3></div></div></div><p>
					If the <code class="literal">audience</code> parameter is provided, then the calling client must have permission to exchange to the client. How to set this up is discussed earlier in this chapter.
				</p><p>
					Additionally, the calling client must be granted permission to impersonate users. In the admin console, go to the <code class="literal">Users</code> screen and click on the <code class="literal">Permissions</code> tab.
				</p><div class="formalpara"><p class="title"><strong>Users Permission</strong></p><p>
						<span class="inlinemediaobject"><img src="images/rhsso-images/exchange-users-permission-unset.png" alt="exchange users permission unset"/></span>
					</p></div><p>
					Toggle the <code class="literal">Permissions Enabled</code> switch to true.
				</p><div class="formalpara"><p class="title"><strong>Identity Provider Permission</strong></p><p>
						<span class="inlinemediaobject"><img src="images/rhsso-images/exchange-users-permission-set.png" alt="exchange users permission set"/></span>
					</p></div><p>
					You should see a <code class="literal">impersonation</code> link on the page. Click that to start defining the permission. It will bring you to this page.
				</p><div class="formalpara"><p class="title"><strong>Users Impersonation Permission Setup</strong></p><p>
						<span class="inlinemediaobject"><img src="images/rhsso-images/exchange-users-permission-setup.png" alt="exchange users permission setup"/></span>
					</p></div><p>
					You’ll have to define a policy for this permission. Click the <code class="literal">Authorization</code> link, go to the <code class="literal">Policies</code> tab and create a <code class="literal">Client</code> Policy.
				</p><div class="formalpara"><p class="title"><strong>Client Policy Creation</strong></p><p>
						<span class="inlinemediaobject"><img src="images/rhsso-images/exchange-users-client-policy.png" alt="exchange users client policy"/></span>
					</p></div><p>
					Here you enter in the starting client, that is the authenticated client that is requesting a token exchange. After you create this policy, go back to the users' <code class="literal">impersonation</code> permission and add the client policy you just defined.
				</p><div class="formalpara"><p class="title"><strong>Apply Client Policy</strong></p><p>
						<span class="inlinemediaobject"><img src="images/rhsso-images/exchange-users-apply-policy.png" alt="exchange users apply policy"/></span>
					</p></div><p>
					Your client now has permission to impersonate users. If you do not do this correctly, you will get a 403 Forbidden response if you try to make this type of exchange.
				</p><div class="admonition note"><div class="admonition_header">Note</div><div><p>
						Public clients are not allowed to do direct naked impersonations.
					</p></div></div></section><section class="section" id="making_the_request_4"><div class="titlepage"><div><div><h3 class="title">7.5.2. Making the Request</h3></div></div></div><p>
					To make the request, simply specify the <code class="literal">requested_subject</code> parameter. This must be the username or user id of a valid user. You can also specify an <code class="literal">audience</code> parameter if you wish.
				</p><pre class="programlisting language-bash">curl -X POST \
    -d "client_id=starting-client" \
    -d "client_secret=geheim" \
    --data-urlencode "grant_type=urn:ietf:params:oauth:grant-type:token-exchange" \
    -d "requested_subject=wburke" \
    http://localhost:8080/auth/realms/myrealm/protocol/openid-connect/token</pre></section></section><section class="section" id="expand_permission_model_with_service_accounts"><div class="titlepage"><div><div><h2 class="title">7.6. Expand Permission Model With Service Accounts</h2></div></div></div><p>
				When granting clients permission to exchange, you don’t necessarily have to manually enable those permissions for each and every client. If the client has a service account associated with it, you can use a role to group permissions together and assign exchange permissions by assigning a role to the client’s service account. For example, you might define a <code class="literal">naked-exchange</code> role and any service account that has that role can do a naked exchange.
			</p></section><section class="section" id="exchange_vulnerabilities"><div class="titlepage"><div><div><h2 class="title">7.7. Exchange Vulnerabilities</h2></div></div></div><p>
				When you start allowing token exchanges, there’s various things you have to both be aware of and careful of.
			</p><p>
				The first is public clients. Public clients do not have or require a client credential in order to perform an exchange. Anybody that has a valid token will be able to <span class="emphasis"><em>impersonate</em></span> the public client and perform the exchanges that public client is allowed to perform. If there are any untrustworthy clients that are managed by your realm, public clients may open up vulnerabilities in your permission models. This is why direct naked exchanges do not allow public clients and will abort with an error if the calling client is public.
			</p><p>
				It is possible to exchange social tokens provided by Facebook, Google, etc. for a realm token. Be careful and vigilante on what the exchange token is allowed to do as its not hard to create fake accounts on these social websites. Use default roles, groups, and identity provider mappers to control what attributes and roles are assigned to the external social user.
			</p><p>
				Direct naked exchanges are quite dangerous. You are putting a lot of trust in the calling client that it will never leak out its client credentials. If those credentials are leaked, then the thief can impersonate anybody in your system. This is in direct contrast to confidential clients that have existing tokens. You have two factors of authentication, the access token and the client credentials, and you’re only dealing with one user. So use direct naked exchanges sparingly.
			</p></section></section><div><div xml:lang="en-US" class="legalnotice" id="idm140066873301568"><h1 class="legalnotice">Legal Notice</h1><div class="para">
				Copyright <span class="trademark"/>© 2019 Red Hat, Inc.
			</div><div class="para">
				Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with the License. You may obtain a copy of the License at
			</div><div class="para">
				<a class="ulink" href="http://www.apache.org/licenses/LICENSE-2.0"> http://www.apache.org/licenses/LICENSE-2.0</a>
			</div><div class="para">
				Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.
			</div></div></div></div></div></div><script type="text/javascript">
                        jQuery(document).ready(function() {
                            initSwitchery();
                            jQuery('pre[class*="language-"]').each(function(i, block){hljs.highlightBlock(block);});
                        });
                    </script></body></html>