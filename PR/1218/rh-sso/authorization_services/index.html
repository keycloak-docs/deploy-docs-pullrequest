<?xml version='1.0' encoding='UTF-8'?>
<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" class="chrometwo"><head><title>Authorization Services Guide</title><link rel="stylesheet" type="text/css" href="Common_Content/css/default.css"/><meta name="generator" content="publican v4.3.4"/><meta name="description" content="This guide consists of information for authorization services for Red Hat Single Sign-On 7.4"/><link rel="next" href="#making-open-source-more-inclusive" title="Making open source more inclusive"/><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/><script type="text/javascript" src="Common_Content/scripts/jquery-1.7.1.min.js"> </script><script type="text/javascript" src="Common_Content/scripts/utils.js"> </script><script type="text/javascript" src="Common_Content/scripts/highlight.js/highlight.pack.js"> </script></head><body><div id="chrometwo"><div id="main"><div xml:lang="en-US" class="book" id="idm139768737665872"><div class="titlepage"><div><div class="producttitle"><span class="productname">Red Hat Single Sign-On</span> <span class="productnumber">7.4</span></div><div><h1 class="title">Authorization Services Guide</h1></div><div><h2 class="subtitle">For Use with Red Hat Single Sign-On 7.4</h2></div><div><div xml:lang="en-US" class="authorgroup"><span class="orgname">Red Hat Customer Content Services</span></div></div><div><a href="#idm139768737258128">Legal Notice</a></div><div><div class="abstract"><p class="title"><strong>Abstract</strong></p><div class="para">
				This guide consists of information for authorization services for Red Hat Single Sign-On 7.4
			</div></div></div></div><hr/></div><div class="toc"><ul class="toc"><li><span class="preface"><a href="#making-open-source-more-inclusive">Making open source more inclusive</a></span></li><li><span class="chapter"><a href="#overview">1. Authorization services overview</a></span><ul><li><span class="section"><a href="#overview_architecture">1.1. Architecture</a></span><ul><li><span class="section"><a href="#the_authorization_process">1.1.1. The authorization process</a></span></li><li><span class="section"><a href="#authorization_services">1.1.2. Authorization services</a></span></li></ul></li><li><span class="section"><a href="#overview_terminology">1.2. Terminology</a></span><ul><li><span class="section"><a href="#overview_terminology_resource_server">1.2.1. Resource Server</a></span></li><li><span class="section"><a href="#resource">1.2.2. Resource</a></span></li><li><span class="section"><a href="#scope">1.2.3. Scope</a></span></li><li><span class="section"><a href="#permission">1.2.4. Permission</a></span></li><li><span class="section"><a href="#policy">1.2.5. Policy</a></span></li><li><span class="section"><a href="#policy_provider">1.2.6. Policy provider</a></span></li><li><span class="section"><a href="#overview_terminology_permission_ticket">1.2.7. Permission ticket</a></span></li></ul></li></ul></li><li><span class="chapter"><a href="#getting_started_overview">2. Getting started</a></span><ul><li><span class="section"><a href="#getting_started_hello_world_overview">2.1. Securing a servlet application</a></span></li><li><span class="section"><a href="#getting_started_hello_world_create_realm">2.2. Creating a realm and a user</a></span></li><li><span class="section"><a href="#getting_started_hello_world_enabling_authz_services">2.3. Enabling authorization services</a></span></li><li><span class="section"><a href="#getting_started_hello_world_deploy">2.4. Build, deploy, and test your application</a></span><ul><li><span class="section"><a href="#obtaining_the_adapter_configuration">2.4.1. Obtaining the adapter configuration</a></span></li><li><span class="section"><a href="#building_and_deploying_the_application">2.4.2. Building and deploying the application</a></span></li><li><span class="section"><a href="#testing_the_application">2.4.3. Testing the application</a></span></li><li><span class="section"><a href="#next_steps">2.4.4. Next steps</a></span></li></ul></li><li><span class="section"><a href="#authorization_quickstarts">2.5. Authorization quickstarts</a></span></li></ul></li><li><span class="chapter"><a href="#resource_server_overview">3. Managing resource servers</a></span><ul><li><span class="section"><a href="#resource_server_create_client">3.1. Creating a client application</a></span></li><li><span class="section"><a href="#resource_server_enable_authorization">3.2. Enabling authorization services</a></span><ul><li><span class="section"><a href="#resource_server_settings">3.2.1. Resource server settings</a></span></li></ul></li><li><span class="section"><a href="#resource_server_default_config">3.3. Default Configuration</a></span><ul><li><span class="section"><a href="#changing_the_default_configuration">3.3.1. Changing the default configuration</a></span></li></ul></li><li><span class="section"><a href="#resource_server_import_config">3.4. Export and import authorization configuration</a></span><ul><li><span class="section"><a href="#exporting_a_configuration_file">3.4.1. Exporting a configuration file</a></span></li><li><span class="section"><a href="#importing_a_configuration_file">3.4.2. Importing a configuration file</a></span></li></ul></li></ul></li><li><span class="chapter"><a href="#resource_overview">4. Managing resources and scopes</a></span><ul><li><span class="section"><a href="#resource_view">4.1. Viewing resources</a></span></li><li><span class="section"><a href="#resource_create">4.2. Creating resources</a></span><ul><li><span class="section"><a href="#resource_attributes">4.2.1. Resource attributes</a></span></li><li><span class="section"><a href="#typed_resources">4.2.2. Typed resources</a></span></li><li><span class="section"><a href="#resource_owners">4.2.3. Resource owners</a></span></li><li><span class="section"><a href="#managing_resources_remotely">4.2.4. Managing resources remotely</a></span></li></ul></li></ul></li><li><span class="chapter"><a href="#policy_overview">5. Managing policies</a></span><ul><li><span class="section"><a href="#policy_user">5.1. User-based policy</a></span><ul><li><span class="section"><a href="#configuration">5.1.1. Configuration</a></span></li></ul></li><li><span class="section"><a href="#policy_rbac">5.2. Role-based policy</a></span><ul><li><span class="section"><a href="#configuration_2">5.2.1. Configuration</a></span></li><li><span class="section"><a href="#policy_rbac_required">5.2.2. Defining a role as required</a></span></li></ul></li><li><span class="section"><a href="#policy_js">5.3. JavaScript-based policy</a></span><ul><li><span class="section"><a href="#configuration_3">5.3.1. Configuration</a></span></li><li><span class="section"><a href="#creating_a_js_policy_from_a_deployed_jar_file">5.3.2. Creating a JS policy from a deployed JAR file</a></span></li><li><span class="section"><a href="#examples">5.3.3. Examples</a></span></li></ul></li><li><span class="section"><a href="#policy_time">5.4. Time-based policy</a></span><ul><li><span class="section"><a href="#configuration_4">5.4.1. Configuration</a></span></li></ul></li><li><span class="section"><a href="#policy_aggregated">5.5. Aggregated policy</a></span><ul><li><span class="section"><a href="#configuration_5">5.5.1. Configuration</a></span></li><li><span class="section"><a href="#decision_strategy_for_aggregated_policies">5.5.2. Decision strategy for aggregated policies</a></span></li></ul></li><li><span class="section"><a href="#policy_client">5.6. Client-based policy</a></span><ul><li><span class="section"><a href="#configuration_6">5.6.1. Configuration</a></span></li></ul></li><li><span class="section"><a href="#policy_group">5.7. Group-based policy</a></span><ul><li><span class="section"><a href="#configuration_7">5.7.1. Configuration</a></span></li><li><span class="section"><a href="#policy_group_extend_access_children">5.7.2. Extending access to child groups</a></span></li></ul></li><li><span class="section"><a href="#policy_client_scope">5.8. Client scope-based policy</a></span><ul><li><span class="section"><a href="#configuration_8">5.8.1. Configuration</a></span></li><li><span class="section"><a href="#policy_client_scope_required">5.8.2. Defining a client scope as required</a></span></li></ul></li><li><span class="section"><a href="#policy_logic">5.9. Positive and negative logic</a></span></li><li><span class="section"><a href="#policy_evaluation_api">5.10. Policy evaluation API</a></span><ul><li><span class="section"><a href="#the_evaluation_context">5.10.1. The evaluation context</a></span></li></ul></li></ul></li><li><span class="chapter"><a href="#permission_overview">6. Managing permissions</a></span><ul><li><span class="section"><a href="#permission_create_resource">6.1. Creating resource-based permission</a></span><ul><li><span class="section"><a href="#configuration_9">6.1.1. Configuration</a></span></li><li><span class="section"><a href="#permission_typed_resource">6.1.2. Typed resource permission</a></span></li></ul></li><li><span class="section"><a href="#permission_create_scope">6.2. Creating scope-based permissions</a></span><ul><li><span class="section"><a href="#configuration_10">6.2.1. Configuration</a></span></li></ul></li><li><span class="section"><a href="#permission_decision_strategies">6.3. Policy decision strategies</a></span></li></ul></li><li><span class="chapter"><a href="#policy_evaluation_overview">7. Evaluating and testing policies</a></span><ul><li><span class="section"><a href="#providing_identity_information">7.1. Providing identity information</a></span></li><li><span class="section"><a href="#providing_contextual_information">7.2. Providing contextual information</a></span></li><li><span class="section"><a href="#providing_the_permissions">7.3. Providing the permissions</a></span></li></ul></li><li><span class="chapter"><a href="#service_overview">8. Authorization services</a></span><ul><li><span class="section"><a href="#service_authorization_api">8.1. Discovering authorization services endpoints and metadata</a></span></li><li><span class="section"><a href="#service_obtaining_permissions">8.2. Obtaining permissions</a></span><ul><li><span class="section"><a href="#authentication_methods">8.2.1. Client authentication methods</a></span></li><li><span class="section"><a href="#service_pushing_claims">8.2.2. Pushing claims</a></span></li></ul></li><li><span class="section"><a href="#service_user_managed_access">8.3. User-managed access</a></span><ul><li><span class="section"><a href="#service_uma_authorization_process">8.3.1. Authorization process</a></span></li><li><span class="section"><a href="#service_authorization_aat">8.3.2. Submitting permission requests</a></span></li><li><span class="section"><a href="#service_authorization_my_resources">8.3.3. Managing access to users resources</a></span></li></ul></li><li><span class="section"><a href="#service_protection_api">8.4. Protection API</a></span><ul><li><span class="section"><a href="#service_protection_whatis_obtain_pat">8.4.1. What is a PAT and how to obtain it</a></span></li><li><span class="section"><a href="#service_protection_resources_api">8.4.2. Managing resources</a></span></li><li><span class="section"><a href="#service_protection_permission_api_papi">8.4.3. Managing permission requests</a></span></li><li><span class="section"><a href="#service_authorization_uma_policy_api">8.4.4. Managing resource permissions using the Policy API</a></span></li></ul></li><li><span class="section"><a href="#service_rpt_overview">8.5. Requesting party token</a></span><ul><li><span class="section"><a href="#service_protection_token_introspection">8.5.1. Introspecting a requesting party token</a></span></li><li><span class="section"><a href="#obtaining_information_about_an_rpt">8.5.2. Obtaining Information about an RPT</a></span></li><li><span class="section"><a href="#do_i_need_to_invoke_the_server_every_time_i_want_to_introspect_an_rpt">8.5.3. Do I need to invoke the server every time I want to introspect an RPT?</a></span></li></ul></li><li><span class="section"><a href="#service_client_api">8.6. Authorization client java API</a></span><ul><li><span class="section"><a href="#maven_dependency">8.6.1. Maven dependency</a></span></li><li><span class="section"><a href="#configuration_11">8.6.2. Configuration</a></span></li><li><span class="section"><a href="#creating_the_authorization_client">8.6.3. Creating the authorization client</a></span></li><li><span class="section"><a href="#obtaining_user_entitlements">8.6.4. Obtaining user entitlements</a></span></li><li><span class="section"><a href="#creating_a_resource_using_the_protection_api">8.6.5. Creating a resource using the protection API</a></span></li><li><span class="section"><a href="#introspecting_an_rpt">8.6.6. Introspecting an RPT</a></span></li></ul></li></ul></li><li><span class="chapter"><a href="#enforcer_overview">9. Policy enforcers</a></span><ul><li><span class="section"><a href="#enforcer_filter">9.1. Configuration</a></span></li><li><span class="section"><a href="#enforcer_claim_information_point">9.2. Claim Information Point</a></span><ul><li><span class="section"><a href="#obtaining_information_from_the_http_request">9.2.1. Obtaining information from the HTTP request</a></span></li><li><span class="section"><a href="#obtaining_information_from_an_external_http_service">9.2.2. Obtaining information from an external HTTP service</a></span></li><li><span class="section"><a href="#static_claims">9.2.3. Static claims</a></span></li><li><span class="section"><a href="#claim_information_provider_spi">9.2.4. Claim information provider SPI</a></span></li></ul></li><li><span class="section"><a href="#enforcer_authorization_context">9.3. Obtaining the authorization context</a></span></li><li><span class="section"><a href="#using_the_authorizationcontext_to_obtain_an_authorization_client_instance">9.4. Using the AuthorizationContext to obtain an Authorization Client Instance</a></span></li><li><span class="section"><a href="#enforcer_js_adapter">9.5. JavaScript integration</a></span><ul><li><span class="section"><a href="#handling_authorization_responses_from_a_uma_protected_resource_server">9.5.1. Handling authorization responses from a UMA-Protected resource server</a></span></li><li><span class="section"><a href="#obtaining_entitlements">9.5.2. Obtaining entitlements</a></span></li><li><span class="section"><a href="#authorization_request">9.5.3. Authorization request</a></span></li><li><span class="section"><a href="#obtaining_the_rpt">9.5.4. Obtaining the RPT</a></span></li></ul></li><li><span class="section"><a href="#enforcer_filter_using_https">9.6. Configuring TLS/HTTPS</a></span></li></ul></li></ul></div><section class="preface" id="making-open-source-more-inclusive"><div class="titlepage"><div><div><h1 class="title">Making open source more inclusive</h1></div></div></div><p>
			Red Hat is committed to replacing problematic language in our code, documentation, and web properties. We are beginning with these four terms: master, slave, blacklist, and whitelist. Because of the enormity of this endeavor, these changes will be implemented gradually over several upcoming releases. For more details, see <a class="link" href="https://www.redhat.com/en/blog/making-open-source-more-inclusive-eradicating-problematic-language">our CTO Chris Wright’s message</a>.
		</p></section><section class="chapter" id="overview"><div class="titlepage"><div><div><h1 class="title">Chapter 1. Authorization services overview</h1></div></div></div><p>
			Red Hat Single Sign-On supports fine-grained authorization policies and is able to combine different access control mechanisms such as:
		</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">
					<span class="strong strong"><strong>Attribute-based access control (ABAC)</strong></span>
				</li><li class="listitem">
					<span class="strong strong"><strong>Role-based access control (RBAC)</strong></span>
				</li><li class="listitem">
					<span class="strong strong"><strong>User-based access control (UBAC)</strong></span>
				</li><li class="listitem">
					<span class="strong strong"><strong>Context-based access control (CBAC)</strong></span>
				</li><li class="listitem"><p class="simpara">
					<span class="strong strong"><strong>Rule-based access control</strong></span>
				</p><div class="itemizedlist"><ul class="itemizedlist" type="circle"><li class="listitem">
							Using JavaScript
						</li></ul></div></li><li class="listitem">
					<span class="strong strong"><strong>Time-based access control</strong></span>
				</li><li class="listitem">
					<span class="strong strong"><strong>Support for custom access control mechanisms (ACMs) through a Policy Provider Service Provider Interface (SPI)</strong></span>
				</li></ul></div><p>
			Red Hat Single Sign-On is based on a set of administrative UIs and a RESTful API, and provides the necessary means to create permissions for your protected resources and scopes, associate those permissions with authorization policies, and enforce authorization decisions in your applications and services.
		</p><p>
			Resource servers (applications or services serving protected resources) usually rely on some kind of information to decide if access should be granted to a protected resource. For RESTful-based resource servers, that information is usually obtained from a security token, usually sent as a bearer token on every request to the server. For web applications that rely on a session to authenticate users, that information is usually stored in a user’s session and retrieved from there for each request.
		</p><p>
			Frequently, resource servers only perform authorization decisions based on role-based access control (RBAC), where the roles granted to the user trying to access protected resources are checked against the roles mapped to these same resources. While roles are very useful and used by applications, they also have a few limitations:
		</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">
					Resources and roles are tightly coupled and changes to roles (such as adding, removing, or changing an access context) can impact multiple resources
				</li><li class="listitem">
					Changes to your security requirements can imply deep changes to application code to reflect these changes
				</li><li class="listitem">
					Depending on your application size, role management might become difficult and error-prone
				</li><li class="listitem">
					It is not the most flexible access control mechanism. Roles do not represent who you are and lack contextual information. If you have been granted a role, you have at least some access.
				</li></ul></div><p>
			Considering that today we need to consider heterogeneous environments where users are distributed across different regions, with different local policies, using different devices, and with a high demand for information sharing, Red Hat Single Sign-On Authorization Services can help you improve the authorization capabilities of your applications and services by providing:
		</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">
					Resource protection using fine-grained authorization policies and different access control mechanisms
				</li><li class="listitem">
					Centralized Resource, Permission, and Policy Management
				</li><li class="listitem">
					Centralized Policy Decision Point
				</li><li class="listitem">
					REST security based on a set of REST-based authorization services
				</li><li class="listitem">
					Authorization workflows and User-Managed Access
				</li><li class="listitem">
					The infrastructure to help avoid code replication across projects (and redeploys) and quickly adapt to changes in your security requirements.
				</li></ul></div><section class="section" id="overview_architecture"><div class="titlepage"><div><div><h2 class="title">1.1. Architecture</h2></div></div></div><p>
				<span class="inlinemediaobject"><img src="images/authz-arch-overview.png" alt="Red Hat Single Sign-On AuthZ Architecture Overview"/></span>
			</p><p>
				From a design perspective, Authorization Services is based on a well-defined set of authorization patterns providing these capabilities:
			</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p class="simpara">
						<span class="strong strong"><strong>Policy Administration Point (PAP)</strong></span>
					</p><p class="simpara">
						Provides a set of UIs based on the Red Hat Single Sign-On Administration Console to manage resource servers, resources, scopes, permissions, and policies. Part of this is also accomplished remotely through the use of the <a class="link" href="#service_protection_api" title="8.4. Protection API">Protection API</a>.
					</p></li><li class="listitem"><p class="simpara">
						<span class="strong strong"><strong>Policy Decision Point (PDP)</strong></span>
					</p><p class="simpara">
						Provides a distributable policy decision point to where authorization requests are sent and policies are evaluated accordingly with the permissions being requested. For more information, see <a class="link" href="#service_obtaining_permissions" title="8.2. Obtaining permissions">Obtaining Permissions</a>.
					</p></li><li class="listitem"><p class="simpara">
						<span class="strong strong"><strong>Policy Enforcement Point (PEP)</strong></span>
					</p><p class="simpara">
						Provides implementations for different environments to actually enforce authorization decisions at the resource server side. Red Hat Single Sign-On provides some built-in <a class="link" href="#enforcer_overview" title="Chapter 9. Policy enforcers">Policy Enforcers</a>.
					</p></li><li class="listitem"><p class="simpara">
						<span class="strong strong"><strong>Policy Information Point (PIP)</strong></span>
					</p><p class="simpara">
						Being based on Red Hat Single Sign-On Authentication Server, you can obtain attributes from identities and runtime environment during the evaluation of authorization policies.
					</p></li></ul></div><section class="section" id="the_authorization_process"><div class="titlepage"><div><div><h3 class="title">1.1.1. The authorization process</h3></div></div></div><p>
					Three main processes define the necessary steps to understand how to use Red Hat Single Sign-On to enable fine-grained authorization to your applications:
				</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">
							<span class="strong strong"><strong>Resource Management</strong></span>
						</li><li class="listitem">
							<span class="strong strong"><strong>Permission and Policy Management</strong></span>
						</li><li class="listitem">
							<span class="strong strong"><strong>Policy Enforcement</strong></span>
						</li></ul></div><section class="section" id="resource_management"><div class="titlepage"><div><div><h4 class="title">1.1.1.1. Resource management</h4></div></div></div><p>
						<span class="strong strong"><strong>Resource Management</strong></span> involves all the necessary steps to define what is being protected.
					</p><p>
						<span class="inlinemediaobject"><img src="images/resource-mgmt-process.png" alt="Resource Management Overview"/></span>
					</p><p>
						First, you need to specify Red Hat Single Sign-On what are you looking to protect, which usually represents a web application or a set of one or more services. For more information on resource servers see <a class="link" href="#overview_terminology" title="1.2. Terminology">Terminology</a>.
					</p><p>
						Resource servers are managed using the Red Hat Single Sign-On Administration Console. There you can enable any registered client application as a resource server and start managing the resources and scopes you want to protect.
					</p><p>
						<span class="inlinemediaobject"><img src="images/rs-r-scopes.png" alt="Resource Server Overview"/></span>
					</p><p>
						A resource can be a web page, a RESTFul resource, a file in your file system, an EJB, and so on. They can represent a group of resources (just like a Class in Java) or they can represent a single and specific resource.
					</p><p>
						For instance, you might have a <span class="emphasis"><em>Bank Account</em></span> resource that represents all banking accounts and use it to define the authorization policies that are common to all banking accounts. However, you might want to define specific policies for <span class="emphasis"><em>Alice Account</em></span> (a resource instance that belongs to a customer), where only the owner is allowed to access some information or perform an operation.
					</p><p>
						Resources can be managed using the Red Hat Single Sign-On Administration Console or the <a class="link" href="#service_protection_api" title="8.4. Protection API">Protection API</a>. In the latter case, resource servers are able to manage their resources remotely.
					</p><p>
						Scopes usually represent the actions that can be performed on a resource, but they are not limited to that. You can also use scopes to represent one or more attributes within a resource.
					</p></section><section class="section" id="permission_and_policy_management"><div class="titlepage"><div><div><h4 class="title">1.1.1.2. Permission and policy management</h4></div></div></div><p>
						Once you have defined your resource server and all the resources you want to protect, you must set up permissions and policies.
					</p><p>
						This process involves all the necessary steps to actually define the security and access requirements that govern your resources.
					</p><p>
						<span class="inlinemediaobject"><img src="images/policy-mgmt-process.png" alt="Permission and Policy Management Overview"/></span>
					</p><p>
						Policies define the conditions that must be satisfied to access or perform operations on something (resource or scope), but they are not tied to what they are protecting. They are generic and can be reused to build permissions or even more complex policies.
					</p><p>
						For instance, to allow access to a group of resources only for users granted with a role "User Premium", you can use RBAC (Role-based Access Control).
					</p><p>
						Red Hat Single Sign-On provides a few built-in policy types (and their respective policy providers) covering the most common access control mechanisms. You can even create policies based on rules written using JavaScript.
					</p><p>
						Once you have your policies defined, you can start defining your permissions. Permissions are coupled with the resource they are protecting. Here you specify what you want to protect (resource or scope) and the policies that must be satisfied to grant or deny permission.
					</p></section><section class="section" id="policy_enforcement"><div class="titlepage"><div><div><h4 class="title">1.1.1.3. Policy enforcement</h4></div></div></div><p>
						<span class="strong strong"><strong>Policy Enforcement</strong></span> involves the necessary steps to actually enforce authorization decisions to a resource server. This is achieved by enabling a <span class="strong strong"><strong>Policy Enforcement Point</strong></span> or PEP at the resource server that is capable of communicating with the authorization server, ask for authorization data and control access to protected resources based on the decisions and permissions returned by the server.
					</p><p>
						<span class="inlinemediaobject"><img src="images/pep-pattern-diagram.png" alt="PEP Overview"/></span>
					</p><p>
						Red Hat Single Sign-On provides some built-in <a class="link" href="#enforcer_overview" title="Chapter 9. Policy enforcers">Policy Enforcers</a> implementations that you can use to protect your applications depending on the platform they are running on.
					</p></section></section><section class="section" id="authorization_services"><div class="titlepage"><div><div><h3 class="title">1.1.2. Authorization services</h3></div></div></div><p>
					Authorization services consist of the following RESTFul endpoints:
				</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">
							<span class="strong strong"><strong>Token Endpoint</strong></span>
						</li><li class="listitem">
							<span class="strong strong"><strong>Resource Management Endpoint</strong></span>
						</li><li class="listitem">
							<span class="strong strong"><strong>Permission Management Endpoint</strong></span>
						</li></ul></div><p>
					Each of these services provides a specific API covering the different steps involved in the authorization process.
				</p><section class="section" id="token_endpoint"><div class="titlepage"><div><div><h4 class="title">1.1.2.1. Token endpoint</h4></div></div></div><p>
						OAuth2 clients (such as front end applications) can obtain access tokens from the server using the token endpoint and use these same tokens to access resources protected by a resource server (such as back end services). In the same way, Red Hat Single Sign-On Authorization Services provide extensions to OAuth2 to allow access tokens to be issued based on the processing of all policies associated with the resource(s) or scope(s) being requested. This means that resource servers can enforce access to their protected resources based on the permissions granted by the server and held by an access token. In Red Hat Single Sign-On Authorization Services the access token with permissions is called a Requesting Party Token or RPT for short.
					</p><div class="itemizedlist _additional-resources"><p class="title"><strong>Additional resources</strong></p><ul class="itemizedlist _additional-resources" type="disc"><li class="listitem">
								<a class="link" href="#service_obtaining_permissions" title="8.2. Obtaining permissions">Obtaining Permissions</a>
							</li></ul></div></section><section class="section" id="protection_api"><div class="titlepage"><div><div><h4 class="title">1.1.2.2. Protection API</h4></div></div></div><p>
						The <span class="strong strong"><strong>Protection API</strong></span> is a set of <a class="link" href="https://docs.kantarainitiative.org/uma/wg/oauth-uma-federated-authz-2.0-09.html">UMA-compliant</a> endpoint-providing operations for resource servers to help them manage their resources, scopes, permissions, and policies associated with them. Only resource servers are allowed to access this API, which also requires a <span class="strong strong"><strong>uma_protection</strong></span> scope.
					</p><p>
						The operations provided by the Protection API can be organized in two main groups:
					</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p class="simpara">
								<span class="strong strong"><strong>Resource Management</strong></span>
							</p><div class="itemizedlist"><ul class="itemizedlist" type="circle"><li class="listitem">
										Create Resource
									</li><li class="listitem">
										Delete Resource
									</li><li class="listitem">
										Find by Id
									</li><li class="listitem">
										Query
									</li></ul></div></li><li class="listitem"><p class="simpara">
								<span class="strong strong"><strong>Permission Management</strong></span>
							</p><div class="itemizedlist"><ul class="itemizedlist" type="circle"><li class="listitem">
										Issue Permission Tickets
									</li></ul></div></li></ul></div><div class="admonition note"><div class="admonition_header">Note</div><div><p>
							By default, Remote Resource Management is enabled. You can change that using the Red Hat Single Sign-On Administration Console and only allow resource management through the console.
						</p></div></div><p>
						When using the UMA protocol, the issuance of Permission Tickets by the Protection API is an important part of the whole authorization process. As described in a subsequent section, they represent the permissions being requested by the client and that are sent to the server to obtain a final token with all permissions granted during the evaluation of the permissions and policies associated with the resources and scopes being requested.
					</p><div class="itemizedlist _additional-resources"><p class="title"><strong>Additional resources</strong></p><ul class="itemizedlist _additional-resources" type="disc"><li class="listitem">
								<a class="link" href="#service_protection_api" title="8.4. Protection API">Protection API</a>
							</li></ul></div></section></section></section><section class="section" id="overview_terminology"><div class="titlepage"><div><div><h2 class="title">1.2. Terminology</h2></div></div></div><p>
				Before going further, it is important to understand these terms and concepts introduced by Red Hat Single Sign-On Authorization Services.
			</p><section class="section" id="overview_terminology_resource_server"><div class="titlepage"><div><div><h3 class="title">1.2.1. Resource Server</h3></div></div></div><p>
					Per OAuth2 terminology, a resource server is the server hosting the protected resources and capable of accepting and responding to protected resource requests.
				</p><p>
					Resource servers usually rely on some kind of information to decide whether access to a protected resource should be granted. For RESTful-based resource servers, that information is usually carried in a security token, typically sent as a bearer token along with every request to the server. Web applications that rely on a session to authenticate users usually store that information in the user’s session and retrieve it from there for each request.
				</p><p>
					In Red Hat Single Sign-On, any <span class="strong strong"><strong>confidential</strong></span> client application can act as a resource server. This client’s resources and their respective scopes are protected and governed by a set of authorization policies.
				</p></section><section class="section" id="resource"><div class="titlepage"><div><div><h3 class="title">1.2.2. Resource</h3></div></div></div><p>
					A resource is part of the assets of an application and the organization. It can be a set of one or more endpoints, a classic web resource such as an HTML page, and so on. In authorization policy terminology, a resource is the <span class="emphasis"><em>object</em></span> being protected.
				</p><p>
					Every resource has a unique identifier that can represent a single resource or a set of resources. For instance, you can manage a <span class="emphasis"><em>Banking Account Resource</em></span> that represents and defines a set of authorization policies for all banking accounts. But you can also have a different resource named <span class="emphasis"><em>Alice’s Banking Account</em></span>, which represents a single resource owned by a single customer, which can have its own set of authorization policies.
				</p></section><section class="section" id="scope"><div class="titlepage"><div><div><h3 class="title">1.2.3. Scope</h3></div></div></div><p>
					A resource’s scope is a bounded extent of access that is possible to perform on a resource. In authorization policy terminology, a scope is one of the potentially many <span class="emphasis"><em>verbs</em></span> that can logically apply to a resource.
				</p><p>
					It usually indicates what can be done with a given resource. Example of scopes are view, edit, delete, and so on. However, scope can also be related to specific information provided by a resource. In this case, you can have a project resource and a cost scope, where the cost scope is used to define specific policies and permissions for users to access a project’s cost.
				</p></section><section class="section" id="permission"><div class="titlepage"><div><div><h3 class="title">1.2.4. Permission</h3></div></div></div><p>
					Consider this simple and very common permission:
				</p><p>
					A permission associates the object being protected with the policies that must be evaluated to determine whether access is granted.
				</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p class="simpara">
							<span class="strong strong"><strong>X</strong></span> CAN DO <span class="strong strong"><strong>Y</strong></span> ON RESOURCE <span class="strong strong"><strong>Z</strong></span>
						</p><div class="itemizedlist"><ul class="itemizedlist" type="circle"><li class="listitem"><p class="simpara">
									where …​
								</p><div class="itemizedlist"><ul class="itemizedlist" type="square"><li class="listitem">
											<span class="strong strong"><strong>X</strong></span> represents one or more users, roles, or groups, or a combination of them. You can also use claims and context here.
										</li><li class="listitem">
											<span class="strong strong"><strong>Y</strong></span> represents an action to be performed, for example, write, view, and so on.
										</li><li class="listitem">
											<span class="strong strong"><strong>Z</strong></span> represents a protected resource, for example, "/accounts".
										</li></ul></div></li></ul></div></li></ul></div><p>
					Red Hat Single Sign-On provides a rich platform for building a range of permission strategies ranging from simple to very complex, rule-based dynamic permissions. It provides flexibility and helps to:
				</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">
							Reduce code refactoring and permission management costs
						</li><li class="listitem">
							Support a more flexible security model, helping you to easily adapt to changes in your security requirements
						</li><li class="listitem">
							Make changes at runtime; applications are only concerned about the resources and scopes being protected and not how they are protected.
						</li></ul></div></section><section class="section" id="policy"><div class="titlepage"><div><div><h3 class="title">1.2.5. Policy</h3></div></div></div><p>
					A policy defines the conditions that must be satisfied to grant access to an object. Unlike permissions, you do not specify the object being protected but rather the conditions that must be satisfied for access to a given object (for example, resource, scope, or both). Policies are strongly related to the different access control mechanisms (ACMs) that you can use to protect your resources. With policies, you can implement strategies for attribute-based access control (ABAC), role-based access control (RBAC), context-based access control, or any combination of these.
				</p><p>
					Red Hat Single Sign-On leverages the concept of policies and how you define them by providing the concept of aggregated policies, where you can build a "policy of policies" and still control the behavior of the evaluation. Instead of writing one large policy with all the conditions that must be satisfied for access to a given resource, the policies implementation in Red Hat Single Sign-On Authorization Services follows the divide-and-conquer technique. That is, you can create individual policies, then reuse them with different permissions and build more complex policies by combining individual policies.
				</p></section><section class="section" id="policy_provider"><div class="titlepage"><div><div><h3 class="title">1.2.6. Policy provider</h3></div></div></div><p>
					Policy providers are implementations of specific policy types. Red Hat Single Sign-On provides built-in policies, backed by their corresponding policy providers, and you can create your own policy types to support your specific requirements.
				</p><p>
					Red Hat Single Sign-On provides a SPI (Service Provider Interface) that you can use to plug in your own policy provider implementations.
				</p></section><section class="section" id="overview_terminology_permission_ticket"><div class="titlepage"><div><div><h3 class="title">1.2.7. Permission ticket</h3></div></div></div><p>
					A permission ticket is a special type of token defined by the User-Managed Access (UMA) specification that provides an opaque structure whose form is determined by the authorization server. This structure represents the resources and/or scopes being requested by a client, the access context, as well as the policies that must be applied to a request for authorization data (requesting party token [RPT]).
				</p><p>
					In UMA, permission tickets are crucial to support person-to-person sharing and also person-to-organization sharing. Using permission tickets for authorization workflows enables a range of scenarios from simple to complex, where resource owners and resource servers have complete control over their resources based on fine-grained policies that govern the access to these resources.
				</p><p>
					In the UMA workflow, permission tickets are issued by the authorization server to a resource server, which returns the permission ticket to the client trying to access a protected resource. Once the client receives the ticket, it can make a request for an RPT (a final token holding authorization data) by sending the ticket back to the authorization server.
				</p><p>
					For more information on permission tickets, see <a class="link" href="#service_user_managed_access" title="8.3. User-managed access">User-Managed Access</a> and the <a class="link" href="https://docs.kantarainitiative.org/uma/wg/oauth-uma-grant-2.0-09.html">UMA</a> specification.
				</p></section></section></section><section class="chapter" id="getting_started_overview"><div class="titlepage"><div><div><h1 class="title">Chapter 2. Getting started</h1></div></div></div><p>
			Before you can use this tutorial, you need to complete the installation of Red Hat Single Sign-On and create the initial admin user as shown in the <a class="link" href="https://access.redhat.com/documentation/en-us/red_hat_single_sign-on/7.4/html-single/getting_started_guide/">Getting Started Guide</a> tutorial. There is one caveat to this. You have to run a separate JBoss EAP instance on the same machine as Red Hat Single Sign-On Server. This separate instance will run your Java Servlet application. Because of this you will have to run the Red Hat Single Sign-On under a different port so that there are no port conflicts when running on the same machine. Use the <code class="literal">jboss.socket.binding.port-offset</code> system property on the command line. The value of this property is a number that will be added to the base value of every port opened by Red Hat Single Sign-On Server.
		</p><p>
			To boot Red Hat Single Sign-On Server:
		</p><div class="formalpara"><p class="title"><strong>Linux/Unix</strong></p><p>
				
<pre class="screen">$ .../bin/standalone.sh -Djboss.socket.binding.port-offset=100</pre>
			</p></div><div class="formalpara"><p class="title"><strong>Windows</strong></p><p>
				
<pre class="screen">&gt; ...\bin\standalone.bat -Djboss.socket.binding.port-offset=100</pre>
			</p></div><p>
			After installing and booting both servers you should be able to access Red Hat Single Sign-On Admin Console at <a class="link" href="http://localhost:8180/auth/admin/">http://localhost:8180/auth/admin/</a> and also the JBoss EAP instance at <a class="link" href="http://localhost:8080">http://localhost:8080</a>.
		</p><div class="itemizedlist _additional-resources"><p class="title"><strong>Additional resources</strong></p><ul class="itemizedlist _additional-resources" type="disc"><li class="listitem">
					For more details about installing and configuring JBoss EAP instances, see <a class="link" href="https://access.redhat.com/documentation/en-us/red_hat_single_sign-on/7.4/html-single/securing_applications_and_services_guide/">Securing Applications and Services Guide</a>.
				</li></ul></div><section class="section" id="getting_started_hello_world_overview"><div class="titlepage"><div><div><h2 class="title">2.1. Securing a servlet application</h2></div></div></div><p>
				The purpose of this getting started guide is to get you up and running as quickly as possible so that you can experiment with and test various authorization features provided by Red Hat Single Sign-On. This quick tour relies heavily on the default database and server configurations and does not cover complex deployment options. For more information on features or configuration options, see the appropriate sections in this documentation.
			</p><p>
				This guide explains key concepts about Red Hat Single Sign-On Authorization Services:
			</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">
						Enabling fine-grained authorization for a client application
					</li><li class="listitem">
						Configuring a client application to be a resource server, with protected resources
					</li><li class="listitem">
						Defining permissions and authorization policies to govern access to protected resources
					</li><li class="listitem">
						Enabling policy enforcement in your applications.
					</li></ul></div></section><section class="section" id="getting_started_hello_world_create_realm"><div class="titlepage"><div><div><h2 class="title">2.2. Creating a realm and a user</h2></div></div></div><p>
				The first step in this tutorial is to create a realm and a user in that realm. Then, within the realm we will create a single client application, which then becomes a <a class="link" href="#overview_terminology" title="1.2. Terminology">resource server</a> for which you need to enable authorization services.
			</p><div class="orderedlist"><p class="title"><strong>Procedure</strong></p><ol class="orderedlist" type="1"><li class="listitem"><p class="simpara">
						Create a realm with a name <span class="strong strong"><strong>hello-world-authz</strong></span>. Once created, a page similar to the following is displayed:
					</p><div class="formalpara"><p class="title"><strong>Realm hello-world-authz</strong></p><p>
							<span class="inlinemediaobject"><img src="images/rhsso-images/getting-started/hello-world/create-realm.png" alt="Realm hello-world-authz"/></span>
						</p></div></li><li class="listitem"><p class="simpara">
						Click <span class="strong strong"><strong>Users</strong></span>.
					</p><p class="simpara">
						The user list page displays where you can create a user.
					</p></li><li class="listitem">
						Click <span class="strong strong"><strong>Add User</strong></span>.
					</li><li class="listitem">
						Complete the <span class="strong strong"><strong>Username</strong></span>, <span class="strong strong"><strong>Email</strong></span>, <span class="strong strong"><strong>First Name</strong></span>, and <span class="strong strong"><strong>Last Name</strong></span> fields.
					</li><li class="listitem">
						Toggle <span class="strong strong"><strong>User Enabled</strong></span> to <span class="strong strong"><strong>ON</strong></span>
					</li><li class="listitem"><p class="simpara">
						Click <span class="strong strong"><strong>Save</strong></span>.
					</p><div class="formalpara"><p class="title"><strong>Add User</strong></p><p>
							<span class="inlinemediaobject"><img src="images/rhsso-images/getting-started/hello-world/create-user.png" alt="Add User"/></span>
						</p></div></li><li class="listitem"><p class="simpara">
						Set a password for the user by clicking the <span class="strong strong"><strong>Credentials</strong></span> tab.
					</p><div class="formalpara"><p class="title"><strong>Set User Password</strong></p><p>
							<span class="inlinemediaobject"><img src="images/rhsso-images/getting-started/hello-world/reset-user-pwd.png" alt="Set User Password"/></span>
						</p></div></li><li class="listitem">
						Complete the <span class="strong strong"><strong>New Password</strong></span> and <span class="strong strong"><strong>Password Confirmation</strong></span> fields with a password and click the <span class="strong strong"><strong>Temporary</strong></span> switch to <span class="strong strong"><strong>OFF</strong></span>.
					</li><li class="listitem">
						Click <span class="strong strong"><strong>Set Password</strong></span> to set the user’s password.
					</li></ol></div></section><section class="section" id="getting_started_hello_world_enabling_authz_services"><div class="titlepage"><div><div><h2 class="title">2.3. Enabling authorization services</h2></div></div></div><p>
				You can enable authorization services in an existing client application configured to use the OpenID Connect Protocol. You can also create a client using the following procedure.
			</p><div class="orderedlist"><p class="title"><strong>Procedure</strong></p><ol class="orderedlist" type="1"><li class="listitem">
						Click <span class="strong strong"><strong>Clients</strong></span> to start creating a client application.
					</li><li class="listitem"><p class="simpara">
						Fill in the <span class="strong strong"><strong>Client ID</strong></span>, <span class="strong strong"><strong>Client Protocol</strong></span>, and <span class="strong strong"><strong>Root URL</strong></span> fields.
					</p><div class="formalpara"><p class="title"><strong>Create Client Application</strong></p><p>
							<span class="inlinemediaobject"><img src="images/rhsso-images/getting-started/hello-world/create-client.png" alt="Create Client Application"/></span>
						</p></div></li><li class="listitem"><p class="simpara">
						Click <span class="strong strong"><strong>Save</strong></span>.
					</p><p class="simpara">
						The Client Details page is displayed.
					</p></li><li class="listitem">
						Select <span class="strong strong"><strong>confidential</strong></span> in the <span class="strong strong"><strong>Access Type</strong></span> field and toggle <span class="strong strong"><strong>Authorization Enabled</strong></span> to <span class="strong strong"><strong>ON</strong></span>
					</li><li class="listitem"><p class="simpara">
						Click <span class="strong strong"><strong>Save</strong></span>.
					</p><p class="simpara">
						A new <span class="strong strong"><strong>Authorization</strong></span> tab is displayed for the client.
					</p><div class="formalpara"><p class="title"><strong>Client Details</strong></p><p>
							<span class="inlinemediaobject"><img src="images/rhsso-images/getting-started/hello-world/enable-authz.png" alt="Client Details"/></span>
						</p></div></li><li class="listitem"><p class="simpara">
						Click the <span class="strong strong"><strong>Authorization</strong></span> tab.
					</p><p class="simpara">
						An Authorization Settings page similar to the following is displayed:
					</p><div class="formalpara"><p class="title"><strong>Authorization Settings</strong></p><p>
							<span class="inlinemediaobject"><img src="images/rhsso-images/getting-started/hello-world/authz-settings.png" alt="Authorization Settings"/></span>
						</p></div></li></ol></div><p>
				When you enable authorization services for a client application, Red Hat Single Sign-On automatically creates several default settings for your client authorization configuration.
			</p><div class="itemizedlist _additional-resources"><p class="title"><strong>Additional resources</strong></p><ul class="itemizedlist _additional-resources" type="disc"><li class="listitem">
						<a class="link" href="#resource_server_enable_authorization" title="3.2. Enabling authorization services">Enabling authorization services</a>
					</li><li class="listitem">
						<a class="link" href="#resource_server_default_config" title="3.3. Default Configuration">Default configuration</a>
					</li></ul></div></section><section class="section" id="getting_started_hello_world_deploy"><div class="titlepage"><div><div><h2 class="title">2.4. Build, deploy, and test your application</h2></div></div></div><p>
				Now that the <span class="strong strong"><strong>app-authz-vanilla</strong></span> resource server (or client) is properly configured and authorization services are enabled, it can be deployed to the server.
			</p><p>
				The project and code for the application you are going to deploy is available in <a class="link" href="https://github.com/redhat-developer/redhat-sso-quickstarts">Red Hat Single Sign-On Quickstarts Repository</a>. You will need the following installed on your machine and available in your PATH before you can continue:
			</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">
						Java JDK 8
					</li><li class="listitem">
						Apache Maven 3.1.1 or higher
					</li><li class="listitem">
						Git
					</li></ul></div><p>
				You can obtain the code by cloning the repository at <a class="link" href="https://github.com/redhat-developer/redhat-sso-quickstarts">https://github.com/redhat-developer/redhat-sso-quickstarts</a>. Use the branch matching the version of Red Hat Single Sign-On in use.
			</p><p>
				Follow these steps to download the code.
			</p><div class="formalpara"><p class="title"><strong>Clone Project</strong></p><p>
					
<pre class="screen">$ git clone https://github.com/redhat-developer/redhat-sso-quickstarts</pre>
				</p></div><p>
				The application we are about to build and deploy is located at
			</p><pre class="screen">$ cd redhat-sso-quickstarts/app-authz-jee-vanilla</pre><section class="section" id="obtaining_the_adapter_configuration"><div class="titlepage"><div><div><h3 class="title">2.4.1. Obtaining the adapter configuration</h3></div></div></div><p>
					You must first obtain the adapter configuration before building and deploying the application.
				</p><div class="orderedlist"><p class="title"><strong>Procedure</strong></p><ol class="orderedlist" type="1"><li class="listitem">
							Log into the Admin Console.
						</li><li class="listitem">
							Click <span class="strong strong"><strong>Clients</strong></span> in the menu.
						</li><li class="listitem"><p class="simpara">
							In the client listing, click the <span class="strong strong"><strong>app-authz-vanilla</strong></span> client application. The Client Details page opens.
						</p><div class="formalpara"><p class="title"><strong>Client Details</strong></p><p>
								<span class="inlinemediaobject"><img src="images/rhsso-images/getting-started/hello-world/enable-authz.png" alt="Client Details"/></span>
							</p></div></li><li class="listitem">
							Click the <span class="strong strong"><strong>Installation</strong></span> tab.
						</li><li class="listitem"><p class="simpara">
							From the Format Option item list, select <span class="strong strong"><strong>Keycloak OIDC JSON</strong></span>.
						</p><p class="simpara">
							The adapter configuration is displayed in JSON format.
						</p></li><li class="listitem"><p class="simpara">
							Click <span class="strong strong"><strong>Download</strong></span>.
						</p><div class="formalpara"><p class="title"><strong>Adapter Configuration</strong></p><p>
								<span class="inlinemediaobject"><img src="images/rhsso-images/getting-started/hello-world/adapter-config.png" alt="Adapter Configuration"/></span>
							</p></div></li><li class="listitem">
							Move the file <code class="literal">keycloak.json</code> to the <code class="literal">app-authz-jee-vanilla/config</code> directory.
						</li><li class="listitem"><p class="simpara">
							Optionally, specify a redirection URL.
						</p><p class="simpara">
							By default, the policy enforcer responds with a <code class="literal">403</code> status code when the user lacks permission to access protected resources on the resource server. However, you can also specify a redirection URL for unauthorized users. To specify a redirection URL, edit the <span class="strong strong"><strong>keycloak.json</strong></span> file that you updated and replace the <code class="literal">policy-enforcer</code> configuration with the following:
						</p><pre class="programlisting language-json">"policy-enforcer": {
    "on-deny-redirect-to" : "/app-authz-vanilla/error.jsp"
}</pre><p class="simpara">
							This change specifies to the policy enforcer to redirect users to a <code class="literal">/app-authz-vanilla/error.jsp</code> page if a user does not have the necessary permissions to access a protected resource, rather than an unhelpful <code class="literal">403 Unauthorized</code> message.
						</p></li></ol></div></section><section class="section" id="building_and_deploying_the_application"><div class="titlepage"><div><div><h3 class="title">2.4.2. Building and deploying the application</h3></div></div></div><p>
					To build and deploy the application execute the following command:
				</p><pre class="screen">$ cd redhat-sso-quickstarts/app-authz-jee-vanilla
$ mvn clean package wildfly:deploy</pre></section><section class="section" id="testing_the_application"><div class="titlepage"><div><div><h3 class="title">2.4.3. Testing the application</h3></div></div></div><p>
					If your application was successfully deployed, you can access it at <a class="link" href="http://localhost:8080/app-authz-vanilla">http://localhost:8080/app-authz-vanilla</a>. The Red Hat Single Sign-On Login page opens.
				</p><div class="formalpara"><p class="title"><strong>Login Page</strong></p><p>
						<span class="inlinemediaobject"><img src="images/rhsso-images/getting-started/hello-world/login-page.png" alt="Login Page"/></span>
					</p></div><div class="orderedlist"><p class="title"><strong>Procedure</strong></p><ol class="orderedlist" type="1"><li class="listitem"><p class="simpara">
							Log in as <span class="strong strong"><strong>alice</strong></span> using the password you specified for that user. The following page is displayed:
						</p><div class="formalpara"><p class="title"><strong>Hello World Authz Main Page</strong></p><p>
								<span class="inlinemediaobject"><img src="images/rhsso-images/getting-started/hello-world/main-page.png" alt="Hello World Authz Main Page"/></span>
							</p></div><p class="simpara">
							The <a class="link" href="#resource_server_default_config" title="3.3. Default Configuration">default settings</a> defined by Red Hat Single Sign-On when you enable authorization services for a client application provide a simple policy that always grants access to the resources protected by this policy.
						</p></li><li class="listitem"><p class="simpara">
							Change the default permissions and policies and test how your application responds. You could also create new policies using the different policy types provided by Red Hat Single Sign-On.
						</p><p class="simpara">
							You have many options to test this application. For example, you can change the default policy by clicking the <span class="strong strong"><strong>Authorization</strong></span> tab for the client, then <span class="strong strong"><strong>Policies</strong></span> tab, then click the <span class="strong strong"><strong>Default Policy</strong></span> in the list to allow you to change it as follows:
						</p><pre class="programlisting language-js">// The default value is $evaluation.grant(),
// let's see what happens when we change it to $evaluation.deny()
$evaluation.deny();</pre></li><li class="listitem"><p class="simpara">
							Log out of the demo application and log in again.
						</p><p class="simpara">
							You can no longer access the application.
						</p><p class="simpara">
							<span class="inlinemediaobject"><img src="images/rhsso-images/getting-started/hello-world/access-denied-page.png" alt="Access Denied Page"/></span>
						</p></li><li class="listitem"><p class="simpara">
							Correct that problem by changing the <span class="strong strong"><strong>Logic</strong></span> to <span class="strong strong"><strong>Negative</strong></span> using the item list below the policy code text area.
						</p><p class="simpara">
							That re-enables access to the application as we are negating the result of that policy, which is by default denying all requests for access. Again, before testing this change, be sure to log out and log in again.
						</p></li></ol></div><div class="itemizedlist _additional-resources"><p class="title"><strong>Additional resources</strong></p><ul class="itemizedlist _additional-resources" type="disc"><li class="listitem">
							<a class="link" href="#policy_overview" title="Chapter 5. Managing policies">Policy types</a>
						</li></ul></div></section><section class="section" id="next_steps"><div class="titlepage"><div><div><h3 class="title">2.4.4. Next steps</h3></div></div></div><p>
					There are additional things you can do, such as:
				</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">
							Create a scope, define a policy and permission for it, and test it on the application side. Can the user perform an action or anything else represented by the scope you created?
						</li><li class="listitem">
							Create different types of policies such as <a class="link" href="#policy_js" title="5.3. JavaScript-based policy">JavaScript-based</a>, and associate these policies with the <code class="literal">Default Permission</code>.
						</li><li class="listitem">
							Apply multiple policies to the <code class="literal">Default Permission</code> and test the behavior. For example, combine multiple policies and change the <code class="literal">Decision Strategy</code> accordingly.
						</li></ul></div><div class="itemizedlist _additional-resources"><p class="title"><strong>Additional resources</strong></p><ul class="itemizedlist _additional-resources" type="disc"><li class="listitem">
							For more information about how to view and test permissions inside your application see <a class="link" href="#enforcer_authorization_context" title="9.3. Obtaining the authorization context">Obtaining the authorization context</a>.
						</li></ul></div></section></section><section class="section" id="authorization_quickstarts"><div class="titlepage"><div><div><h2 class="title">2.5. Authorization quickstarts</h2></div></div></div><p>
				In addition to the <span class="strong strong"><strong>app-authz-jee-vanilla</strong></span> quickstart that was used as a sample application in the previous section, the <a class="link" href="https://github.com/redhat-developer/redhat-sso-quickstarts">Red Hat Single Sign-On Quickstarts Repository</a> contains other applications that make use of the authorization services described in this documentation.
			</p><p>
				The authorization quickstarts have been designed so that authorization services are displayed in different scenarios and using different technologies and integrations. It is not meant as a comprehensive set of all the possible use cases involving authorization but they should provide a starting point for users interested in understanding how the authorization services can be used in their own applications.
			</p><p>
				Each quickstart has a <code class="literal">README</code> file with instructions on how to build, deploy, and test the sample application. The following table provides a brief description of the available authorization quickstarts:
			</p><div class="table" id="idm139768734641152"><p class="title"><strong>Table 2.1. Authorization quickstarts</strong></p><div class="table-contents"><table class="lt-4-cols lt-7-rows"><colgroup><col style="width: 50%; " class="col_1"/><col style="width: 50%; " class="col_2"/></colgroup><thead><tr><th align="left" valign="top" id="idm139768734636256" scope="col">Name</th><th align="left" valign="top" id="idm139768734635168" scope="col">Description</th></tr></thead><tbody><tr><td align="left" valign="top" headers="idm139768734636256">
							<p>
								<a class="link" href="https://github.com/keycloak/keycloak-quickstarts/tree/latest/app-authz-jee-servlet">app-authz-jee-servlet</a>
							</p>
							</td><td align="left" valign="top" headers="idm139768734635168">
							<p>
								Demonstrates how to enable fine-grained authorization to a Java EE application in order to protect specific resources and build a dynamic menu based on the permissions obtained from a Keycloak Server.
							</p>
							</td></tr><tr><td align="left" valign="top" headers="idm139768734636256">
							<p>
								<a class="link" href="https://github.com/keycloak/keycloak-quickstarts/tree/latest/app-authz-jee-vanilla">app-authz-jee-vanilla</a>
							</p>
							</td><td align="left" valign="top" headers="idm139768734635168">
							<p>
								Demonstrates how to enable fine-grained authorization to a Java EE application and use the default authorization settings to protect all resources in the application.
							</p>
							</td></tr><tr><td align="left" valign="top" headers="idm139768734636256">
							<p>
								<a class="link" href="https://github.com/keycloak/keycloak-quickstarts/tree/latest/app-authz-rest-springboot">app-authz-rest-springboot</a>
							</p>
							</td><td align="left" valign="top" headers="idm139768734635168">
							<p>
								Demonstrates how to protect a SpringBoot REST service using Keycloak Authorization Services.
							</p>
							</td></tr><tr><td align="left" valign="top" headers="idm139768734636256">
							<p>
								<a class="link" href="https://github.com/keycloak/keycloak-quickstarts/tree/latest/app-authz-springboot">app-authz-springboot</a>
							</p>
							</td><td align="left" valign="top" headers="idm139768734635168">
							<p>
								Demonstrates how to write a SpringBoot Web application where both authentication and authorization aspects are managed by Keycloak.
							</p>
							</td></tr><tr><td align="left" valign="top" headers="idm139768734636256">
							<p>
								<a class="link" href="https://github.com/keycloak/keycloak-quickstarts/tree/latest/app-authz-uma-photoz">app-authz-uma-photoz</a>
							</p>
							</td><td align="left" valign="top" headers="idm139768734635168">
							<p>
								A simple application based on HTML5+AngularJS+JAX-RS that demonstrates how to enable User-Managed Access to your application and let users to manage permissions for their resources.
							</p>
							</td></tr></tbody></table></div></div></section></section><section class="chapter" id="resource_server_overview"><div class="titlepage"><div><div><h1 class="title">Chapter 3. Managing resource servers</h1></div></div></div><p>
			According to the OAuth2 specification, a resource server is a server hosting the protected resources and capable of accepting and responding to protected resource requests.
		</p><p>
			In Red Hat Single Sign-On, resource servers are provided with a rich platform for enabling fine-grained authorization for their protected resources, where authorization decisions can be made based on different access control mechanisms.
		</p><p>
			Any client application can be configured to support fine-grained permissions. In doing so, you are conceptually turning the client application into a resource server.
		</p><section class="section" id="resource_server_create_client"><div class="titlepage"><div><div><h2 class="title">3.1. Creating a client application</h2></div></div></div><p>
				The first step to enable Red Hat Single Sign-On Authorization Services is to create the client application that you want to turn into a resource server.
			</p><div class="orderedlist"><p class="title"><strong>Procedure</strong></p><ol class="orderedlist" type="1"><li class="listitem"><p class="simpara">
						Click <span class="strong strong"><strong>Clients</strong></span>.
					</p><div class="formalpara"><p class="title"><strong>Clients</strong></p><p>
							<span class="inlinemediaobject"><img src="images/rhsso-images/resource-server/client-list.png" alt="Clients"/></span>
						</p></div></li><li class="listitem"><p class="simpara">
						On this page, click <span class="strong strong"><strong>Create</strong></span>.
					</p><div class="formalpara"><p class="title"><strong>Create Client</strong></p><p>
							<span class="inlinemediaobject"><img src="images/rhsso-images/resource-server/client-create.png" alt="Create Client"/></span>
						</p></div></li><li class="listitem">
						Type the <code class="literal">Client ID</code> of the client. For example, <span class="emphasis"><em>my-resource-server</em></span>.
					</li><li class="listitem"><p class="simpara">
						Type the <code class="literal">Root URL</code> for your application. For example:
					</p><pre class="screen">http://${host}:${port}/my-resource-server</pre></li><li class="listitem"><p class="simpara">
						Click <span class="strong strong"><strong>Save</strong></span>. The client is created and the client Settings page opens. A page similar to the following is displayed:
					</p><div class="formalpara"><p class="title"><strong>Client Settings</strong></p><p>
							<span class="inlinemediaobject"><img src="images/rhsso-images/resource-server/client-enable-authz.png" alt="Client Settings"/></span>
						</p></div></li></ol></div></section><section class="section" id="resource_server_enable_authorization"><div class="titlepage"><div><div><h2 class="title">3.2. Enabling authorization services</h2></div></div></div><p>
				To turn your OIDC Client Application into a resource server and enable fine-grained authorization, select <span class="strong strong"><strong>Access type</strong></span> <span class="strong strong"><strong>confidential</strong></span> and click the <span class="strong strong"><strong>Authorization Enabled</strong></span> switch to <span class="strong strong"><strong>ON</strong></span> then click <span class="strong strong"><strong>Save</strong></span>.
			</p><div class="formalpara"><p class="title"><strong>Enabling Authorization Services</strong></p><p>
					<span class="inlinemediaobject"><img src="images/rhsso-images/resource-server/client-enable-authz.png" alt="Enabling Authorization Services"/></span>
				</p></div><p>
				A new Authorization tab is displayed for this client. Click the <span class="strong strong"><strong>Authorization</strong></span> tab and a page similar to the following is displayed:
			</p><div class="formalpara"><p class="title"><strong>Resource Server Settings</strong></p><p>
					<span class="inlinemediaobject"><img src="images/rhsso-images/resource-server/authz-settings.png" alt="Resource Server Settings"/></span>
				</p></div><p>
				The Authorization tab contains additional sub-tabs covering the different steps that you must follow to actually protect your application’s resources. Each tab is covered separately by a specific topic in this documentation. But here is a quick description about each one:
			</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p class="simpara">
						<span class="strong strong"><strong>Settings</strong></span>
					</p><p class="simpara">
						General settings for your resource server. For more details about this page see the <a class="link" href="#resource_server_settings" title="3.2.1. Resource server settings">Resource Server Settings</a> section.
					</p></li><li class="listitem"><p class="simpara">
						<span class="strong strong"><strong>Resource</strong></span>
					</p><p class="simpara">
						From this page, you can manage your application’s <a class="link" href="#resource_overview" title="Chapter 4. Managing resources and scopes">resources</a>.
					</p></li><li class="listitem"><p class="simpara">
						<span class="strong strong"><strong>Authorization Scopes</strong></span>
					</p><p class="simpara">
						From this page, you can manage <a class="link" href="#resource_overview" title="Chapter 4. Managing resources and scopes">scopes</a>.
					</p></li><li class="listitem"><p class="simpara">
						<span class="strong strong"><strong>Policies</strong></span>
					</p><p class="simpara">
						From this page, you can manage <a class="link" href="#policy_overview" title="Chapter 5. Managing policies">authorization policies</a> and define the conditions that must be met to grant a permission.
					</p></li><li class="listitem"><p class="simpara">
						<span class="strong strong"><strong>Permissions</strong></span>
					</p><p class="simpara">
						From this page, you can manage the <a class="link" href="#permission_overview" title="Chapter 6. Managing permissions">permissions</a> for your protected resources and scopes by linking them with the policies you created.
					</p></li><li class="listitem"><p class="simpara">
						<span class="strong strong"><strong>Evaluate</strong></span>
					</p><p class="simpara">
						From this page, you can <a class="link" href="#policy_evaluation_overview" title="Chapter 7. Evaluating and testing policies">simulate authorization requests</a> and view the result of the evaluation of the permissions and authorization policies you have defined.
					</p></li><li class="listitem"><p class="simpara">
						<span class="strong strong"><strong>Export Settings</strong></span>
					</p><p class="simpara">
						From this page, you can <a class="link" href="#resource_server_import_config" title="3.4. Export and import authorization configuration">export</a> the authorization settings to a JSON file.
					</p></li></ul></div><section class="section" id="resource_server_settings"><div class="titlepage"><div><div><h3 class="title">3.2.1. Resource server settings</h3></div></div></div><p>
					On the Resource Server Settings page, you can configure the policy enforcement mode, allow remote resource management, and export the authorization configuration settings.
				</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p class="simpara">
							<span class="strong strong"><strong>Policy Enforcement Mode</strong></span>
						</p><p class="simpara">
							Specifies how policies are enforced when processing authorization requests sent to the server.
						</p><div class="itemizedlist"><ul class="itemizedlist" type="circle"><li class="listitem"><p class="simpara">
									<span class="strong strong"><strong>Enforcing</strong></span>
								</p><p class="simpara">
									(default mode) Requests are denied by default even when there is no policy associated with a given resource.
								</p></li><li class="listitem"><p class="simpara">
									<span class="strong strong"><strong>Permissive</strong></span>
								</p><p class="simpara">
									Requests are allowed even when there is no policy associated with a given resource.
								</p></li><li class="listitem"><p class="simpara">
									<span class="strong strong"><strong>Disabled</strong></span>
								</p><p class="simpara">
									Disables the evaluation of all policies and allows access to all resources.
								</p></li></ul></div></li><li class="listitem"><p class="simpara">
							<span class="strong strong"><strong>Decision Strategy</strong></span>
						</p><p class="simpara">
							This configurations changes how the policy evaluation engine decides whether or not a resource or scope should be granted based on the outcome from all evaluated permissions. <code class="literal">Affirmative</code> means that at least one permission must evaluate to a positive decision in order grant access to a resource and its scopes. <code class="literal">Unanimous</code> means that all permissions must evaluate to a positive decision in order for the final decision to be also positive. As an example, if two permissions for a same resource or scope are in conflict (one of them is granting access and the other is denying access), the permission to the resource or scope will be granted if the choosen strategy is <code class="literal">Affirmative</code>. Otherwise, a single deny from any permission will also deny access to the resource or scope.
						</p></li><li class="listitem"><p class="simpara">
							<span class="strong strong"><strong>Remote Resource Management</strong></span>
						</p><p class="simpara">
							Specifies whether resources can be managed remotely by the resource server. If false, resources can be managed only from the administration console.
						</p></li></ul></div></section></section><section class="section" id="resource_server_default_config"><div class="titlepage"><div><div><h2 class="title">3.3. Default Configuration</h2></div></div></div><p>
				When you create a resource server, Red Hat Single Sign-On creates a default configuration for your newly created resource server.
			</p><p>
				The default configuration consists of:
			</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">
						A default protected resource representing all resources in your application.
					</li><li class="listitem">
						A policy that always grants access to the resources protected by this policy.
					</li><li class="listitem">
						A permission that governs access to all resources based on the default policy.
					</li></ul></div><p>
				The default protected resource is referred to as the <span class="strong strong"><strong>default resource</strong></span> and you can view it if you navigate to the <span class="strong strong"><strong>Resources</strong></span> tab.
			</p><div class="formalpara"><p class="title"><strong>Default Resource</strong></p><p>
					<span class="inlinemediaobject"><img src="images/rhsso-images/resource-server/default-resource.png" alt="Default Resource"/></span>
				</p></div><p>
				This resource defines a <code class="literal">Type</code>, namely <code class="literal">urn:my-resource-server:resources:default</code> and a <code class="literal">URI</code> <code class="literal">/*</code>. Here, the <code class="literal">URI</code> field defines a wildcard pattern that indicates to Red Hat Single Sign-On that this resource represents all the paths in your application. In other words, when enabling <a class="link" href="#enforcer_overview" title="Chapter 9. Policy enforcers">policy enforcement</a> for your application, all the permissions associated with the resource will be examined before granting access.
			</p><p>
				The <code class="literal">Type</code> mentioned previously defines a value that can be used to create <a class="link" href="#permission_typed_resource" title="6.1.2. Typed resource permission">typed resource permissions</a> that must be applied to the default resource or any other resource you create using the same type.
			</p><p>
				The default policy is referred to as the <span class="strong strong"><strong>only from realm policy</strong></span> and you can view it if you navigate to the <span class="strong strong"><strong>Policies</strong></span> tab.
			</p><div class="formalpara"><p class="title"><strong>Default Policy</strong></p><p>
					<span class="inlinemediaobject"><img src="images/rhsso-images/resource-server/default-policy.png" alt="Default Policy"/></span>
				</p></div><p>
				This policy is a <a class="link" href="#policy_js" title="5.3. JavaScript-based policy">JavaScript-based policy</a> defining a condition that always grants access to the resources protected by this policy. If you click this policy you can see that it defines a rule as follows:
			</p><pre class="programlisting language-js">// by default, grants any permission associated with this policy
$evaluation.grant();</pre><p>
				Lastly, the default permission is referred to as the <span class="strong strong"><strong>default permission</strong></span> and you can view it if you navigate to the <span class="strong strong"><strong>Permissions</strong></span> tab.
			</p><div class="formalpara"><p class="title"><strong>Default Permission</strong></p><p>
					<span class="inlinemediaobject"><img src="images/rhsso-images/resource-server/default-permission.png" alt="Default Permission"/></span>
				</p></div><p>
				This permission is a <a class="link" href="#permission_create_resource" title="6.1. Creating resource-based permission">resource-based permission</a>, defining a set of one or more policies that are applied to all resources with a given type.
			</p><section class="section" id="changing_the_default_configuration"><div class="titlepage"><div><div><h3 class="title">3.3.1. Changing the default configuration</h3></div></div></div><p>
					You can change the default configuration by removing the default resource, policy, or permission definitions and creating your own.
				</p><p>
					The default resource is created with an <span class="strong strong"><strong>URI</strong></span> that maps to any resource or path in your application using a <span class="strong strong"><strong>/</strong></span>* pattern. Before creating your own resources, permissions and policies, make sure the default configuration doesn’t conflict with your own settings.
				</p><div class="admonition note"><div class="admonition_header">Note</div><div><p>
						The default configuration defines a resource that maps to all paths in your application. If you are about to write permissions to your own resources, be sure to remove the <span class="strong strong"><strong>Default Resource</strong></span> or change its <code class="literal"><code class="literal">URIS</code></code> fields to a more specific paths in your application. Otherwise, the policy associated with the default resource (which by default always grants access) will allow Red Hat Single Sign-On to grant access to any protected resource.
					</p></div></div></section></section><section class="section" id="resource_server_import_config"><div class="titlepage"><div><div><h2 class="title">3.4. Export and import authorization configuration</h2></div></div></div><p>
				The configuration settings for a resource server (or client) can be exported and downloaded. You can also import an existing configuration file for a resource server. Importing and exporting a configuration file is helpful when you want to create an initial configuration for a resource server or to update an existing configuration. The configuration file contains definitions for:
			</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">
						Protected resources and scopes
					</li><li class="listitem">
						Policies
					</li><li class="listitem">
						Permissions
					</li></ul></div><section class="section" id="exporting_a_configuration_file"><div class="titlepage"><div><div><h3 class="title">3.4.1. Exporting a configuration file</h3></div></div></div><div class="orderedlist"><p class="title"><strong>Procedure</strong></p><ol class="orderedlist" type="1"><li class="listitem">
							Navigate to the <span class="strong strong"><strong>Resource Server Settings</strong></span> page.
						</li><li class="listitem">
							Click the <span class="strong strong"><strong>Export Settings</strong></span> tab.
						</li><li class="listitem"><p class="simpara">
							On this page, click <span class="strong strong"><strong>Export</strong></span>.
						</p><div class="formalpara"><p class="title"><strong>Export Settings</strong></p><p>
								<span class="inlinemediaobject"><img src="images/rhsso-images/resource-server/authz-export.png" alt="Export Settings"/></span>
							</p></div></li></ol></div><p>
					The configuration file is exported in JSON format and displayed in a text area, from which you can copy and paste. You can also click <span class="strong strong"><strong>Download</strong></span> to download the configuration file and save it.
				</p></section><section class="section" id="importing_a_configuration_file"><div class="titlepage"><div><div><h3 class="title">3.4.2. Importing a configuration file</h3></div></div></div><p>
					You can import a configuration file for a resource server.
				</p><div class="orderedlist"><p class="title"><strong>Procedure</strong></p><ol class="orderedlist" type="1"><li class="listitem"><p class="simpara">
							Navigate to the <span class="strong strong"><strong>Resource Server Settings</strong></span> page.
						</p><div class="formalpara"><p class="title"><strong>Import Settings</strong></p><p>
								<span class="inlinemediaobject"><img src="images/rhsso-images/resource-server/authz-settings.png" alt="Import Settings"/></span>
							</p></div></li><li class="listitem">
							Click <span class="strong strong"><strong>Select file</strong></span> and choose a file containing the configuration that you want to import.
						</li></ol></div></section></section></section><section class="chapter" id="resource_overview"><div class="titlepage"><div><div><h1 class="title">Chapter 4. Managing resources and scopes</h1></div></div></div><p>
			Resource management is straightforward and generic. After creating a resource server, you can start creating the resources and scopes that you want to protect. Resources and scopes can be managed by navigating to the <span class="strong strong"><strong>Resource</strong></span> and <span class="strong strong"><strong>Authorization Scopes</strong></span> tabs, respectively.
		</p><section class="section" id="resource_view"><div class="titlepage"><div><div><h2 class="title">4.1. Viewing resources</h2></div></div></div><p>
				On the <span class="strong strong"><strong>Resource</strong></span> page, you see a list of the resources associated with a resource server.
			</p><div class="formalpara"><p class="title"><strong>Resources</strong></p><p>
					<span class="inlinemediaobject"><img src="images/rhsso-images/resource/view.png" alt="Resources"/></span>
				</p></div><p>
				The resource list provides information about the protected resources, such as:
			</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">
						Type
					</li><li class="listitem">
						URIS
					</li><li class="listitem">
						Owner
					</li><li class="listitem">
						Associated scopes, if any
					</li><li class="listitem">
						Associated permissions
					</li></ul></div><p>
				From this list, you can also directly create a permission by clicking <span class="strong strong"><strong>Create Permission</strong></span> for the resource for which you want to create the permission.
			</p><div class="admonition note"><div class="admonition_header">Note</div><div><p>
					Before creating permissions for your resources, be sure you have already defined the policies that you want to associate with the permission.
				</p></div></div></section><section class="section" id="resource_create"><div class="titlepage"><div><div><h2 class="title">4.2. Creating resources</h2></div></div></div><p>
				Creating a resource is straightforward and generic. Your main concern is the granularity of the resources you create. In other words, resources can be created to represent a set of one or more resources and the way you define them is crucial to managing permissions.
			</p><p>
				To create a new resource, click <span class="strong strong"><strong>Create</strong></span> in the right upper corner of the resource listing.
			</p><div class="formalpara"><p class="title"><strong>Add Resource</strong></p><p>
					<span class="inlinemediaobject"><img src="images/rhsso-images/resource/create.png" alt="Add Resource"/></span>
				</p></div><p>
				In Red Hat Single Sign-On, a resource defines a small set of information that is common to different types of resources, such as:
			</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p class="simpara">
						<span class="strong strong"><strong>Name</strong></span>
					</p><p class="simpara">
						A human-readable and unique string describing this resource.
					</p></li></ul></div><div class="itemizedlist" id="resource_create_type"><ul class="itemizedlist" type="disc"><li class="listitem"><p class="simpara">
						<span class="strong strong"><strong>Type</strong></span>
					</p><p class="simpara">
						A string uniquely identifying the type of a set of one or more resources. The type is a <span class="emphasis"><em>string</em></span> used to group different resource instances. For example, the default type for the default resource that is automatically created is <code class="literal">urn:resource-server-name:resources:default</code>
					</p></li></ul></div><div class="itemizedlist" id="resource_create_uri"><ul class="itemizedlist" type="disc"><li class="listitem"><p class="simpara">
						<span class="strong strong"><strong>URIS</strong></span>
					</p><p class="simpara">
						URIS that provides the locations/addresses for the resource. For HTTP resources, the URIS are usually the relative paths used to serve these resources.
					</p></li><li class="listitem"><p class="simpara">
						<span class="strong strong"><strong>Scopes</strong></span>
					</p><p class="simpara">
						One or more scopes to associate with the resource.
					</p></li></ul></div><section class="section" id="resource_attributes"><div class="titlepage"><div><div><h3 class="title">4.2.1. Resource attributes</h3></div></div></div><p>
					Resources may have attributes associated with them. These attributes can be used to provide additional information about a resource and to provide additional information to policies when evaluating permissions associated with a resource.
				</p><p>
					Each attribute is a key and value pair where the value can be a set of one or many strings. Multiple values can be defined for an attribute by separating each value with a comma.
				</p></section><section class="section" id="typed_resources"><div class="titlepage"><div><div><h3 class="title">4.2.2. Typed resources</h3></div></div></div><p>
					The type field of a resource can be used to group different resources together, so they can be protected using a common set of permissions.
				</p></section><section class="section" id="resource_owners"><div class="titlepage"><div><div><h3 class="title">4.2.3. Resource owners</h3></div></div></div><p>
					Resources also have an owner. By default, resources are owned by the resource server.
				</p><p>
					However, resources can also be associated with users, so you can create permissions based on the resource owner. For example, only the resource owner is allowed to delete or update a given resource.
				</p></section><section class="section" id="managing_resources_remotely"><div class="titlepage"><div><div><h3 class="title">4.2.4. Managing resources remotely</h3></div></div></div><p>
					Resource management is also exposed through the <a class="link" href="#service_protection_api" title="8.4. Protection API">Protection API</a> to allow resource servers to remotely manage their resources.
				</p><p>
					When using the Protection API, resource servers can be implemented to manage resources owned by their users. In this case, you can specify the user identifier to configure a resource as belonging to a specific user.
				</p><div class="admonition note"><div class="admonition_header">Note</div><div><p>
						Red Hat Single Sign-On provides resource servers complete control over their resources. In the future, we should be able to allow users to control their own resources as well as approve authorization requests and manage permissions, especially when using the UMA protocol.
					</p></div></div></section></section></section><section class="chapter" id="policy_overview"><div class="titlepage"><div><div><h1 class="title">Chapter 5. Managing policies</h1></div></div></div><p>
			As mentioned previously, policies define the conditions that must be satisfied before granting access to an object.
		</p><div class="orderedlist"><p class="title"><strong>Procedure</strong></p><ol class="orderedlist" type="1"><li class="listitem"><p class="simpara">
					Click the <span class="strong strong"><strong>Policy</strong></span> tab to view all policies associated with a resource server.
				</p><div class="formalpara"><p class="title"><strong>Policies</strong></p><p>
						<span class="inlinemediaobject"><img src="images/rhsso-images/policy/view.png" alt="Policies"/></span>
					</p></div><p class="simpara">
					On this tab, you can view the list of previously created policies as well as create and edit a policy.
				</p></li><li class="listitem"><p class="simpara">
					To create a new policy, select a policy type from the <span class="strong strong"><strong>Create policy</strong></span> item list in the upper right corner.
				</p><p class="simpara">
					Details about each policy type are described in this section.
				</p></li></ol></div><section class="section" id="policy_user"><div class="titlepage"><div><div><h2 class="title">5.1. User-based policy</h2></div></div></div><p>
				You can use this type of policy to define conditions for your permissions where a set of one or more users is permitted to access an object.
			</p><p>
				To create a new user-based policy, select <span class="strong strong"><strong>User</strong></span> in the item list in the upper right corner of the policy listing.
			</p><div class="formalpara"><p class="title"><strong>Add a User-Based Policy</strong></p><p>
					<span class="inlinemediaobject"><img src="images/rhsso-images/policy/create-user.png" alt="Add User-Based Policy"/></span>
				</p></div><section class="section" id="configuration"><div class="titlepage"><div><div><h3 class="title">5.1.1. Configuration</h3></div></div></div><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p class="simpara">
							<span class="strong strong"><strong>Name</strong></span>
						</p><p class="simpara">
							A human-readable and unique string identifying the policy. A best practice is to use names that are closely related to your business and security requirements, so you can identify them more easily.
						</p></li><li class="listitem"><p class="simpara">
							<span class="strong strong"><strong>Description</strong></span>
						</p><p class="simpara">
							A string containing details about this policy.
						</p></li><li class="listitem"><p class="simpara">
							<span class="strong strong"><strong>Users</strong></span>
						</p><p class="simpara">
							Specifies which users are given access by this policy.
						</p></li><li class="listitem"><p class="simpara">
							<span class="strong strong"><strong>Logic</strong></span>
						</p><p class="simpara">
							The logic of this policy to apply after the other conditions have been evaluated.
						</p></li></ul></div><div class="itemizedlist _additional-resources"><p class="title"><strong>Additional resources</strong></p><ul class="itemizedlist _additional-resources" type="disc"><li class="listitem">
							<a class="link" href="#policy_logic" title="5.9. Positive and negative logic">Postive and negative logic</a>
						</li></ul></div></section></section><section class="section" id="policy_rbac"><div class="titlepage"><div><div><h2 class="title">5.2. Role-based policy</h2></div></div></div><p>
				You can use this type of policy to define conditions for your permissions where a set of one or more roles is permitted to access an object.
			</p><p>
				By default, roles added to this policy are not specified as required and the policy will grant access if the user requesting access has been granted any of these roles. However, you can specify a specific role as <a class="link" href="#policy_rbac_required" title="5.2.2. Defining a role as required">required</a> if you want to enforce a specific role. You can also combine required and non-required roles, regardless of whether they are realm or client roles.
			</p><p>
				Role policies can be useful when you need more restricted role-based access control (RBAC), where specific roles must be enforced to grant access to an object. For instance, you can enforce that a user must consent to allowing a client application (which is acting on the user’s behalf) to access the user’s resources. You can use Red Hat Single Sign-On Client Scope Mapping to enable consent pages or even enforce clients to explicitly provide a scope when obtaining access tokens from a Red Hat Single Sign-On server.
			</p><p>
				To create a new role-based policy, select <span class="strong strong"><strong>Role</strong></span> in the item list in the upper right corner of the policy listing.
			</p><div class="formalpara"><p class="title"><strong>Add Role-Based Policy</strong></p><p>
					<span class="inlinemediaobject"><img src="images/rhsso-images/policy/create-role.png" alt="Add Role-Based Policy"/></span>
				</p></div><section class="section" id="configuration_2"><div class="titlepage"><div><div><h3 class="title">5.2.1. Configuration</h3></div></div></div><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p class="simpara">
							<span class="strong strong"><strong>Name</strong></span>
						</p><p class="simpara">
							A human-readable and unique string describing the policy. A best practice is to use names that are closely related to your business and security requirements, so you can identify them more easily.
						</p></li><li class="listitem"><p class="simpara">
							<span class="strong strong"><strong>Description</strong></span>
						</p><p class="simpara">
							A string containing details about this policy.
						</p></li><li class="listitem"><p class="simpara">
							<span class="strong strong"><strong>Realm Roles</strong></span>
						</p><p class="simpara">
							Specifies which <span class="strong strong"><strong>realm</strong></span> roles are permitted by this policy.
						</p></li><li class="listitem"><p class="simpara">
							<span class="strong strong"><strong>Client Roles</strong></span>
						</p><p class="simpara">
							Specifies which <span class="strong strong"><strong>client</strong></span> roles are permitted by this policy. To enable this field must first select a <code class="literal">Client</code>.
						</p></li><li class="listitem"><p class="simpara">
							<span class="strong strong"><strong>Logic</strong></span>
						</p><p class="simpara">
							The logic of this policy to apply after the other conditions have been evaluated.
						</p></li></ul></div><div class="itemizedlist _additional-resources"><p class="title"><strong>Additional resources</strong></p><ul class="itemizedlist _additional-resources" type="disc"><li class="listitem">
							<a class="link" href="#policy_logic" title="5.9. Positive and negative logic">Postive and negative logic</a>
						</li></ul></div></section><section class="section" id="policy_rbac_required"><div class="titlepage"><div><div><h3 class="title">5.2.2. Defining a role as required</h3></div></div></div><p>
					When creating a role-based policy, you can specify a specific role as <code class="literal">Required</code>. When you do that, the policy will grant access only if the user requesting access has been granted <span class="strong strong"><strong>all</strong></span> the <span class="strong strong"><strong>required</strong></span> roles. Both realm and client roles can be configured as such.
				</p><div class="formalpara"><p class="title"><strong>Example of a required role</strong></p><p>
						<span class="inlinemediaobject"><img src="images/rhsso-images/policy/create-role.png" alt="Example of a required role"/></span>
					</p></div><p>
					To specify a role as required, select the <code class="literal">Required</code> checkbox for the role you want to configure as required.
				</p><p>
					Required roles can be useful when your policy defines multiple roles but only a subset of them are mandatory. In this case, you can combine realm and client roles to enable an even more fine-grained role-based access control (RBAC) model for your application. For example, you can have policies specific for a client and require a specific client role associated with that client. Or you can enforce that access is granted only in the presence of a specific realm role. You can also combine both approaches within the same policy.
				</p></section></section><section class="section" id="policy_js"><div class="titlepage"><div><div><h2 class="title">5.3. JavaScript-based policy</h2></div></div></div><div class="admonition warning"><div class="admonition_header">Warning</div><div><p>
					If your policy implementation is using Attribute based access control (ABAC) as in the examples below, then please make sure that users are not able to edit the protected attributes and the corresponding attributes are read-only. See the details in the <a class="link" href="https://access.redhat.com/documentation/en-us/red_hat_single_sign-on/7.4/html-single/server_administration_guide/#_read_only_user_attributes">Threat model mitigation chapter</a>.
				</p></div></div><p>
				You can use this type of policy to define conditions for your permissions using JavaScript. It is one of the rule-based policy types supported by Red Hat Single Sign-On, and provides flexibility to write any policy based on the <a class="link" href="#policy_evaluation_api" title="5.10. Policy evaluation API">Evaluation API</a>.
			</p><p>
				To create a new JavaScript-based policy, select <span class="strong strong"><strong>JavaScript</strong></span> in the item list in the upper right corner of the policy listing.
			</p><div class="admonition note"><div class="admonition_header">Note</div><div><p>
					By default, JavaScript Policies can not be uploaded to the server. You should prefer deploying your JS Policies directly to the server as described in <a class="link" href="https://access.redhat.com/documentation/en-us/red_hat_single_sign-on/7.4/html-single/server_developer_guide/#_script_providers">JavaScript Providers</a>. If you still want to use the Red Hat Single Sign-On Administration Console to manage your JS policies you should enable the <code class="literal">Upload Scripts</code> feature.
				</p></div></div><div class="formalpara"><p class="title"><strong>Add JavaScript Policy</strong></p><p>
					<span class="inlinemediaobject"><img src="images/rhsso-images/policy/create-js.png" alt="Add JavaScript Policy"/></span>
				</p></div><section class="section" id="configuration_3"><div class="titlepage"><div><div><h3 class="title">5.3.1. Configuration</h3></div></div></div><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p class="simpara">
							<span class="strong strong"><strong>Name</strong></span>
						</p><p class="simpara">
							A human-readable and unique string describing the policy. A best practice is to use names that are closely related to your business and security requirements, so you can identify them more easily.
						</p></li><li class="listitem"><p class="simpara">
							<span class="strong strong"><strong>Description</strong></span>
						</p><p class="simpara">
							A string containing details about this policy.
						</p></li><li class="listitem"><p class="simpara">
							<span class="strong strong"><strong>Code</strong></span>
						</p><p class="simpara">
							The JavaScript code providing the conditions for this policy.
						</p></li><li class="listitem"><p class="simpara">
							<span class="strong strong"><strong>Logic</strong></span>
						</p><p class="simpara">
							The logic of this policy to apply after the other conditions have been evaluated.
						</p></li></ul></div><div class="itemizedlist _additional-resources"><p class="title"><strong>Additional resources</strong></p><ul class="itemizedlist _additional-resources" type="disc"><li class="listitem">
							<a class="link" href="#policy_logic" title="5.9. Positive and negative logic">Postive and negative logic</a>
						</li></ul></div></section><section class="section" id="creating_a_js_policy_from_a_deployed_jar_file"><div class="titlepage"><div><div><h3 class="title">5.3.2. Creating a JS policy from a deployed JAR file</h3></div></div></div><p>
					Red Hat Single Sign-On allows you to deploy a JAR file in order to deploy scripts to the server. Please, take a look at <a class="link" href="https://access.redhat.com/documentation/en-us/red_hat_single_sign-on/7.4/html-single/server_developer_guide/#_script_providers">JavaScript Providers</a> for more details.
				</p><p>
					Once you have your scripts deployed, you should be able to select the scripts you deployed from the list of available policy providers.
				</p></section><section class="section" id="examples"><div class="titlepage"><div><div><h3 class="title">5.3.3. Examples</h3></div></div></div><section class="section" id="checking_for_attributes_from_the_evaluation_context"><div class="titlepage"><div><div><h4 class="title">5.3.3.1. Checking for attributes from the evaluation context</h4></div></div></div><p>
						Here is a simple example of a JavaScript-based policy that uses attribute-based access control (ABAC) to define a condition based on an attribute obtained from the execution context:
					</p><pre class="programlisting language-javascript">var context = $evaluation.getContext();
var contextAttributes = context.getAttributes();

if (contextAttributes.containsValue('kc.client.network.ip_address', '127.0.0.1')) {
    $evaluation.grant();
}</pre></section><section class="section" id="checking_for_attributes_from_the_current_identity"><div class="titlepage"><div><div><h4 class="title">5.3.3.2. Checking for attributes from the current identity</h4></div></div></div><p>
						Here is a simple example of a JavaScript-based policy that uses attribute-based access control (ABAC) to define a condition based on an attribute obtained associated with the current identity:
					</p><pre class="programlisting language-javascript">var context = $evaluation.getContext();
var identity = context.getIdentity();
var attributes = identity.getAttributes();
var email = attributes.getValue('email').asString(0);

if (email.endsWith('@keycloak.org')) {
    $evaluation.grant();
}</pre><p>
						Where these attributes are mapped from whatever claim is defined in the token that was used in the authorization request.
					</p></section><section class="section" id="checking_for_roles_granted_to_the_current_identity"><div class="titlepage"><div><div><h4 class="title">5.3.3.3. Checking for roles granted to the current identity</h4></div></div></div><p>
						You can also use Role-Based Access Control (RBAC) in your policies. In the example below, we check if a user is granted with a <code class="literal">keycloak_user</code> <span class="strong strong"><strong>realm</strong></span> role:
					</p><pre class="programlisting language-javascript">var context = $evaluation.getContext();
var identity = context.getIdentity();

if (identity.hasRealmRole('keycloak_user')) {
    $evaluation.grant();
}</pre><p>
						Or you can check if a user is granted with a <code class="literal">my-client-role</code> <span class="strong strong"><strong>client</strong></span> role, where <code class="literal">my-client</code> is the client id of the client application:
					</p><pre class="programlisting language-javascript">var context = $evaluation.getContext();
var identity = context.getIdentity();

if (identity.hasClientRole('my-client', 'my-client-role')) {
    $evaluation.grant();
}</pre></section><section class="section" id="checking_for_roles_granted_to_an_user"><div class="titlepage"><div><div><h4 class="title">5.3.3.4. Checking for roles granted to an user</h4></div></div></div><p>
						To check for realm roles granted to an user:
					</p><pre class="programlisting language-javascript">var realm = $evaluation.getRealm();

if (realm.isUserInRealmRole('marta', 'role-a')) {
    $evaluation.grant();
}</pre><p>
						Or for client roles granted to an user:
					</p><pre class="programlisting language-javascript">var realm = $evaluation.getRealm();

if (realm.isUserInClientRole('marta', 'my-client', 'some-client-role')) {
    $evaluation.grant();
}</pre></section><section class="section" id="checking_for_roles_granted_to_a_group"><div class="titlepage"><div><div><h4 class="title">5.3.3.5. Checking for roles granted to a group</h4></div></div></div><p>
						To check for realm roles granted to a group:
					</p><pre class="programlisting language-javascript">var realm = $evaluation.getRealm();

if (realm.isGroupInRole('/Group A/Group D', 'role-a')) {
    $evaluation.grant();
}</pre></section><section class="section" id="pushing_arbitrary_claims_to_the_resource_server"><div class="titlepage"><div><div><h4 class="title">5.3.3.6. Pushing arbitrary claims to the resource server</h4></div></div></div><p>
						To push arbitrary claims to the resource server in order to provide additional information on how permissions should be enforced:
					</p><pre class="programlisting language-javascript">var permission = $evaluation.getPermission();

// decide if permission should be granted

if (granted) {
    permission.addClaim('claim-a', 'claim-a');
    permission.addClaim('claim-a', 'claim-a1');
    permission.addClaim('claim-b', 'claim-b');
}</pre></section><section class="section" id="checking_for_group_membership"><div class="titlepage"><div><div><h4 class="title">5.3.3.7. Checking for group membership</h4></div></div></div><pre class="programlisting language-javascript">var realm = $evaluation.getRealm();

if (realm.isUserInGroup('marta', '/Group A/Group B')) {
    $evaluation.grant();
}</pre></section><section class="section" id="mixing_different_access_control_mechanisms"><div class="titlepage"><div><div><h4 class="title">5.3.3.8. Mixing different access control mechanisms</h4></div></div></div><p>
						You can also use a combination of several access control mechanisms. The example below shows how roles(RBAC) and claims/attributes(ABAC) checks can be used within the same policy. In this case we check if user is granted with <code class="literal">admin</code> role or has an e-mail from <code class="literal">keycloak.org</code> domain:
					</p><pre class="programlisting language-javascript">var context = $evaluation.getContext();
var identity = context.getIdentity();
var attributes = identity.getAttributes();
var email = attributes.getValue('email').asString(0);

if (identity.hasRealmRole('admin') || email.endsWith('@keycloak.org')) {
    $evaluation.grant();
}</pre><div class="admonition note"><div class="admonition_header">Note</div><div><p>
							When writing your own rules, keep in mind that the <span class="strong strong"><strong>$evaluation</strong></span> object is an object implementing <span class="strong strong"><strong>org.keycloak.authorization.policy.evaluation.Evaluation</strong></span>. For more information about what you can access from this interface, see the <a class="link" href="#policy_evaluation_api" title="5.10. Policy evaluation API">Evaluation API</a>.
						</p></div></div></section></section></section><section class="section" id="policy_time"><div class="titlepage"><div><div><h2 class="title">5.4. Time-based policy</h2></div></div></div><p>
				You can use this type of policy to define time conditions for your permissions.
			</p><p>
				To create a new time-based policy, select <span class="strong strong"><strong>Time</strong></span> in the item list in the upper right corner of the policy listing.
			</p><div class="formalpara"><p class="title"><strong>Add time policy</strong></p><p>
					<span class="inlinemediaobject"><img src="images/rhsso-images/policy/create-time.png" alt="Add Time Policy"/></span>
				</p></div><section class="section" id="configuration_4"><div class="titlepage"><div><div><h3 class="title">5.4.1. Configuration</h3></div></div></div><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p class="simpara">
							<span class="strong strong"><strong>Name</strong></span>
						</p><p class="simpara">
							A human-readable and unique string describing the policy. A best practice is to use names that are closely related to your business and security requirements, so you can identify them more easily.
						</p></li><li class="listitem"><p class="simpara">
							<span class="strong strong"><strong>Description</strong></span>
						</p><p class="simpara">
							A string containing details about this policy.
						</p></li><li class="listitem"><p class="simpara">
							<span class="strong strong"><strong>Not Before</strong></span>
						</p><p class="simpara">
							Defines the time before which access must <span class="strong strong"><strong>not</strong></span> be granted. Permission is granted only if the current date/time is later than or equal to this value.
						</p></li><li class="listitem"><p class="simpara">
							<span class="strong strong"><strong>Not On or After</strong></span>
						</p><p class="simpara">
							Defines the time after which access must <span class="strong strong"><strong>not</strong></span> be granted. Permission is granted only if the current date/time is earlier than or equal to this value.
						</p></li><li class="listitem"><p class="simpara">
							<span class="strong strong"><strong>Day of Month</strong></span>
						</p><p class="simpara">
							Defines the day of month that access must be granted. You can also specify a range of dates. In this case, permission is granted only if the current day of the month is between or equal to the two values specified.
						</p></li><li class="listitem"><p class="simpara">
							<span class="strong strong"><strong>Month</strong></span>
						</p><p class="simpara">
							Defines the month that access must be granted. You can also specify a range of months. In this case, permission is granted only if the current month is between or equal to the two values specified.
						</p></li><li class="listitem"><p class="simpara">
							<span class="strong strong"><strong>Year</strong></span>
						</p><p class="simpara">
							Defines the year that access must be granted. You can also specify a range of years. In this case, permission is granted only if the current year is between or equal to the two values specified.
						</p></li><li class="listitem"><p class="simpara">
							<span class="strong strong"><strong>Hour</strong></span>
						</p><p class="simpara">
							Defines the hour that access must be granted. You can also specify a range of hours. In this case, permission is granted only if current hour is between or equal to the two values specified.
						</p></li><li class="listitem"><p class="simpara">
							<span class="strong strong"><strong>Minute</strong></span>
						</p><p class="simpara">
							Defines the minute that access must be granted. You can also specify a range of minutes. In this case, permission is granted only if the current minute is between or equal to the two values specified.
						</p></li><li class="listitem"><p class="simpara">
							<span class="strong strong"><strong>Logic</strong></span>
						</p><p class="simpara">
							The logic of this policy to apply after the other conditions have been evaluated.
						</p></li></ul></div><p>
					Access is only granted if all conditions are satisfied. Red Hat Single Sign-On will perform an <span class="emphasis"><em>AND</em></span> based on the outcome of each condition.
				</p><div class="itemizedlist _additional-resources"><p class="title"><strong>Additional resources</strong></p><ul class="itemizedlist _additional-resources" type="disc"><li class="listitem">
							<a class="link" href="#policy_logic" title="5.9. Positive and negative logic">Postive and negative logic</a>
						</li></ul></div></section></section><section class="section" id="policy_aggregated"><div class="titlepage"><div><div><h2 class="title">5.5. Aggregated policy</h2></div></div></div><p>
				As mentioned previously, Red Hat Single Sign-On allows you to build a policy of policies, a concept referred to as policy aggregation. You can use policy aggregation to reuse existing policies to build more complex ones and keep your permissions even more decoupled from the policies that are evaluated during the processing of authorization requests.
			</p><p>
				To create a new aggregated policy, select <span class="strong strong"><strong>Aggregated</strong></span> in the item list located in the right upper corner of the policy listing.
			</p><div class="formalpara"><p class="title"><strong>Add an Aggregated Policy</strong></p><p>
					<span class="inlinemediaobject"><img src="images/rhsso-images/policy/create-aggregated.png" alt="Add Aggregated Policy"/></span>
				</p></div><p>
				Let’s suppose you have a resource called <span class="emphasis"><em>Confidential Resource</em></span> that can be accessed only by users from the <span class="emphasis"><em>keycloak.org</em></span> domain and from a certain range of IP addresses. You can create a single policy with both conditions. However, you want to reuse the domain part of this policy to apply to permissions that operates regardless of the originating network.
			</p><p>
				You can create separate policies for both domain and network conditions and create a third policy based on the combination of these two policies. With an aggregated policy, you can freely combine other policies and then apply the new aggregated policy to any permission you want.
			</p><div class="admonition note"><div class="admonition_header">Note</div><div><p>
					When creating aggregated policies, be mindful that you are not introducing a circular reference or dependency between policies. If a circular dependency is detected, you cannot create or update the policy.
				</p></div></div><section class="section" id="configuration_5"><div class="titlepage"><div><div><h3 class="title">5.5.1. Configuration</h3></div></div></div><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p class="simpara">
							<span class="strong strong"><strong>Name</strong></span>
						</p><p class="simpara">
							A human-readable and unique string describing the policy. We strongly suggest that you use names that are closely related with your business and security requirements, so you can identify them more easily and also know what they mean.
						</p></li><li class="listitem"><p class="simpara">
							<span class="strong strong"><strong>Description</strong></span>
						</p><p class="simpara">
							A string with more details about this policy.
						</p></li><li class="listitem"><p class="simpara">
							<span class="strong strong"><strong>Apply Policy</strong></span>
						</p><p class="simpara">
							Defines a set of one or more policies to associate with the aggregated policy. To associate a policy you can either select an existing policy or create a new one by selecting the type of the policy you want to create.
						</p></li><li class="listitem"><p class="simpara">
							<span class="strong strong"><strong>Decision Strategy</strong></span>
						</p><p class="simpara">
							The decision strategy for this permission.
						</p></li><li class="listitem"><p class="simpara">
							<span class="strong strong"><strong>Logic</strong></span>
						</p><p class="simpara">
							The logic of this policy to apply after the other conditions have been evaluated.
						</p></li></ul></div><div class="itemizedlist _additional-resources"><p class="title"><strong>Additional resources</strong></p><ul class="itemizedlist _additional-resources" type="disc"><li class="listitem">
							<a class="link" href="#policy_logic" title="5.9. Positive and negative logic">Postive and negative logic</a>
						</li></ul></div></section><section class="section" id="decision_strategy_for_aggregated_policies"><div class="titlepage"><div><div><h3 class="title">5.5.2. Decision strategy for aggregated policies</h3></div></div></div><p>
					When creating aggregated policies, you can also define the decision strategy that will be used to determine the final decision based on the outcome from each policy.
				</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p class="simpara">
							<span class="strong strong"><strong>Unanimous</strong></span>
						</p><p class="simpara">
							The default strategy if none is provided. In this case, <span class="emphasis"><em>all</em></span> policies must evaluate to a positive decision for the final decision to be also positive.
						</p></li><li class="listitem"><p class="simpara">
							<span class="strong strong"><strong>Affirmative</strong></span>
						</p><p class="simpara">
							In this case, <span class="emphasis"><em>at least one</em></span> policy must evaluate to a positive decision in order for the final decision to be also positive.
						</p></li><li class="listitem"><p class="simpara">
							<span class="strong strong"><strong>Consensus</strong></span>
						</p><p class="simpara">
							In this case, the number of positive decisions must be greater than the number of negative decisions. If the number of positive and negative decisions is the same, the final decision will be negative.
						</p></li></ul></div></section></section><section class="section" id="policy_client"><div class="titlepage"><div><div><h2 class="title">5.6. Client-based policy</h2></div></div></div><p>
				You can use this type of policy to define conditions for your permissions where a set of one or more clients is permitted to access an object.
			</p><p>
				To create a new client-based policy, select <span class="strong strong"><strong>Client</strong></span> in the item list in the upper right corner of the policy listing.
			</p><div class="formalpara"><p class="title"><strong>Add a Client-Based Policy</strong></p><p>
					<span class="inlinemediaobject"><img src="images/policy/create-client.png" alt="Add Client-Based Policy"/></span>
				</p></div><section class="section" id="configuration_6"><div class="titlepage"><div><div><h3 class="title">5.6.1. Configuration</h3></div></div></div><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p class="simpara">
							<span class="strong strong"><strong>Name</strong></span>
						</p><p class="simpara">
							A human-readable and unique string identifying the policy. A best practice is to use names that are closely related to your business and security requirements, so you can identify them more easily.
						</p></li><li class="listitem"><p class="simpara">
							<span class="strong strong"><strong>Description</strong></span>
						</p><p class="simpara">
							A string containing details about this policy.
						</p></li><li class="listitem"><p class="simpara">
							<span class="strong strong"><strong>Clients</strong></span>
						</p><p class="simpara">
							Specifies which clients are given access by this policy.
						</p></li><li class="listitem"><p class="simpara">
							<span class="strong strong"><strong>Logic</strong></span>
						</p><p class="simpara">
							The logic of this policy to apply after the other conditions have been evaluated.
						</p></li></ul></div><div class="itemizedlist _additional-resources"><p class="title"><strong>Additional resources</strong></p><ul class="itemizedlist _additional-resources" type="disc"><li class="listitem">
							<a class="link" href="#policy_logic" title="5.9. Positive and negative logic">Postive and negative logic</a>
						</li></ul></div></section></section><section class="section" id="policy_group"><div class="titlepage"><div><div><h2 class="title">5.7. Group-based policy</h2></div></div></div><p>
				You can use this type of policy to define conditions for your permissions where a set of one or more groups (and their hierarchies) is permitted to access an object.
			</p><p>
				To create a new group-based policy, select <span class="strong strong"><strong>Group</strong></span> in the item list in the upper right corner of the policy listing.
			</p><p>
				Group-Based Policy 
				<span class="inlinemediaobject"><img src="images/rhsso-images/policy/create-group.png" alt="Add group-based policy"/></span>
			</p><section class="section" id="configuration_7"><div class="titlepage"><div><div><h3 class="title">5.7.1. Configuration</h3></div></div></div><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p class="simpara">
							<span class="strong strong"><strong>Name</strong></span>
						</p><p class="simpara">
							A human-readable and unique string describing the policy. A best practice is to use names that are closely related to your business and security requirements, so you can identify them more easily.
						</p></li><li class="listitem"><p class="simpara">
							<span class="strong strong"><strong>Description</strong></span>
						</p><p class="simpara">
							A string containing details about this policy.
						</p></li><li class="listitem"><p class="simpara">
							<span class="strong strong"><strong>Groups Claim</strong></span>
						</p><p class="simpara">
							Specifies the name of the claim in the token holding the group names and/or paths. Usually, authorization requests are processed based on an ID Token or Access Token previously issued to a client acting on behalf of some user. If defined, the token must include a claim from where this policy is going to obtain the groups the user is a member of. If not defined, user’s groups are obtained from your realm configuration.
						</p></li><li class="listitem"><p class="simpara">
							<span class="strong strong"><strong>Groups</strong></span>
						</p><p class="simpara">
							Allows you to select the groups that should be enforced by this policy when evaluating permissions. After adding a group, you can extend access to children of the group by marking the checkbox <span class="strong strong"><strong>Extend to Children</strong></span>. If left unmarked, access restrictions only applies to the selected group.
						</p></li><li class="listitem"><p class="simpara">
							<span class="strong strong"><strong>Logic</strong></span>
						</p><p class="simpara">
							The logic of this policy to apply after the other conditions have been evaluated.
						</p></li></ul></div><div class="itemizedlist _additional-resources"><p class="title"><strong>Additional resources</strong></p><ul class="itemizedlist _additional-resources" type="disc"><li class="listitem">
							<a class="link" href="#policy_logic" title="5.9. Positive and negative logic">Postive and negative logic</a>
						</li></ul></div></section><section class="section" id="policy_group_extend_access_children"><div class="titlepage"><div><div><h3 class="title">5.7.2. Extending access to child groups</h3></div></div></div><p>
					By default, when you add a group to this policy, access restrictions will only apply to members of the selected group.
				</p><p>
					Under some circumstances, it might be necessary to allow access not only to the group itself but to any child group in the hierarchy. For any group added you can mark a checkbox <span class="strong strong"><strong>Extend to Children</strong></span> in order to extend access to child groups.
				</p><div class="formalpara"><p class="title"><strong>Extending Access to Child Groups</strong></p><p>
						<span class="inlinemediaobject"><img src="images/rhsso-images/policy/create-group-extend-children.png" alt="Extending Access to Child Groups"/></span>
					</p></div><p>
					In the example above, the policy is granting access for any user member of <span class="strong strong"><strong>IT</strong></span> or any of its children.
				</p></section></section><section class="section" id="policy_client_scope"><div class="titlepage"><div><div><h2 class="title">5.8. Client scope-based policy</h2></div></div></div><p>
				You can use this type of policy to define conditions for your permissions where a set of one or more client scopes is permitted to access an object.
			</p><p>
				By default, client scopes added to this policy are not specified as required and the policy will grant access if the client requesting access has been granted any of these client scopes. However, you can specify a specific client scope as <a class="link" href="#policy_client_scope_required" title="5.8.2. Defining a client scope as required">required</a> if you want to enforce a specific client scope.
			</p><p>
				To create a new client scope-based policy, select <span class="strong strong"><strong>Client Scope</strong></span> in the item list in the upper right corner of the policy listing.
			</p><div class="formalpara"><p class="title"><strong>Add Client Scope-Based Policy</strong></p><p>
					<span class="inlinemediaobject"><img src="images/policy/create-client-scope.png" alt="Add Client Scope-Based Policy"/></span>
				</p></div><section class="section" id="configuration_8"><div class="titlepage"><div><div><h3 class="title">5.8.1. Configuration</h3></div></div></div><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p class="simpara">
							<span class="strong strong"><strong>Name</strong></span>
						</p><p class="simpara">
							A human-readable and unique string describing the policy. A best practice is to use names that are closely related to your business and security requirements, so you can identify them more easily.
						</p></li><li class="listitem"><p class="simpara">
							<span class="strong strong"><strong>Description</strong></span>
						</p><p class="simpara">
							A string containing details about this policy.
						</p></li><li class="listitem"><p class="simpara">
							<span class="strong strong"><strong>Client Scopes</strong></span>
						</p><p class="simpara">
							Specifies which client scopes are permitted by this policy.
						</p></li><li class="listitem"><p class="simpara">
							<span class="strong strong"><strong>Logic</strong></span>
						</p><p class="simpara">
							The logic of this policy to apply after the other conditions have been evaluated.
						</p></li></ul></div><div class="itemizedlist _additional-resources"><p class="title"><strong>Additional resources</strong></p><ul class="itemizedlist _additional-resources" type="disc"><li class="listitem">
							<a class="link" href="#policy_logic" title="5.9. Positive and negative logic">Postive and negative logic</a>
						</li></ul></div></section><section class="section" id="policy_client_scope_required"><div class="titlepage"><div><div><h3 class="title">5.8.2. Defining a client scope as required</h3></div></div></div><p>
					When creating a client scope-based policy, you can specify a specific client scope as <code class="literal">Required</code>. When you do that, the policy will grant access only if the client requesting access has been granted <span class="strong strong"><strong>all</strong></span> the <span class="strong strong"><strong>required</strong></span> client scopes.
				</p><div class="formalpara"><p class="title"><strong>Example of Required Client Scope</strong></p><p>
						<span class="inlinemediaobject"><img src="images/policy/create-client-scope.png" alt="Example of Required Client Scope"/></span>
					</p></div><p>
					To specify a client scope as required, select the <code class="literal">Required</code> checkbox for the client scope you want to configure as required.
				</p><p>
					Required client scopes can be useful when your policy defines multiple client scopes but only a subset of them are mandatory.
				</p></section></section><section class="section" id="policy_logic"><div class="titlepage"><div><div><h2 class="title">5.9. Positive and negative logic</h2></div></div></div><p>
				Policies can be configured with positive or negative logic. Briefly, you can use this option to define whether the policy result should be kept as it is or be negated.
			</p><p>
				For example, suppose you want to create a policy where only users <span class="strong strong"><strong>not</strong></span> granted with a specific role should be given access. In this case, you can create a role-based policy using that role and set its <span class="strong strong"><strong>Logic</strong></span> field to <span class="strong strong"><strong>Negative</strong></span>. If you keep <span class="strong strong"><strong>Positive</strong></span>, which is the default behavior, the policy result will be kept as it is.
			</p></section><section class="section" id="policy_evaluation_api"><div class="titlepage"><div><div><h2 class="title">5.10. Policy evaluation API</h2></div></div></div><p>
				When writing rule-based policies using JavaScript, Red Hat Single Sign-On provides an Evaluation API that provides useful information to help determine whether a permission should be granted.
			</p><p>
				This API consists of a few interfaces that provide you access to information, such as
			</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">
						The permission being evaluated, representing both the resource and scopes being requested.
					</li><li class="listitem">
						The attributes associated with the resource being requested
					</li><li class="listitem">
						Runtime environment and any other attribute associated with the execution context
					</li><li class="listitem">
						Information about users such as group membership and roles
					</li></ul></div><p>
				The main interface is <span class="strong strong"><strong>org.keycloak.authorization.policy.evaluation.Evaluation</strong></span>, which defines the following contract:
			</p><pre class="programlisting language-java">public interface Evaluation {

    /**
     * Returns the {@link ResourcePermission} to be evaluated.
     *
     * @return the permission to be evaluated
     */
    ResourcePermission getPermission();

    /**
     * Returns the {@link EvaluationContext}. Which provides access to the whole evaluation runtime context.
     *
     * @return the evaluation context
     */
    EvaluationContext getContext();

    /**
     * Returns a {@link Realm} that can be used by policies to query information.
     *
     * @return a {@link Realm} instance
     */
    Realm getRealm();

    /**
     * Grants the requested permission to the caller.
     */
    void grant();

    /**
     * Denies the requested permission.
     */
    void deny();
}</pre><p>
				When processing an authorization request, Red Hat Single Sign-On creates an <code class="literal">Evaluation</code> instance before evaluating any policy. This instance is then passed to each policy to determine whether access is <span class="strong strong"><strong>GRANT</strong></span> or <span class="strong strong"><strong>DENY</strong></span>.
			</p><p>
				Policies determine this by invoking the <code class="literal">grant()</code> or <code class="literal">deny()</code> methods on an <code class="literal">Evaluation</code> instance. By default, the state of the <code class="literal">Evaluation</code> instance is denied, which means that your policies must explicitly invoke the <code class="literal">grant()</code> method to indicate to the policy evaluation engine that permission should be granted.
			</p><p>
				For more information about the Evaluation API see the <a class="link" href="https://access.redhat.com/documentation/en-us/red_hat_single_sign-on/7.4/html-single/api_documentation/index">JavaDocs</a>.
			</p><section class="section" id="the_evaluation_context"><div class="titlepage"><div><div><h3 class="title">5.10.1. The evaluation context</h3></div></div></div><p>
					The evaluation context provides useful information to policies during their evaluation.
				</p><pre class="programlisting language-java">public interface EvaluationContext {

    /**
     * Returns the {@link Identity} that represents an entity (person or non-person) to which the permissions must be granted, or not.
     *
     * @return the identity to which the permissions must be granted, or not
     */
    Identity getIdentity();

    /**
     * Returns all attributes within the current execution and runtime environment.
     *
     * @return the attributes within the current execution and runtime environment
     */
    Attributes getAttributes();
}</pre><p>
					From this interface, policies can obtain:
				</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">
							The authenticated <code class="literal">Identity</code>
						</li><li class="listitem">
							Information about the execution context and runtime environment
						</li></ul></div><p>
					The <code class="literal">Identity</code> is built based on the OAuth2 Access Token that was sent along with the authorization request, and this construct has access to all claims extracted from the original token. For example, if you are using a <span class="emphasis"><em>Protocol Mapper</em></span> to include a custom claim in an OAuth2 Access Token you can also access this claim from a policy and use it to build your conditions.
				</p><p>
					The <code class="literal">EvaluationContext</code> also gives you access to attributes related to both the execution and runtime environments. For now, there only a few built-in attributes.
				</p><div class="table" id="idm139768732569936"><p class="title"><strong>Table 5.1. Execution and Runtime Attributes</strong></p><div class="table-contents"><table class="lt-4-cols lt-7-rows"><colgroup><col style="width: 33%; " class="col_1"/><col style="width: 33%; " class="col_2"/><col style="width: 33%; " class="col_3"/></colgroup><thead><tr><th align="left" valign="top" id="idm139768732564160" scope="col">Name</th><th align="left" valign="top" id="idm139768732563072" scope="col">Description</th><th align="left" valign="top" id="idm139768732561984" scope="col">Type</th></tr></thead><tbody><tr><td align="left" valign="top" headers="idm139768732564160">
								<p>
									kc.time.date_time
								</p>
								</td><td align="left" valign="top" headers="idm139768732563072">
								<p>
									Current date and time
								</p>
								</td><td align="left" valign="top" headers="idm139768732561984">
								<p>
									String. Format <code class="literal">MM/dd/yyyy hh:mm:ss</code>
								</p>
								</td></tr><tr><td align="left" valign="top" headers="idm139768732564160">
								<p>
									kc.client.network.ip_address
								</p>
								</td><td align="left" valign="top" headers="idm139768732563072">
								<p>
									IPv4 address of the client
								</p>
								</td><td align="left" valign="top" headers="idm139768732561984">
								<p>
									String
								</p>
								</td></tr><tr><td align="left" valign="top" headers="idm139768732564160">
								<p>
									kc.client.network.host
								</p>
								</td><td align="left" valign="top" headers="idm139768732563072">
								<p>
									Client’s host name
								</p>
								</td><td align="left" valign="top" headers="idm139768732561984">
								<p>
									String
								</p>
								</td></tr><tr><td align="left" valign="top" headers="idm139768732564160">
								<p>
									kc.client.id
								</p>
								</td><td align="left" valign="top" headers="idm139768732563072">
								<p>
									The client id
								</p>
								</td><td align="left" valign="top" headers="idm139768732561984">
								<p>
									String
								</p>
								</td></tr><tr><td align="left" valign="top" headers="idm139768732564160">
								<p>
									kc.client.user_agent
								</p>
								</td><td align="left" valign="top" headers="idm139768732563072">
								<p>
									The value of the 'User-Agent' HTTP header
								</p>
								</td><td align="left" valign="top" headers="idm139768732561984">
								<p>
									String[]
								</p>
								</td></tr><tr><td align="left" valign="top" headers="idm139768732564160">
								<p>
									kc.realm.name
								</p>
								</td><td align="left" valign="top" headers="idm139768732563072">
								<p>
									The name of the realm
								</p>
								</td><td align="left" valign="top" headers="idm139768732561984">
								<p>
									String
								</p>
								</td></tr></tbody></table></div></div></section></section></section><section class="chapter" id="permission_overview"><div class="titlepage"><div><div><h1 class="title">Chapter 6. Managing permissions</h1></div></div></div><p>
			A permission associates the object being protected and the policies that must be evaluated to decide whether access should be granted.
		</p><p>
			After creating the resources you want to protect and the policies you want to use to protect these resources, you can start managing permissions. To manage permissions, click the <span class="strong strong"><strong>Permissions</strong></span> tab when editing a resource server.
		</p><div class="formalpara"><p class="title"><strong>Permissions</strong></p><p>
				<span class="inlinemediaobject"><img src="images/rhsso-images/permission/view.png" alt="Permissions"/></span>
			</p></div><p>
			Permissions can be created to protect two main types of objects:
		</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">
					<span class="strong strong"><strong>Resources</strong></span>
				</li><li class="listitem">
					<span class="strong strong"><strong>Scopes</strong></span>
				</li></ul></div><p>
			To create a permission, select the permission type you want to create from the item list in the upper right corner of the permission listing. The following sections describe these two types of objects in more detail.
		</p><section class="section" id="permission_create_resource"><div class="titlepage"><div><div><h2 class="title">6.1. Creating resource-based permission</h2></div></div></div><p>
				A resource-based permission defines a set of one or more resources to protect using a set of one or more authorization policies.
			</p><p>
				To create a new resource-based permission, select <span class="strong strong"><strong>Resource-based</strong></span> in the item list in the upper right corner of the permission listing.
			</p><div class="formalpara"><p class="title"><strong>Add Resource-Based Permission</strong></p><p>
					<span class="inlinemediaobject"><img src="images/rhsso-images/permission/create-resource.png" alt="Add Resource-Based Permission"/></span>
				</p></div><section class="section" id="configuration_9"><div class="titlepage"><div><div><h3 class="title">6.1.1. Configuration</h3></div></div></div><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p class="simpara">
							<span class="strong strong"><strong>Name</strong></span>
						</p><p class="simpara">
							A human-readable and unique string describing the permission. A best practice is to use names that are closely related to your business and security requirements, so you can identify them more easily.
						</p></li><li class="listitem"><p class="simpara">
							<span class="strong strong"><strong>Description</strong></span>
						</p><p class="simpara">
							A string containing details about this permission.
						</p></li></ul></div><div class="itemizedlist" id="permission_create_resource_apply_resource_type"><ul class="itemizedlist" type="disc"><li class="listitem"><p class="simpara">
							<span class="strong strong"><strong>Apply To Resource Type</strong></span>
						</p><p class="simpara">
							Specifies if the permission is applied to all resources with a given type. When selecting this field, you are prompted to enter the resource type to protect.
						</p><div class="itemizedlist"><ul class="itemizedlist" type="circle"><li class="listitem"><p class="simpara">
									Resource Type
								</p><p class="simpara">
									Defines the resource type to protect. When defined, this permission is evaluated for all resources matching that type.
								</p></li></ul></div></li><li class="listitem"><p class="simpara">
							<span class="strong strong"><strong>Resources</strong></span>
						</p><p class="simpara">
							Defines a set of one or more resources to protect.
						</p></li><li class="listitem"><p class="simpara">
							<span class="strong strong"><strong>Apply Policy</strong></span>
						</p><p class="simpara">
							Defines a set of one or more policies to associate with a permission. To associate a policy you can either select an existing policy or create a new one by selecting the type of the policy you want to create.
						</p></li><li class="listitem"><p class="simpara">
							<span class="strong strong"><strong>Decision Strategy</strong></span>
						</p><p class="simpara">
							The <a class="link" href="#permission_decision_strategies" title="6.3. Policy decision strategies">Decision Strategy</a> for this permission.
						</p></li></ul></div></section><section class="section" id="permission_typed_resource"><div class="titlepage"><div><div><h3 class="title">6.1.2. Typed resource permission</h3></div></div></div><p>
					Resource permissions can also be used to define policies that are to be applied to all resources with a given <a class="link" href="#resource_create_type">type</a>. This form of resource-based permission can be useful when you have resources sharing common access requirements and constraints.
				</p><p>
					Frequently, resources within an application can be categorized (or typed) based on the data they encapsulate or the functionality they provide. For example, a financial application can manage different banking accounts where each one belongs to a specific customer. Although they are different banking accounts, they share common security requirements and constraints that are globally defined by the banking organization. With typed resource permissions, you can define common policies to apply to all banking accounts, such as:
				</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">
							Only the owner can manage his account
						</li><li class="listitem">
							Only allow access from the owner’s country and/or region
						</li><li class="listitem">
							Enforce a specific authentication method
						</li></ul></div><p>
					To create a typed resource permission, click <a class="link" href="#permission_create_resource_apply_resource_type">Apply to Resource Type</a> when creating a new resource-based permission. With <code class="literal">Apply to Resource Type</code> set to <code class="literal">On</code>, you can specify the type that you want to protect as well as the policies that are to be applied to govern access to all resources with type you have specified.
				</p><div class="formalpara"><p class="title"><strong>Example of a Typed Resource Permission</strong></p><p>
						<span class="inlinemediaobject"><img src="images/rhsso-images/permission/typed-resource-perm-example.png" alt="Example of a Typed Resource Permission"/></span>
					</p></div></section></section><section class="section" id="permission_create_scope"><div class="titlepage"><div><div><h2 class="title">6.2. Creating scope-based permissions</h2></div></div></div><p>
				A scope-based permission defines a set of one or more scopes to protect using a set of one or more authorization policies. Unlike resource-based permissions, you can use this permission type to create permissions not only for a resource, but also for the scopes associated with it, providing more granularity when defining the permissions that govern your resources and the actions that can be performed on them.
			</p><p>
				To create a new scope-based permission, select <span class="strong strong"><strong>Scope-based</strong></span> in the item list in the upper right corner of the permission listing.
			</p><div class="formalpara"><p class="title"><strong>Add Scope-Based Permission</strong></p><p>
					<span class="inlinemediaobject"><img src="images/rhsso-images/permission/create-scope.png" alt="Add Scope-Based Permission"/></span>
				</p></div><section class="section" id="configuration_10"><div class="titlepage"><div><div><h3 class="title">6.2.1. Configuration</h3></div></div></div><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p class="simpara">
							<span class="strong strong"><strong>Name</strong></span>
						</p><p class="simpara">
							A human-readable and unique string describing the permission. A best practice is to use names that are closely related to your business and security requirements, so you can identify them more easily.
						</p></li><li class="listitem"><p class="simpara">
							<span class="strong strong"><strong>Description</strong></span>
						</p><p class="simpara">
							A string containing details about this permission.
						</p></li><li class="listitem"><p class="simpara">
							<span class="strong strong"><strong>Resource</strong></span>
						</p><p class="simpara">
							Restricts the scopes to those associated with the selected resource. If none is selected, all scopes are available.
						</p></li><li class="listitem"><p class="simpara">
							<span class="strong strong"><strong>Scopes</strong></span>
						</p><p class="simpara">
							Defines a set of one or more scopes to protect.
						</p></li><li class="listitem"><p class="simpara">
							<span class="strong strong"><strong>Apply Policy</strong></span>
						</p><p class="simpara">
							Defines a set of one or more policies to associate with a permission. To associate a policy you can either select an existing policy or create a new one by selecting the type of the policy you want to create.
						</p></li><li class="listitem"><p class="simpara">
							<span class="strong strong"><strong>Decision Strategy</strong></span>
						</p><p class="simpara">
							The <a class="link" href="#permission_decision_strategies" title="6.3. Policy decision strategies">Decision Strategy</a> for this permission.
						</p></li></ul></div></section></section><section class="section" id="permission_decision_strategies"><div class="titlepage"><div><div><h2 class="title">6.3. Policy decision strategies</h2></div></div></div><p>
				When associating policies with a permission, you can also define a decision strategy to specify how to evaluate the outcome of the associated policies to determine access.
			</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p class="simpara">
						<span class="strong strong"><strong>Unanimous</strong></span>
					</p><p class="simpara">
						The default strategy if none is provided. In this case, <span class="emphasis"><em>all</em></span> policies must evaluate to a positive decision for the final decision to be also positive.
					</p></li><li class="listitem"><p class="simpara">
						<span class="strong strong"><strong>Affirmative</strong></span>
					</p><p class="simpara">
						In this case, <span class="emphasis"><em>at least one</em></span> policy must evaluate to a positive decision for the final decision to be also positive.
					</p></li><li class="listitem"><p class="simpara">
						<span class="strong strong"><strong>Consensus</strong></span>
					</p><p class="simpara">
						In this case, the number of positive decisions must be greater than the number of negative decisions. If the number of positive and negative decisions is equal, the final decision will be negative.
					</p></li></ul></div></section></section><section class="chapter" id="policy_evaluation_overview"><div class="titlepage"><div><div><h1 class="title">Chapter 7. Evaluating and testing policies</h1></div></div></div><p>
			When designing your policies, you can simulate authorization requests to test how your policies are being evaluated.
		</p><p>
			You can access the Policy Evaluation Tool by clicking the <code class="literal">Evaluate</code> tab when editing a resource server. There you can specify different inputs to simulate real authorization requests and test the effect of your policies.
		</p><p>
			<span class="inlinemediaobject"><img src="images/rhsso-images/policy-evaluation-tool/policy-evaluation-tool.png" alt="Policy Evaluation Tool"/></span>
		</p><section class="section" id="providing_identity_information"><div class="titlepage"><div><div><h2 class="title">7.1. Providing identity information</h2></div></div></div><p>
				The <span class="strong strong"><strong>Identity Information</strong></span> filters can be used to specify the user requesting permissions.
			</p></section><section class="section" id="providing_contextual_information"><div class="titlepage"><div><div><h2 class="title">7.2. Providing contextual information</h2></div></div></div><p>
				The <span class="strong strong"><strong>Contextual Information</strong></span> filters can be used to define additional attributes to the evaluation context, so that policies can obtain these same attributes.
			</p></section><section class="section" id="providing_the_permissions"><div class="titlepage"><div><div><h2 class="title">7.3. Providing the permissions</h2></div></div></div><p>
				The <span class="strong strong"><strong>Permissions</strong></span> filters can be used to build an authorization request. You can request permissions for a set of one or more resources and scopes. If you want to simulate authorization requests based on all protected resources and scopes, click <span class="strong strong"><strong>Add</strong></span> without specifying any <code class="literal">Resources</code> or <code class="literal">Scopes</code>.
			</p><p>
				When you’ve specified your desired values, click <span class="strong strong"><strong>Evaluate</strong></span>.
			</p></section></section><section class="chapter" id="service_overview"><div class="titlepage"><div><div><h1 class="title">Chapter 8. Authorization services</h1></div></div></div><p>
			Red Hat Single Sign-On Authorization Services are built on top of well-known standards such as the OAuth2 and User-Managed Access specifications.
		</p><p>
			OAuth2 clients (such as front end applications) can obtain access tokens from the server using the token endpoint and use these same tokens to access resources protected by a resource server (such as back end services). In the same way, Red Hat Single Sign-On Authorization Services provide extensions to OAuth2 to allow access tokens to be issued based on the processing of all policies associated with the resource(s) or scope(s) being requested. This means that resource servers can enforce access to their protected resources based on the permissions granted by the server and held by an access token. In Red Hat Single Sign-On Authorization Services the access token with permissions is called a Requesting Party Token or RPT for short.
		</p><p>
			In addition to the issuance of RPTs, Red Hat Single Sign-On Authorization Services also provides a set of RESTful endpoints that allow resources servers to manage their protected resources, scopes, permissions and policies, helping developers to extend or integrate these capabilities into their applications in order to support fine-grained authorization.
		</p><section class="section" id="service_authorization_api"><div class="titlepage"><div><div><h2 class="title">8.1. Discovering authorization services endpoints and metadata</h2></div></div></div><p>
				Red Hat Single Sign-On provides a discovery document from which clients can obtain all necessary information to interact with Red Hat Single Sign-On Authorization Services, including endpoint locations and capabilities.
			</p><p>
				The discovery document can be obtained from:
			</p><pre class="programlisting language-bash">curl -X GET \
  http://${host}:${port}/auth/realms/${realm}/.well-known/uma2-configuration</pre><p>
				Where <code class="literal">${host}:${port}</code> is the hostname (or IP address) and port where Red Hat Single Sign-On is running and <code class="literal">${realm}</code> is the name of a realm in Red Hat Single Sign-On.
			</p><p>
				As a result, you should get a response as follows:
			</p><pre class="programlisting language-bash">{

    // some claims are expected here

    // these are the main claims in the discovery document about Authorization Services endpoints location
    "token_endpoint": "http://${host}:${port}/auth/realms/${realm}/protocol/openid-connect/token",
    "token_introspection_endpoint": "http://${host}:${port}/auth/realms/${realm}/protocol/openid-connect/token/introspect",
    "resource_registration_endpoint": "http://${host}:${port}/auth/realms/${realm}/authz/protection/resource_set",
    "permission_endpoint": "http://${host}:${port}/auth/realms/${realm}/authz/protection/permission",
    "policy_endpoint": "http://${host}:${port}/auth/realms/${realm}/authz/protection/uma-policy"
}</pre><p>
				Each of these endpoints expose a specific set of capabilities:
			</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p class="simpara">
						<span class="strong strong"><strong>token_endpoint</strong></span>
					</p><p class="simpara">
						A OAuth2-compliant Token Endpoint that supports the <code class="literal">urn:ietf:params:oauth:grant-type:uma-ticket</code> grant type. Through this endpoint clients can send authorization requests and obtain an RPT with all permissions granted by Red Hat Single Sign-On.
					</p></li><li class="listitem"><p class="simpara">
						<span class="strong strong"><strong>token_introspection_endpoint</strong></span>
					</p><p class="simpara">
						A OAuth2-compliant Token Introspection Endpoint which clients can use to query the server to determine the active state of an RPT and to determine any other information associated with the token, such as the permissions granted by Red Hat Single Sign-On.
					</p></li><li class="listitem"><p class="simpara">
						<span class="strong strong"><strong>resource_registration_endpoint</strong></span>
					</p><p class="simpara">
						A UMA-compliant Resource Registration Endpoint which resource servers can use to manage their protected resources and scopes. This endpoint provides operations create, read, update and delete resources and scopes in Red Hat Single Sign-On.
					</p></li><li class="listitem"><p class="simpara">
						<span class="strong strong"><strong>permission_endpoint</strong></span>
					</p><p class="simpara">
						A UMA-compliant Permission Endpoint which resource servers can use to manage permission tickets. This endpoint provides operations create, read, update, and delete permission tickets in Red Hat Single Sign-On.
					</p></li></ul></div></section><section class="section" id="service_obtaining_permissions"><div class="titlepage"><div><div><h2 class="title">8.2. Obtaining permissions</h2></div></div></div><p>
				To obtain permissions from Red Hat Single Sign-On you send an authorization request to the token endpoint. As a result, Red Hat Single Sign-On will evaluate all policies associated with the resource(s) and scope(s) being requested and issue an RPT with all permissions granted by the server.
			</p><p>
				Clients are allowed to send authorization requests to the token endpoint using the following parameters:
			</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p class="simpara">
						<span class="strong strong"><strong>grant_type</strong></span>
					</p><p class="simpara">
						This parameter is <span class="strong strong"><strong>required</strong></span>. Must be <code class="literal">urn:ietf:params:oauth:grant-type:uma-ticket</code>.
					</p></li><li class="listitem"><p class="simpara">
						<span class="strong strong"><strong>ticket</strong></span>
					</p><p class="simpara">
						This parameter is <span class="strong strong"><strong>optional</strong></span>. The most recent permission ticket received by the client as part of the UMA authorization process.
					</p></li><li class="listitem"><p class="simpara">
						<span class="strong strong"><strong>claim_token</strong></span>
					</p><p class="simpara">
						This parameter is <span class="strong strong"><strong>optional</strong></span>. A string representing additional claims that should be considered by the server when evaluating permissions for the resource(s) and scope(s) being requested. This parameter allows clients to push claims to Red Hat Single Sign-On. For more details about all supported token formats see <code class="literal">claim_token_format</code> parameter.
					</p></li><li class="listitem"><p class="simpara">
						<span class="strong strong"><strong>claim_token_format</strong></span>
					</p><p class="simpara">
						This parameter is <span class="strong strong"><strong>optional</strong></span>. A string indicating the format of the token specified in the <code class="literal">claim_token</code> parameter. Red Hat Single Sign-On supports two token formats: <code class="literal">urn:ietf:params:oauth:token-type:jwt</code> and <code class="literal"><a class="link" href="https://openid.net/specs/openid-connect-core-1_0.html#IDToken">https://openid.net/specs/openid-connect-core-1_0.html#IDToken</a></code>. The <code class="literal">urn:ietf:params:oauth:token-type:jwt</code> format indicates that the <code class="literal">claim_token</code> parameter references an access token. The <code class="literal"><a class="link" href="https://openid.net/specs/openid-connect-core-1_0.html#IDToken">https://openid.net/specs/openid-connect-core-1_0.html#IDToken</a></code> indicates that the <code class="literal">claim_token</code> parameter references an OpenID Connect ID Token.
					</p></li><li class="listitem"><p class="simpara">
						<span class="strong strong"><strong>rpt</strong></span>
					</p><p class="simpara">
						This parameter is <span class="strong strong"><strong>optional</strong></span>. A previously issued RPT which permissions should also be evaluated and added in a new one. This parameter allows clients in possession of an RPT to perform incremental authorization where permissions are added on demand.
					</p></li><li class="listitem"><p class="simpara">
						<span class="strong strong"><strong>permission</strong></span>
					</p><p class="simpara">
						This parameter is <span class="strong strong"><strong>optional</strong></span>. A string representing a set of one or more resources and scopes the client is seeking access. This parameter can be defined multiple times in order to request permission for multiple resource and scopes. This parameter is an extension to <code class="literal">urn:ietf:params:oauth:grant-type:uma-ticket</code> grant type in order to allow clients to send authorization requests without a permission ticket. The format of the string must be: <code class="literal">RESOURCE_ID#SCOPE_ID</code>. For instance: <code class="literal">Resource A#Scope A</code>, <code class="literal">Resource A#Scope A, Scope B, Scope C</code>, <code class="literal">Resource A</code>, <code class="literal">#Scope A</code>.
					</p></li><li class="listitem"><p class="simpara">
						<span class="strong strong"><strong>audience</strong></span>
					</p><p class="simpara">
						This parameter is <span class="strong strong"><strong>optional</strong></span>. The client identifier of the resource server to which the client is seeking access. This parameter is mandatory in case the <code class="literal">permission</code> parameter is defined. It serves as a hint to Red Hat Single Sign-On to indicate the context in which permissions should be evaluated.
					</p></li><li class="listitem"><p class="simpara">
						<span class="strong strong"><strong>response_include_resource_name</strong></span>
					</p><p class="simpara">
						This parameter is <span class="strong strong"><strong>optional</strong></span>. A boolean value indicating to the server whether resource names should be included in the RPT’s permissions. If false, only the resource identifier is included.
					</p></li><li class="listitem"><p class="simpara">
						<span class="strong strong"><strong>response_permissions_limit</strong></span>
					</p><p class="simpara">
						This parameter is <span class="strong strong"><strong>optional</strong></span>. An integer N that defines a limit for the amount of permissions an RPT can have. When used together with <code class="literal">rpt</code> parameter, only the last N requested permissions will be kept in the RPT.
					</p></li><li class="listitem"><p class="simpara">
						<span class="strong strong"><strong>submit_request</strong></span>
					</p><p class="simpara">
						This parameter is <span class="strong strong"><strong>optional</strong></span>. A boolean value indicating whether the server should create permission requests to the resources and scopes referenced by a permission ticket. This parameter only has effect if used together with the <code class="literal">ticket</code> parameter as part of a UMA authorization process.
					</p></li><li class="listitem"><p class="simpara">
						<span class="strong strong"><strong>response_mode</strong></span>
					</p><p class="simpara">
						This parameter is <span class="strong strong"><strong>optional</strong></span>. A string value indicating how the server should respond to authorization requests. This parameter is specially useful when you are mainly interested in either the overall decision or the permissions granted by the server, instead of a standard OAuth2 response. Possible values are:
					</p><div class="itemizedlist"><ul class="itemizedlist" type="circle"><li class="listitem"><p class="simpara">
								<code class="literal">decision</code>
							</p><p class="simpara">
								Indicates that responses from the server should only represent the overall decision by returning a JSON with the following format:
							</p><pre class="programlisting language-json">{
    'result': true
}</pre><p class="simpara">
								If the authorization request does not map to any permission, a <code class="literal">403</code> HTTP status code is returned instead.
							</p></li><li class="listitem"><p class="simpara">
								<code class="literal">permissions</code>
							</p><p class="simpara">
								Indicates that responses from the server should contain any permission granted by the server by returning a JSON with the following format:
							</p><pre class="programlisting language-json">[
    {
        'rsid': 'My Resource'
        'scopes': ['view', 'update']
    },

    ...
]</pre><p class="simpara">
								If the authorization request does not map to any permission, a <code class="literal">403</code> HTTP status code is returned instead.
							</p></li></ul></div></li></ul></div><p>
				Example of a authorization request when a client is seeking access to two resources protected by a resource server.
			</p><pre class="programlisting language-bash">curl -X POST \
  http://${host}:${port}/auth/realms/${realm}/protocol/openid-connect/token \
  -H "Authorization: Bearer ${access_token}" \
  --data "grant_type=urn:ietf:params:oauth:grant-type:uma-ticket" \
  --data "audience={resource_server_client_id}" \
  --data "permission=Resource A#Scope A" \
  --data "permission=Resource B#Scope B"</pre><p>
				Example of a authorization request when a client is seeking access to any resource and scope protected by a resource server.
			</p><pre class="programlisting language-bash">curl -X POST \
  http://${host}:${port}/auth/realms/${realm}/protocol/openid-connect/token \
  -H "Authorization: Bearer ${access_token}" \
  --data "grant_type=urn:ietf:params:oauth:grant-type:uma-ticket" \
  --data "audience={resource_server_client_id}"</pre><p>
				Example of an authorization request when a client is seeking access to a UMA protected resource after receiving a permission ticket from the resource server as part of the authorization process:
			</p><pre class="programlisting language-bash">curl -X POST \
  http://${host}:${port}/auth/realms/${realm}/protocol/openid-connect/token \
  -H "Authorization: Bearer ${access_token}" \
  --data "grant_type=urn:ietf:params:oauth:grant-type:uma-ticket" \
  --data "ticket=${permission_ticket}</pre><p>
				If Red Hat Single Sign-On assessment process results in issuance of permissions, it issues the RPT with which it has associated the permissions:
			</p><div class="formalpara"><p class="title"><strong>Red Hat Single Sign-On responds to the client with the RPT</strong></p><p>
					
<pre class="programlisting language-bash">HTTP/1.1 200 OK
Content-Type: application/json
...
{
    "access_token": "${rpt}",
}</pre>
				</p></div><p>
				The response from the server is just like any other response from the token endpoint when using some other grant type. The RPT can be obtained from the <code class="literal">access_token</code> response parameter. If the client is not authorized, Red Hat Single Sign-On responds with a <code class="literal">403</code> HTTP status code:
			</p><div class="formalpara"><p class="title"><strong>Red Hat Single Sign-On denies the authorization request</strong></p><p>
					
<pre class="programlisting language-bash">HTTP/1.1 403 Forbidden
Content-Type: application/json
...
{
    "error": "access_denied",
    "error_description": "request_denied"
}</pre>
				</p></div><section class="section" id="authentication_methods"><div class="titlepage"><div><div><h3 class="title">8.2.1. Client authentication methods</h3></div></div></div><p>
					Clients need to authenticate to the token endpoint in order to obtain an RPT. When using the <code class="literal">urn:ietf:params:oauth:grant-type:uma-ticket</code> grant type, clients can use any of these authentication methods:
				</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p class="simpara">
							<span class="strong strong"><strong>Bearer Token</strong></span>
						</p><p class="simpara">
							Clients should send an access token as a Bearer credential in an HTTP Authorization header to the token endpoint.
						</p><div class="formalpara"><p class="title"><strong>Example: an authorization request using an access token to authenticate to the token endpoint</strong></p><p>
								
<pre class="programlisting language-bash">curl -X POST \
  http://${host}:${port}/auth/realms/${realm}/protocol/openid-connect/token \
  -H "Authorization: Bearer ${access_token}" \
  --data "grant_type=urn:ietf:params:oauth:grant-type:uma-ticket"</pre>
							</p></div><p class="simpara">
							This method is especially useful when the client is acting on behalf of a user. In this case, the bearer token is an access token previously issued by Red Hat Single Sign-On to some client acting on behalf of a user (or on behalf of itself). Permissions will be evaluated considering the access context represented by the access token. For instance, if the access token was issued to Client A acting on behalf of User A, permissions will be granted depending on the resources and scopes to which User A has access.
						</p></li><li class="listitem"><p class="simpara">
							<span class="strong strong"><strong>Client Credentials</strong></span>
						</p><p class="simpara">
							Clients can use any of the client authentication methods supported by Red Hat Single Sign-On. For instance, client_id/client_secret or JWT.
						</p><div class="formalpara"><p class="title"><strong>Example: an authorization request using client id and client secret to authenticate to the token endpoint</strong></p><p>
								
<pre class="programlisting language-bash">curl -X POST \
  http://${host}:${port}/auth/realms/${realm}/protocol/openid-connect/token \
  -H "Authorization: Basic cGhvdGg6L7Jl13RmfWgtkk==pOnNlY3JldA==" \
  --data "grant_type=urn:ietf:params:oauth:grant-type:uma-ticket"</pre>
							</p></div></li></ul></div></section><section class="section" id="service_pushing_claims"><div class="titlepage"><div><div><h3 class="title">8.2.2. Pushing claims</h3></div></div></div><p>
					When obtaining permissions from the server you can push arbitrary claims in order to have these claims available to your policies when evaluating permissions.
				</p><p>
					If you are obtaining permissions from the server <span class="strong strong"><strong>without</strong></span> using a permission ticket (UMA flow), you can send an authorization request to the token endpoint as follows:
				</p><pre class="programlisting language-bash">curl -X POST \
  http://${host}:${port}/auth/realms/${realm}/protocol/openid-connect/token \
  --data "grant_type=urn:ietf:params:oauth:grant-type:uma-ticket" \
  --data "claim_token=ewogICAib3JnYW5pemF0aW9uIjogWyJhY21lIl0KfQ==" \
  --data "claim_token_format=urn:ietf:params:oauth:token-type:jwt" \
  --data "client_id={resource_server_client_id}" \
  --data "client_secret={resource_server_client_secret}" \
  --data "audience={resource_server_client_id}"</pre><p>
					The <code class="literal">claim_token</code> parameter expects a BASE64 encoded JSON with a format similar to the example below:
				</p><pre class="programlisting language-json">{
    "organization" : ["acme"]
}</pre><p>
					The format expects one or more claims where the value for each claim must be an array of strings.
				</p><section class="section" id="pushing_claims_using_uma"><div class="titlepage"><div><div><h4 class="title">8.2.2.1. Pushing claims Using UMA</h4></div></div></div><p>
						For more details about how to push claims when using UMA and permission tickets, please take a look at <a class="link" href="#service_protection_permission_api_papi" title="8.4.3. Managing permission requests">Permission API</a>
					</p></section></section></section><section class="section" id="service_user_managed_access"><div class="titlepage"><div><div><h2 class="title">8.3. User-managed access</h2></div></div></div><p>
				Red Hat Single Sign-On Authorization Services is based on User-Managed Access or UMA for short. UMA is a specification that enhances OAuth2 capabilities in the following ways:
			</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p class="simpara">
						<span class="strong strong"><strong>Privacy</strong></span>
					</p><p class="simpara">
						Nowadays, user privacy is becoming a huge concern, as more and more data and devices are available and connected to the cloud. With UMA and Red Hat Single Sign-On, resource servers can enhance their capabilities in order to improve how their resources are protected in respect to user privacy where permissions are granted based on policies defined by the user.
					</p></li><li class="listitem"><p class="simpara">
						<span class="strong strong"><strong>Party-to-Party Authorization</strong></span>
					</p><p class="simpara">
						Resource owners (e.g.: regular end-users) can manage access to their resources and authorize other parties (e.g: regular end-users) to access these resources. This is different than OAuth2 where consent is given to a client application acting on behalf of a user, with UMA resource owners are allowed to consent access to other users, in a completely asynchronous manner.
					</p></li><li class="listitem"><p class="simpara">
						<span class="strong strong"><strong>Resource Sharing</strong></span>
					</p><p class="simpara">
						Resource owners are allowed to manage permissions to their resources and decide who can access a particular resource and how. Red Hat Single Sign-On can then act as a sharing management service from which resource owners can manage their resources.
					</p></li></ul></div><p>
				Red Hat Single Sign-On is a UMA 2.0 compliant authorization server that provides most UMA capabilities.
			</p><p>
				As an example, consider a user Alice (resource owner) using an Internet Banking Service (resource server) to manage her Bank Account (resource). One day, Alice decides to open her bank account to Bob (requesting party), a accounting professional. However, Bob should only have access to view (scope) Alice’s account.
			</p><p>
				As a resource server, the Internet Banking Service must be able to protect Alice’s Bank Account. For that, it relies on Red Hat Single Sign-On Resource Registration Endpoint to create a resource in the server representing Alice’s Bank Account.
			</p><p>
				At this moment, if Bob tries to access Alice’s Bank Account, access will be denied. The Internet Banking Service defines a few default policies for banking accounts. One of them is that only the owner, in this case Alice, is allowed to access her bank account.
			</p><p>
				However, Internet Banking Service in respect to Alice’s privacy also allows her to change specific policies for the banking account. One of these policies that she can change is to define which people are allowed to view her bank account. For that, Internet Banking Service relies on Red Hat Single Sign-On to provide to Alice a space where she can select individuals and the operations (or data) they are allowed to access. At any time, Alice can revoke access or grant additional permissions to Bob.
			</p><section class="section" id="service_uma_authorization_process"><div class="titlepage"><div><div><h3 class="title">8.3.1. Authorization process</h3></div></div></div><p>
					In UMA, the authorization process starts when a client tries to access a UMA protected resource server.
				</p><p>
					A UMA protected resource server expects a bearer token in the request where the token is an RPT. When a client requests a resource at the resource server without a permission ticket:
				</p><div class="formalpara"><p class="title"><strong>Client requests a protected resource without sending an RPT</strong></p><p>
						
<pre class="programlisting language-bash">curl -X GET \
  http://${host}:${port}/my-resource-server/resource/1bfdfe78-a4e1-4c2d-b142-fc92b75b986f</pre>
					</p></div><p>
					The resource server sends a response back to the client with a permission <code class="literal">ticket</code> and a <code class="literal">as_uri</code> parameter with the location of a Red Hat Single Sign-On server to where the ticket should be sent in order to obtain an RPT.
				</p><div class="formalpara"><p class="title"><strong>Resource server responds with a permission ticket</strong></p><p>
						
<pre class="programlisting language-bash">HTTP/1.1 401 Unauthorized
WWW-Authenticate: UMA realm="${realm}",
    as_uri="https://${host}:${port}/auth/realms/${realm}",
    ticket="016f84e8-f9b9-11e0-bd6f-0021cc6004de"</pre>
					</p></div><p>
					The permission ticket is a special type of token issued by Red Hat Single Sign-On Permission API. They represent the permissions being requested (e.g.: resources and scopes) as well any other information associated with the request. Only resource servers are allowed to create those tokens.
				</p><p>
					Now that the client has a permission ticket and also the location of a Red Hat Single Sign-On server, the client can use the discovery document to obtain the location of the token endpoint and send an authorization request.
				</p><div class="formalpara"><p class="title"><strong>Client sends an authorization request to the token endpoint to obtain an RPT</strong></p><p>
						
<pre class="programlisting language-bash">curl -X POST \
  http://${host}:${port}/auth/realms/${realm}/protocol/openid-connect/token \
  -H "Authorization: Bearer ${access_token}" \
  --data "grant_type=urn:ietf:params:oauth:grant-type:uma-ticket" \
  --data "ticket=${permission_ticket}</pre>
					</p></div><p>
					If Red Hat Single Sign-On assessment process results in issuance of permissions, it issues the RPT with which it has associated the permissions:
				</p><div class="formalpara"><p class="title"><strong>Red Hat Single Sign-On responds to the client with the RPT</strong></p><p>
						
<pre class="programlisting language-bash">HTTP/1.1 200 OK
Content-Type: application/json
...
{
    "access_token": "${rpt}",
}</pre>
					</p></div><p>
					The response from the server is just like any other response from the token endpoint when using some other grant type. The RPT can be obtained from the <code class="literal">access_token</code> response parameter. In case the client is not authorized to have permissions Red Hat Single Sign-On responds with a <code class="literal">403</code> HTTP status code:
				</p><div class="formalpara"><p class="title"><strong>Red Hat Single Sign-On denies the authorization request</strong></p><p>
						
<pre class="programlisting language-bash">HTTP/1.1 403 Forbidden
Content-Type: application/json
...
{
    "error": "access_denied",
    "error_description": "request_denied"
}</pre>
					</p></div></section><section class="section" id="service_authorization_aat"><div class="titlepage"><div><div><h3 class="title">8.3.2. Submitting permission requests</h3></div></div></div><p>
					As part of the authorization process, clients need first to obtain a permission ticket from a UMA protected resource server in order to exchange it with an RPT at the Red Hat Single Sign-On Token Endpoint.
				</p><p>
					By default, Red Hat Single Sign-On responds with a <code class="literal">403</code> HTTP status code and a <code class="literal">request_denied</code> error in case the client can not be issued with an RPT.
				</p><div class="formalpara"><p class="title"><strong>Red Hat Single Sign-On denies the authorization request</strong></p><p>
						
<pre class="programlisting language-bash">HTTP/1.1 403 Forbidden
Content-Type: application/json
...
{
    "error": "access_denied",
    "error_description": "request_denied"
}</pre>
					</p></div><p>
					Such response implies that Red Hat Single Sign-On could not issue an RPT with the permissions represented by a permission ticket.
				</p><p>
					In some situations, client applications may want to start an asynchronous authorization flow and let the owner of the resources being requested decide whether or not access should be granted. For that, clients can use the <code class="literal">submit_request</code> request parameter along with an authorization request to the token endpoint:
				</p><pre class="programlisting language-bash">curl -X POST \
  http://${host}:${port}/auth/realms/${realm}/protocol/openid-connect/token \
  -H "Authorization: Bearer ${access_token}" \
  --data "grant_type=urn:ietf:params:oauth:grant-type:uma-ticket" \
  --data "ticket=${permission_ticket} \
  --data "submit_request=true"</pre><p>
					When using the <code class="literal">submit_request</code> parameter, Red Hat Single Sign-On will persist a permission request for each resource to which access was denied. Once created, resource owners can check their account and manage their permissions requests.
				</p><p>
					You can think about this functionality as a <code class="literal">Request Access</code> button in your application, where users can ask other users for access to their resources.
				</p></section><section class="section" id="service_authorization_my_resources"><div class="titlepage"><div><div><h3 class="title">8.3.3. Managing access to users resources</h3></div></div></div><p>
					Users can manage access to their resources using the Red Hat Single Sign-On User Account Service. To enable this functionality, you must first enable User-Managed Access for your realm.
				</p><div class="orderedlist"><p class="title"><strong>Procedure</strong></p><ol class="orderedlist" type="1"><li class="listitem">
							Log into the Admin Console.
						</li><li class="listitem">
							Click <span class="strong strong"><strong>Realm Settings</strong></span> in the menu.
						</li><li class="listitem"><p class="simpara">
							Toggle <span class="strong strong"><strong>User-Managed Access</strong></span> to <span class="strong strong"><strong>ON</strong></span>.
						</p><p class="simpara">
							<span class="inlinemediaobject"><img src="images/rhsso-images/service/account-my-resource.png" alt="My Resources"/></span>
						</p></li><li class="listitem"><p class="simpara">
							Click <span class="strong strong"><strong>My Resources</strong></span> in the menu option. A page displays with the following options.
						</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p class="simpara">
									Manage Permission Requests that <span class="strong strong"><strong>Need my approval</strong></span>
								</p><p class="simpara">
									This section contains a list of all permission requests awaiting approval. These requests are connected to the parties (users) requesting access to a particular resource. Users are allowed to approve or deny these requests.
								</p></li><li class="listitem"><p class="simpara">
									Manage <span class="strong strong"><strong>My resources</strong></span>
								</p><p class="simpara">
									This section contains a list of all resources owned by the user. Users can click on a resource for more details and share the resource with others.
								</p></li><li class="listitem"><p class="simpara">
									Manage <span class="strong strong"><strong>Resources shared with me</strong></span>
								</p><p class="simpara">
									This section contains a list of all resources shared with the user.
								</p></li><li class="listitem"><p class="simpara">
									Manage <span class="strong strong"><strong>Your requests waiting approval</strong></span>
								</p><p class="simpara">
									This section contains a list of permission requests sent by the user that are waiting for the approval of another user or resource owner.
								</p></li></ul></div></li></ol></div><p>
					When you click on a specific resource to make changes, the following page displays:
				</p><p>
					<span class="inlinemediaobject"><img src="images/rhsso-images/service/account-my-resource-detail.png" alt="Resource Detail"/></span>
				</p><p>
					This page provides the following options:
				</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p class="simpara">
							Manage <span class="strong strong"><strong>People with access to this resource</strong></span>
						</p><p class="simpara">
							This section contains a list of people with access to this resource. Users are allowed to revoke access by clicking on the <code class="literal">Revoke</code> button or by removing a specific <code class="literal">Permission</code>.
						</p></li><li class="listitem"><p class="simpara">
							Share the resource with others
						</p><p class="simpara">
							By typing the username or e-mail of another user, the user is able to share the resource and select the permissions he wants to grant access.
						</p></li></ul></div></section></section><section class="section" id="service_protection_api"><div class="titlepage"><div><div><h2 class="title">8.4. Protection API</h2></div></div></div><p>
				The Protection API provides a UMA-compliant set of endpoints providing:
			</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p class="simpara">
						<span class="strong strong"><strong>Resource Management</strong></span>
					</p><p class="simpara">
						With this endpoint, resource servers can manage their resources remotely and enable <a class="link" href="#enforcer_overview" title="Chapter 9. Policy enforcers">policy enforcers</a> to query the server for the resources that need protection.
					</p></li><li class="listitem"><p class="simpara">
						<span class="strong strong"><strong>Permission Management</strong></span>
					</p><p class="simpara">
						In the UMA protocol, resource servers access this endpoint to create permission tickets. Red Hat Single Sign-On also provides endpoints to manage the state of permissions and query permissions.
					</p></li><li class="listitem"><p class="simpara">
						<span class="strong strong"><strong>Policy API</strong></span>
					</p><p class="simpara">
						Red Hat Single Sign-On leverages the UMA Protection API to allow resource servers to manage permissions for their users. In addition to the Resource and Permission APIs, Red Hat Single Sign-On provides a Policy API from where permissions can be set to resources by resource servers on behalf of their users.
					</p></li></ul></div><p>
				An important requirement for this API is that <span class="emphasis"><em>only</em></span> resource servers are allowed to access its endpoints using a special OAuth2 access token called a protection API token (PAT). In UMA, a PAT is a token with the scope <span class="strong strong"><strong>uma_protection</strong></span>.
			</p><section class="section" id="service_protection_whatis_obtain_pat"><div class="titlepage"><div><div><h3 class="title">8.4.1. What is a PAT and how to obtain it</h3></div></div></div><p>
					A <span class="strong strong"><strong>protection API token</strong></span> (PAT) is a special OAuth2 access token with a scope defined as <span class="strong strong"><strong>uma_protection</strong></span>. When you create a resource server, Red Hat Single Sign-On automatically creates a role, <span class="emphasis"><em>uma_protection</em></span>, for the corresponding client application and associates it with the client’s service account.
				</p><div class="formalpara"><p class="title"><strong>Service Account granted with <span class="strong strong"><strong>uma_protection</strong></span> role</strong></p><p>
						<span class="inlinemediaobject"><img src="images/rhsso-images/service/rs-uma-protection-role.png" alt="Service Account granted with uma_protection role"/></span>
					</p></div><p>
					Resource servers can obtain a PAT from Red Hat Single Sign-On like any other OAuth2 access token. For example, using curl:
				</p><pre class="programlisting language-bash">curl -X POST \
    -H "Content-Type: application/x-www-form-urlencoded" \
    -d 'grant_type=client_credentials&amp;client_id=${client_id}&amp;client_secret=${client_secret}' \
    "http://localhost:8080/auth/realms/${realm_name}/protocol/openid-connect/token"</pre><p>
					The example above is using the <span class="strong strong"><strong>client_credentials</strong></span> grant type to obtain a PAT from the server. As a result, the server returns a response similar to the following:
				</p><pre class="programlisting language-json">{
  "access_token": ${PAT},
  "expires_in": 300,
  "refresh_expires_in": 1800,
  "refresh_token": ${refresh_token},
  "token_type": "bearer",
  "id_token": ${id_token},
  "not-before-policy": 0,
  "session_state": "ccea4a55-9aec-4024-b11c-44f6f168439e"
}</pre><div class="admonition note"><div class="admonition_header">Note</div><div><p>
						Red Hat Single Sign-On can authenticate your client application in different ways. For simplicity, the <span class="strong strong"><strong>client_credentials</strong></span> grant type is used here, which requires a <span class="emphasis"><em>client_id</em></span> and a <span class="emphasis"><em>client_secret</em></span>. You can choose to use any supported authentication method.
					</p></div></div></section><section class="section" id="service_protection_resources_api"><div class="titlepage"><div><div><h3 class="title">8.4.2. Managing resources</h3></div></div></div><p>
					Resource servers can manage their resources remotely using a UMA-compliant endpoint.
				</p><pre class="screen">http://${host}:${port}/auth/realms/${realm_name}/authz/protection/resource_set</pre><p>
					This endpoint provides operations outlined as follows (entire path omitted for clarity):
				</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">
							Create resource set description: POST /resource_set
						</li><li class="listitem">
							Read resource set description: GET /resource_set/{_id}
						</li><li class="listitem">
							Update resource set description: PUT /resource_set/{_id}
						</li><li class="listitem">
							Delete resource set description: DELETE /resource_set/{_id}
						</li><li class="listitem">
							List resource set descriptions: GET /resource_set
						</li></ul></div><p>
					For more information about the contract for each of these operations, see <a class="link" href="https://docs.kantarainitiative.org/uma/wg/oauth-uma-federated-authz-2.0-09.html#reg-api">UMA Resource Registration API</a>.
				</p><section class="section" id="creating_a_resource"><div class="titlepage"><div><div><h4 class="title">8.4.2.1. Creating a resource</h4></div></div></div><p>
						To create a resource you must send an HTTP POST request as follows:
					</p><pre class="programlisting language-bash">curl -v -X POST \
  http://${host}:${port}/auth/realms/${realm_name}/authz/protection/resource_set \
  -H 'Authorization: Bearer '$pat \
  -H 'Content-Type: application/json' \
  -d '{
     "name":"Tweedl Social Service",
     "type":"http://www.example.com/rsrcs/socialstream/140-compatible",
     "icon_uri":"http://www.example.com/icons/sharesocial.png",
     "resource_scopes":[
         "read-public",
         "post-updates",
         "read-private",
         "http://www.example.com/scopes/all"
      ]
  }'</pre><p>
						By default, the owner of a resource is the resource server. If you want to define a different owner, such as an specific user, you can send a request as follows:
					</p><pre class="programlisting language-bash">curl -v -X POST \
  http://${host}:${port}/auth/realms/${realm_name}/authz/protection/resource_set \
  -H 'Authorization: Bearer '$pat \
  -H 'Content-Type: application/json' \
  -d '{
     "name":"Alice Resource",
     "owner": "alice"
  }'</pre><p>
						Where the property <code class="literal">owner</code> can be set with the username or the identifier of the user.
					</p></section><section class="section" id="creating_user_managed_resources"><div class="titlepage"><div><div><h4 class="title">8.4.2.2. Creating user-managed resources</h4></div></div></div><p>
						By default, resources created via Protection API can not be managed by resource owners through the <a class="link" href="#service_authorization_my_resources" title="8.3.3. Managing access to users resources">User Account Service</a>.
					</p><p>
						To create resources and allow resource owners to manage these resources, you must set <code class="literal">ownerManagedAccess</code> property as follows:
					</p><pre class="programlisting language-bash">curl -v -X POST \
  http://${host}:${port}/auth/realms/${realm_name}/authz/protection/resource_set \
  -H 'Authorization: Bearer '$pat \
  -H 'Content-Type: application/json' \
  -d '{
     "name":"Alice Resource",
     "owner": "alice",
     "ownerManagedAccess": true
  }'</pre></section><section class="section" id="updating_resources"><div class="titlepage"><div><div><h4 class="title">8.4.2.3. Updating resources</h4></div></div></div><p>
						To update an existing resource, send an HTTP PUT request as follows:
					</p><pre class="programlisting language-bash">curl -v -X PUT \
  http://${host}:${port}/auth/realms/${realm_name}/authz/protection/resource_set/{resource_id} \
  -H 'Authorization: Bearer '$pat \
  -H 'Content-Type: application/json' \
  -d '{
     "_id": "Alice Resource",
     "name":"Alice Resource",
     "resource_scopes": [
        "read"
     ]
  }'</pre></section><section class="section" id="deleting_resources"><div class="titlepage"><div><div><h4 class="title">8.4.2.4. Deleting resources</h4></div></div></div><p>
						To delete an existing resource, send an HTTP DELETE request as follows:
					</p><pre class="programlisting language-bash">curl -v -X DELETE \
  http://${host}:${port}/auth/realms/${realm_name}/authz/protection/resource_set/{resource_id} \
  -H 'Authorization: Bearer '$pat</pre></section><section class="section" id="querying_resources"><div class="titlepage"><div><div><h4 class="title">8.4.2.5. Querying resources</h4></div></div></div><p>
						To query the resources by <code class="literal">id</code>, send an HTTP GET request as follows:
					</p><pre class="programlisting language-bash">http://${host}:${port}/auth/realms/${realm_name}/authz/protection/resource_set/{resource_id}</pre><p>
						To query resources given a <code class="literal">name</code>, send an HTTP GET request as follows:
					</p><pre class="programlisting language-bash">http://${host}:${port}/auth/realms/${realm_name}/authz/protection/resource_set?name=Alice Resource</pre><p>
						By default, the <code class="literal">name</code> filter will match any resource with the given pattern. To restrict the query to only return resources with an exact match, use:
					</p><pre class="programlisting language-bash">http://${host}:${port}/auth/realms/${realm_name}/authz/protection/resource_set?name=Alice Resource&amp;exactName=true</pre><p>
						To query resources given an <code class="literal">uri</code>, send an HTTP GET request as follows:
					</p><pre class="programlisting language-bash">http://${host}:${port}/auth/realms/${realm_name}/authz/protection/resource_set?uri=/api/alice</pre><p>
						To query resources given an <code class="literal">owner</code>, send an HTTP GET request as follows:
					</p><pre class="programlisting language-bash">http://${host}:${port}/auth/realms/${realm_name}/authz/protection/resource_set?owner=alice</pre><p>
						To query resources given an <code class="literal">type</code>, send an HTTP GET request as follows:
					</p><pre class="programlisting language-bash">http://${host}:${port}/auth/realms/${realm_name}/authz/protection/resource_set?type=albums</pre><p>
						To query resources given an <code class="literal">scope</code>, send an HTTP GET request as follows:
					</p><pre class="programlisting language-bash">http://${host}:${port}/auth/realms/${realm_name}/authz/protection/resource_set?scope=read</pre><p>
						When querying the server for permissions use parameters <code class="literal">first</code> and <code class="literal">max</code> results to limit the result.
					</p></section></section><section class="section" id="service_protection_permission_api_papi"><div class="titlepage"><div><div><h3 class="title">8.4.3. Managing permission requests</h3></div></div></div><p>
					Resource servers using the UMA protocol can use a specific endpoint to manage permission requests. This endpoint provides a UMA-compliant flow for registering permission requests and obtaining a permission ticket.
				</p><pre class="screen">http://${host}:${port}/auth/realms/${realm_name}/authz/protection/permission</pre><p>
					A <a class="link" href="#overview_terminology_permission_ticket" title="1.2.7. Permission ticket">permission ticket</a> is a special security token type representing a permission request. Per the UMA specification, a permission ticket is:
				</p><p>
					<code class="literal">A correlation handle that is conveyed from an authorization server to a resource server, from a resource server to a client, and ultimately from a client back to an authorization server, to enable the authorization server to assess the correct policies to apply to a request for authorization data.</code>
				</p><p>
					In most cases, you won’t need to deal with this endpoint directly. Red Hat Single Sign-On provides a <a class="link" href="#enforcer_overview" title="Chapter 9. Policy enforcers">policy enforcer</a> that enables UMA for your resource server so it can obtain a permission ticket from the authorization server, return this ticket to client application, and enforce authorization decisions based on a final requesting party token (RPT).
				</p><p>
					The process of obtaining permission tickets from Red Hat Single Sign-On is performed by resource servers and not regular client applications, where permission tickets are obtained when a client tries to access a protected resource without the necessary grants to access the resource. The issuance of permission tickets is an important aspects when using UMA as it allows resource servers to:
				</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">
							Abstract from clients the data associated with the resources protected by the resource server
						</li><li class="listitem">
							Register in the Red Hat Single Sign-On authorization requests which in turn can be used later in workflows to grant access based on the resource’s owner consent
						</li><li class="listitem">
							Decouple resource servers from authorization servers and allow them to protect and manage their resources using different authorization servers
						</li></ul></div><p>
					Client wise, a permission ticket has also important aspects that its worthy to highlight:
				</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">
							Clients don’t need to know about how authorization data is associated with protected resources. A permission ticket is completely opaque to clients.
						</li><li class="listitem">
							Clients can have access to resources on different resource servers and protected by different authorization servers
						</li></ul></div><p>
					These are just some of the benefits brought by UMA where other aspects of UMA are strongly based on permission tickets, specially regarding privacy and user controlled access to their resources.
				</p><section class="section" id="creating_permission_ticket"><div class="titlepage"><div><div><h4 class="title">8.4.3.1. Creating permission ticket</h4></div></div></div><p>
						To create a permission ticket, send an HTTP POST request as follows:
					</p><pre class="programlisting language-bash">curl -X POST \
  http://${host}:${port}/auth/realms/${realm_name}/authz/protection/permission \
  -H 'Authorization: Bearer '$pat \
  -H 'Content-Type: application/json' \
  -d '[
  {
    "resource_id": "{resource_id}",
    "resource_scopes": [
      "view"
    ]
  }
]'</pre><p>
						When creating tickets you can also push arbitrary claims and associate these claims with the ticket:
					</p><pre class="programlisting language-bash">curl -X POST \
  http://${host}:${port}/auth/realms/${realm_name}/authz/protection/permission \
  -H 'Authorization: Bearer '$pat \
  -H 'Content-Type: application/json' \
  -d '[
  {
    "resource_id": "{resource_id}",
    "resource_scopes": [
      "view"
    ],
    "claims": {
        "organization": ["acme"]
    }
  }
]'</pre><p>
						Where these claims will be available to your policies when evaluating permissions for the resource and scope(s) associated with the permission ticket.
					</p></section><section class="section" id="other_non_uma_compliant_endpoints"><div class="titlepage"><div><div><h4 class="title">8.4.3.2. Other non UMA-compliant endpoints</h4></div></div></div><section class="section" id="creating_permission_ticket_2"><div class="titlepage"><div><div><h5 class="title">8.4.3.2.1. Creating permission ticket</h5></div></div></div><p>
							To grant permissions for a specific resource with id {resource_id} to a user with id {user_id}, as an owner of the resource send an HTTP POST request as follows:
						</p><pre class="programlisting language-bash">curl -X POST \
     http://${host}:${port}/auth/realms/${realm_name}/authz/protection/permission/ticket \
     -H 'Authorization: Bearer '$access_token \
     -H 'Content-Type: application/json' \
     -d '{
       "resource": "{resource_id}",
       "requester": "{user_id}",
       "granted": true,
       "scopeName": "view"
     }'</pre></section><section class="section" id="getting_permission_tickets"><div class="titlepage"><div><div><h5 class="title">8.4.3.2.2. Getting permission tickets</h5></div></div></div><pre class="programlisting language-bash">curl http://${host}:${port}/auth/realms/${realm_name}/authz/protection/permission/ticket \
     -H 'Authorization: Bearer '$access_token</pre><p>
							You can use any of these query parameters:
						</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">
									<code class="literal">scopeId</code>
								</li><li class="listitem">
									<code class="literal">resourceId</code>
								</li><li class="listitem">
									<code class="literal">owner</code>
								</li><li class="listitem">
									<code class="literal">requester</code>
								</li><li class="listitem">
									<code class="literal">granted</code>
								</li><li class="listitem">
									<code class="literal">returnNames</code>
								</li><li class="listitem">
									<code class="literal">first</code>
								</li><li class="listitem">
									<code class="literal">max</code>
								</li></ul></div></section><section class="section" id="updating_permission_ticket"><div class="titlepage"><div><div><h5 class="title">8.4.3.2.3. Updating permission ticket</h5></div></div></div><pre class="programlisting language-bash">curl -X PUT \
     http://${host}:${port}/auth/realms/${realm_name}/authz/protection/permission/ticket \
     -H 'Authorization: Bearer '$access_token \
     -H 'Content-Type: application/json' \
     -d '{
       "id": "{ticket_id}"
       "resource": "{resource_id}",
       "requester": "{user_id}",
       "granted": false,
       "scopeName": "view"
     }'</pre></section><section class="section" id="deleting_permission_ticket"><div class="titlepage"><div><div><h5 class="title">8.4.3.2.4. Deleting permission ticket</h5></div></div></div><pre class="programlisting language-bash">curl -X DELETE http://${host}:${port}/auth/realms/${realm_name}/authz/protection/permission/ticket/{ticket_id} \
     -H 'Authorization: Bearer '$access_token</pre></section></section></section><section class="section" id="service_authorization_uma_policy_api"><div class="titlepage"><div><div><h3 class="title">8.4.4. Managing resource permissions using the Policy API</h3></div></div></div><p>
					Red Hat Single Sign-On leverages the UMA Protection API to allow resource servers to manage permissions for their users. In addition to the Resource and Permission APIs, Red Hat Single Sign-On provides a Policy API from where permissions can be set to resources by resource servers on behalf of their users.
				</p><p>
					The Policy API is available at:
				</p><pre class="screen">http://${host}:${port}/auth/realms/${realm_name}/authz/protection/uma-policy/{resource_id}</pre><p>
					This API is protected by a bearer token that must represent a consent granted by the user to the resource server to manage permissions on his behalf. The bearer token can be a regular access token obtained from the token endpoint using:
				</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">
							Resource Owner Password Credentials Grant Type
						</li><li class="listitem">
							Token Exchange, in order to exchange an access token granted to some client (public client) for a token where audience is the resource server
						</li></ul></div><section class="section" id="associating_a_permission_with_a_resource"><div class="titlepage"><div><div><h4 class="title">8.4.4.1. Associating a permission with a resource</h4></div></div></div><p>
						To associate a permission with a specific resource you must send a HTTP POST request as follows:
					</p><pre class="programlisting language-bash">curl -X POST \
  http://localhost:8180/auth/realms/photoz/authz/protection/uma-policy/{resource_id} \
  -H 'Authorization: Bearer '$access_token \
  -H 'Cache-Control: no-cache' \
  -H 'Content-Type: application/json' \
  -d '{
	"name": "Any people manager",
	"description": "Allow access to any people manager",
	"scopes": ["read"],
	"roles": ["people-manager"]
}'</pre><p>
						In the example above we are creating and associating a new permission to a resource represented by <code class="literal">resource_id</code> where any user with a role <code class="literal">people-manager</code> should be granted with the <code class="literal">read</code> scope.
					</p><p>
						You can also create policies using other access control mechanisms, such as using groups:
					</p><pre class="programlisting language-bash">curl -X POST \
  http://localhost:8180/auth/realms/photoz/authz/protection/uma-policy/{resource_id} \
  -H 'Authorization: Bearer '$access_token \
  -H 'Cache-Control: no-cache' \
  -H 'Content-Type: application/json' \
  -d '{
	"name": "Any people manager",
	"description": "Allow access to any people manager",
	"scopes": ["read"],
	"groups": ["/Managers/People Managers"]
}'</pre><p>
						Or a specific client:
					</p><pre class="programlisting language-bash">curl -X POST \
  http://localhost:8180/auth/realms/photoz/authz/protection/uma-policy/{resource_id} \
  -H 'Authorization: Bearer '$access_token \
  -H 'Cache-Control: no-cache' \
  -H 'Content-Type: application/json' \
  -d '{
	"name": "Any people manager",
	"description": "Allow access to any people manager",
	"scopes": ["read"],
	"clients": ["my-client"]
}'</pre><p>
						Or even using a custom policy using JavaScript:
					</p><div class="admonition note"><div class="admonition_header">Note</div><div><p>
							Upload Scripts is <span class="strong strong"><strong>Deprecated</strong></span> and will be removed in future releases. This feature is disabled by default.
						</p><p>
							To enable start the server with <code class="literal">-Dkeycloak.profile.feature.upload_scripts=enabled</code> . For more details see <a class="link" href="https://access.redhat.com/documentation/en-us/red_hat_single_sign-on/7.4/html-single/server_installation_and_configuration_guide/#profiles">Profiles</a>.
						</p></div></div><pre class="programlisting language-bash">curl -X POST \
  http://localhost:8180/auth/realms/photoz/authz/protection/uma-policy/{resource_id} \
  -H 'Authorization: Bearer '$access_token \
  -H 'Cache-Control: no-cache' \
  -H 'Content-Type: application/json' \
  -d '{
	"name": "Any people manager",
	"description": "Allow access to any people manager",
	"scopes": ["read"],
	"condition": "if (isPeopleManager()) {$evaluation.grant()}"
}'</pre><p>
						It is also possible to set any combination of these access control mechanisms.
					</p><p>
						To update an existing permission, send an HTTP PUT request as follows:
					</p><pre class="programlisting language-bash">curl -X PUT \
  http://localhost:8180/auth/realms/photoz/authz/protection/uma-policy/{permission_id} \
  -H 'Authorization: Bearer '$access_token \
  -H 'Content-Type: application/json' \
  -d '{
    "id": "21eb3fed-02d7-4b5a-9102-29f3f09b6de2",
    "name": "Any people manager",
    "description": "Allow access to any people manager",
    "type": "uma",
    "scopes": [
        "album:view"
    ],
    "logic": "POSITIVE",
    "decisionStrategy": "UNANIMOUS",
    "owner": "7e22131a-aa57-4f5f-b1db-6e82babcd322",
    "roles": [
        "user"
    ]
}'</pre></section><section class="section" id="removing_a_permission"><div class="titlepage"><div><div><h4 class="title">8.4.4.2. Removing a permission</h4></div></div></div><p>
						To remove a permission associated with a resource, send an HTTP DELETE request as follows:
					</p><pre class="programlisting language-bash">curl -X DELETE \
  http://localhost:8180/auth/realms/photoz/authz/protection/uma-policy/{permission_id} \
  -H 'Authorization: Bearer '$access_token</pre></section><section class="section" id="querying_permission"><div class="titlepage"><div><div><h4 class="title">8.4.4.3. Querying permission</h4></div></div></div><p>
						To query the permissions associated with a resource, send an HTTP GET request as follows:
					</p><pre class="programlisting language-bash">http://${host}:${port}/auth/realms/${realm}/authz/protection/uma-policy?resource={resource_id}</pre><p>
						To query the permissions given its name, send an HTTP GET request as follows:
					</p><pre class="programlisting language-bash">http://${host}:${port}/auth/realms/${realm}/authz/protection/uma-policy?name=Any people manager</pre><p>
						To query the permissions associated with a specific scope, send an HTTP GET request as follows:
					</p><pre class="programlisting language-bash">http://${host}:${port}/auth/realms/${realm}/authz/protection/uma-policy?scope=read</pre><p>
						To query all permissions, send an HTTP GET request as follows:
					</p><pre class="programlisting language-bash">http://${host}:${port}/auth/realms/${realm}/authz/protection/uma-policy</pre><p>
						When querying the server for permissions use parameters <code class="literal">first</code> and <code class="literal">max</code> results to limit the result.
					</p></section></section></section><section class="section" id="service_rpt_overview"><div class="titlepage"><div><div><h2 class="title">8.5. Requesting party token</h2></div></div></div><p>
				A requesting party token (RPT) is a <a class="link" href="https://datatracker.ietf.org/doc/html/rfc7519">JSON web token (JWT)</a> digitally signed using <a class="link" href="https://datatracker.ietf.org/doc/html/rfc7515">JSON web signature (JWS)</a>. The token is built based on the OAuth2 access token previously issued by Red Hat Single Sign-On to a specific client acting on behalf of a user or on its own behalf.
			</p><p>
				When you decode an RPT, you see a payload similar to the following:
			</p><pre class="programlisting language-json">{
  "authorization": {
      "permissions": [
        {
          "resource_set_id": "d2fe9843-6462-4bfc-baba-b5787bb6e0e7",
          "resource_set_name": "Hello World Resource"
        }
      ]
  },
  "jti": "d6109a09-78fd-4998-bf89-95730dfd0892-1464906679405",
  "exp": 1464906971,
  "nbf": 0,
  "iat": 1464906671,
  "sub": "f1888f4d-5172-4359-be0c-af338505d86c",
  "typ": "kc_ett",
  "azp": "hello-world-authz-service"
}</pre><p>
				From this token you can obtain all permissions granted by the server from the <span class="strong strong"><strong>permissions</strong></span> claim.
			</p><p>
				Also note that permissions are directly related with the resources/scopes you are protecting and completely decoupled from the access control methods that were used to actually grant and issue these same permissions.
			</p><section class="section" id="service_protection_token_introspection"><div class="titlepage"><div><div><h3 class="title">8.5.1. Introspecting a requesting party token</h3></div></div></div><p>
					Sometimes you might want to introspect a requesting party token (RPT) to check its validity or obtain the permissions within the token to enforce authorization decisions on the resource server side.
				</p><p>
					There are two main use cases where token introspection can help you:
				</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">
							When client applications need to query the token validity to obtain a new one with the same or additional permissions
						</li><li class="listitem">
							When enforcing authorization decisions at the resource server side, especially when none of the built-in <a class="link" href="#enforcer_overview" title="Chapter 9. Policy enforcers">policy enforcers</a> fits your application
						</li></ul></div></section><section class="section" id="obtaining_information_about_an_rpt"><div class="titlepage"><div><div><h3 class="title">8.5.2. Obtaining Information about an RPT</h3></div></div></div><p>
					The token introspection is essentially a <a class="link" href="https://datatracker.ietf.org/doc/html/rfc7662">OAuth2 token introspection</a>-compliant endpoint from which you can obtain information about an RPT.
				</p><pre class="screen">http://${host}:${port}/auth/realms/${realm_name}/protocol/openid-connect/token/introspect</pre><p>
					To introspect an RPT using this endpoint, you can send a request to the server as follows:
				</p><pre class="programlisting language-bash">curl -X POST \
    -H "Authorization: Basic aGVsbG8td29ybGQtYXV0aHotc2VydmljZTpzZWNyZXQ=" \
    -H "Content-Type: application/x-www-form-urlencoded" \
    -d 'token_type_hint=requesting_party_token&amp;token=${RPT}' \
    "http://localhost:8080/auth/realms/hello-world-authz/protocol/openid-connect/token/introspect"</pre><div class="admonition note"><div class="admonition_header">Note</div><div><p>
						The request above is using HTTP BASIC and passing the client’s credentials (client ID and secret) to authenticate the client attempting to introspect the token, but you can use any other client authentication method supported by Red Hat Single Sign-On.
					</p></div></div><p>
					The introspection endpoint expects two parameters:
				</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p class="simpara">
							<span class="strong strong"><strong>token_type_hint</strong></span>
						</p><p class="simpara">
							Use <span class="strong strong"><strong>requesting_party_token</strong></span> as the value for this parameter, which indicates that you want to introspect an RPT.
						</p></li><li class="listitem"><p class="simpara">
							<span class="strong strong"><strong>token</strong></span>
						</p><p class="simpara">
							Use the token string as it was returned by the server during the authorization process as the value for this parameter.
						</p></li></ul></div><p>
					As a result, the server response is:
				</p><pre class="programlisting language-json">{
  "permissions": [
    {
      "resource_id": "90ccc6fc-b296-4cd1-881e-089e1ee15957",
      "resource_name": "Hello World Resource"
    }
  ],
  "exp": 1465314139,
  "nbf": 0,
  "iat": 1465313839,
  "aud": "hello-world-authz-service",
  "active": true
}</pre><p>
					If the RPT is not active, this response is returned instead:
				</p><pre class="programlisting language-json">{
  "active": false
}</pre></section><section class="section" id="do_i_need_to_invoke_the_server_every_time_i_want_to_introspect_an_rpt"><div class="titlepage"><div><div><h3 class="title">8.5.3. Do I need to invoke the server every time I want to introspect an RPT?</h3></div></div></div><p>
					No. Just like a regular access token issued by a Red Hat Single Sign-On server, RPTs also use the JSON web token (JWT) specification as the default format.
				</p><p>
					If you want to validate these tokens without a call to the remote introspection endpoint, you can decode the RPT and query for its validity locally. Once you decode the token, you can also use the permissions within the token to enforce authorization decisions.
				</p><p>
					This is essentially what the policy enforcers do. Be sure to:
				</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">
							Validate the signature of the RPT (based on the realm’s public key)
						</li><li class="listitem">
							Query for token validity based on its <span class="emphasis"><em>exp</em></span>, <span class="emphasis"><em>iat</em></span>, and <span class="emphasis"><em>aud</em></span> claims
						</li></ul></div><div class="itemizedlist _additional-resources"><p class="title"><strong>Additional resources</strong></p><ul class="itemizedlist _additional-resources" type="disc"><li class="listitem">
							<a class="link" href="https://datatracker.ietf.org/doc/html/rfc7519">JSON web token (JWT)</a>
						</li><li class="listitem">
							<a class="link" href="#enforcer_overview" title="Chapter 9. Policy enforcers">policy enforcers</a>
						</li></ul></div></section></section><section class="section" id="service_client_api"><div class="titlepage"><div><div><h2 class="title">8.6. Authorization client java API</h2></div></div></div><p>
				Depending on your requirements, a resource server should be able to manage resources remotely or even check for permissions programmatically. If you are using Java, you can access the Red Hat Single Sign-On Authorization Services using the Authorization Client API.
			</p><p>
				It is targeted for resource servers that want to access the different endpoints provided by the server such as the Token Endpoint, Resource, and Permission management endpoints.
			</p><section class="section" id="maven_dependency"><div class="titlepage"><div><div><h3 class="title">8.6.1. Maven dependency</h3></div></div></div><pre class="programlisting language-xml">&lt;dependencies&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;org.keycloak&lt;/groupId&gt;
        &lt;artifactId&gt;keycloak-authz-client&lt;/artifactId&gt;
        &lt;version&gt;${KEYCLOAK_VERSION}&lt;/version&gt;
    &lt;/dependency&gt;
&lt;/dependencies&gt;</pre></section><section class="section" id="configuration_11"><div class="titlepage"><div><div><h3 class="title">8.6.2. Configuration</h3></div></div></div><p>
					The client configuration is defined in a <code class="literal">keycloak.json</code> file as follows:
				</p><pre class="programlisting language-json">{
  "realm": "hello-world-authz",
  "auth-server-url" : "http://localhost:8080/auth",
  "resource" : "hello-world-authz-service",
  "credentials": {
    "secret": "secret"
  }
}</pre><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p class="simpara">
							<span class="strong strong"><strong>realm</strong></span> (required)
						</p><p class="simpara">
							The name of the realm.
						</p></li><li class="listitem"><p class="simpara">
							<span class="strong strong"><strong>auth-server-url</strong></span> (required)
						</p><p class="simpara">
							The base URL of the Red Hat Single Sign-On server. All other Red Hat Single Sign-On pages and REST service endpoints are derived from this. It is usually in the form <a class="link" href="https://host:port/auth">https://host:port/auth</a>.
						</p></li><li class="listitem"><p class="simpara">
							<span class="strong strong"><strong>resource</strong></span> (required)
						</p><p class="simpara">
							The client-id of the application. Each application has a client-id that is used to identify the application.
						</p></li><li class="listitem"><p class="simpara">
							<span class="strong strong"><strong>credentials</strong></span> (required)
						</p><p class="simpara">
							Specifies the credentials of the application. This is an object notation where the key is the credential type and the value is the value of the credential type.
						</p></li></ul></div><p>
					The configuration file is usually located in your application’s classpath, the default location from where the client is going to try to find a <code class="literal"><code class="literal">keycloak.json</code></code> file.
				</p></section><section class="section" id="creating_the_authorization_client"><div class="titlepage"><div><div><h3 class="title">8.6.3. Creating the authorization client</h3></div></div></div><p>
					Considering you have a <code class="literal"><code class="literal">keycloak.json</code></code> file in your classpath, you can create a new <code class="literal"><code class="literal">AuthzClient</code></code> instance as follows:
				</p><pre class="programlisting language-java">    // create a new instance based on the configuration defined in a keycloak.json located in your classpath
    AuthzClient authzClient = AuthzClient.create();</pre></section><section class="section" id="obtaining_user_entitlements"><div class="titlepage"><div><div><h3 class="title">8.6.4. Obtaining user entitlements</h3></div></div></div><p>
					Here is an example illustrating how to obtain user entitlements:
				</p><pre class="programlisting language-java">// create a new instance based on the configuration defined in keycloak.json
AuthzClient authzClient = AuthzClient.create();

// create an authorization request
AuthorizationRequest request = new AuthorizationRequest();

// send the entitlement request to the server in order to
// obtain an RPT with all permissions granted to the user
AuthorizationResponse response = authzClient.authorization("alice", "alice").authorize(request);
String rpt = response.getToken();

System.out.println("You got an RPT: " + rpt);

// now you can use the RPT to access protected resources on the resource server</pre><p>
					Here is an example illustrating how to obtain user entitlements for a set of one or more resources:
				</p><pre class="programlisting language-java">// create a new instance based on the configuration defined in keycloak.json
AuthzClient authzClient = AuthzClient.create();

// create an authorization request
AuthorizationRequest request = new AuthorizationRequest();

// add permissions to the request based on the resources and scopes you want to check access
request.addPermission("Default Resource");

// send the entitlement request to the server in order to
// obtain an RPT with permissions for a single resource
AuthorizationResponse response = authzClient.authorization("alice", "alice").authorize(request);
String rpt = response.getToken();

System.out.println("You got an RPT: " + rpt);

// now you can use the RPT to access protected resources on the resource server</pre></section><section class="section" id="creating_a_resource_using_the_protection_api"><div class="titlepage"><div><div><h3 class="title">8.6.5. Creating a resource using the protection API</h3></div></div></div><pre class="programlisting language-java">// create a new instance based on the configuration defined in keycloak.json
AuthzClient authzClient = AuthzClient.create();

// create a new resource representation with the information we want
ResourceRepresentation newResource = new ResourceRepresentation();

newResource.setName("New Resource");
newResource.setType("urn:hello-world-authz:resources:example");

newResource.addScope(new ScopeRepresentation("urn:hello-world-authz:scopes:view"));

ProtectedResource resourceClient = authzClient.protection().resource();
ResourceRepresentation existingResource = resourceClient.findByName(newResource.getName());

if (existingResource != null) {
    resourceClient.delete(existingResource.getId());
}

// create the resource on the server
ResourceRepresentation response = resourceClient.create(newResource);
String resourceId = response.getId();

// query the resource using its newly generated id
ResourceRepresentation resource = resourceClient.findById(resourceId);

System.out.println(resource);</pre></section><section class="section" id="introspecting_an_rpt"><div class="titlepage"><div><div><h3 class="title">8.6.6. Introspecting an RPT</h3></div></div></div><pre class="programlisting language-java">// create a new instance based on the configuration defined in keycloak.json
AuthzClient authzClient = AuthzClient.create();

// send the authorization request to the server in order to
// obtain an RPT with all permissions granted to the user
AuthorizationResponse response = authzClient.authorization("alice", "alice").authorize();
String rpt = response.getToken();

// introspect the token
TokenIntrospectionResponse requestingPartyToken = authzClient.protection().introspectRequestingPartyToken(rpt);

System.out.println("Token status is: " + requestingPartyToken.getActive());
System.out.println("Permissions granted by the server: ");

for (Permission granted : requestingPartyToken.getPermissions()) {
    System.out.println(granted);
}</pre></section></section></section><section class="chapter" id="enforcer_overview"><div class="titlepage"><div><div><h1 class="title">Chapter 9. Policy enforcers</h1></div></div></div><p>
			Policy Enforcement Point (PEP) is a design pattern and as such you can implement it in different ways. Red Hat Single Sign-On provides all the necessary means to implement PEPs for different platforms, environments, and programming languages. Red Hat Single Sign-On Authorization Services presents a RESTful API, and leverages OAuth2 authorization capabilities for fine-grained authorization using a centralized authorization server.
		</p><p>
			<span class="inlinemediaobject"><img src="images/pep-pattern-diagram.png" alt="PEP Overview"/></span>
		</p><p>
			A PEP is responsible for enforcing access decisions from the Red Hat Single Sign-On server where these decisions are taken by evaluating the policies associated with a protected resource. It acts as a filter or interceptor in your application in order to check whether or not a particular request to a protected resource can be fulfilled based on the permissions granted by these decisions.
		</p><p>
			Permissions are enforced depending on the protocol you are using. When using UMA, the policy enforcer always expects an RPT as a bearer token in order to decide whether or not a request can be served. That means clients should first obtain an RPT from Red Hat Single Sign-On before sending requests to the resource server.
		</p><p>
			However, if you are not using UMA, you can also send regular access tokens to the resource server. In this case, the policy enforcer will try to obtain permissions directly from the server.
		</p><p>
			If you are using any of the Red Hat Single Sign-On OIDC adapters, you can easily enable the policy enforcer by adding the following property to your <span class="strong strong"><strong>keycloak.json</strong></span> file:
		</p><div class="formalpara"><p class="title"><strong>keycloak.json</strong></p><p>
				
<pre class="programlisting language-json">{
 "policy-enforcer": {}
}</pre>
			</p></div><p>
			When you enable the policy enforcer all requests sent your application are intercepted and access to protected resources will be granted depending on the permissions granted by Red Hat Single Sign-On to the identity making the request.
		</p><p>
			Policy enforcement is strongly linked to your application’s paths and the <a class="link" href="#resource_overview" title="Chapter 4. Managing resources and scopes">resources</a> you created for a resource server using the Red Hat Single Sign-On Administration Console. By default, when you create a resource server, Red Hat Single Sign-On creates a <a class="link" href="#resource_server_default_config" title="3.3. Default Configuration">default configuration</a> for your resource server so you can enable policy enforcement quickly.
		</p><section class="section" id="enforcer_filter"><div class="titlepage"><div><div><h2 class="title">9.1. Configuration</h2></div></div></div><p>
				To enable policy enforcement for your application, add the following property to your <span class="strong strong"><strong>keycloak.json</strong></span> file:
			</p><div class="formalpara"><p class="title"><strong>keycloak.json</strong></p><p>
					
<pre class="programlisting language-json">{
  "policy-enforcer": {}
}</pre>
				</p></div><p>
				Or a little more verbose if you want to manually define the resources being protected:
			</p><pre class="programlisting language-json">{
  "policy-enforcer": {
    "user-managed-access" : {},
    "enforcement-mode" : "ENFORCING",
    "paths": [
      {
        "path" : "/someUri/*",
        "methods" : [
          {
            "method": "GET",
            "scopes" : ["urn:app.com:scopes:view"]
          },
          {
            "method": "POST",
            "scopes" : ["urn:app.com:scopes:create"]
          }
        ]
      },
      {
        "name" : "Some Resource",
        "path" : "/usingPattern/{id}",
        "methods" : [
          {
            "method": "DELETE",
            "scopes" : ["urn:app.com:scopes:delete"]
          }
        ]
      },
      {
        "path" : "/exactMatch"
      },
      {
        "name" : "Admin Resources",
        "path" : "/usingWildCards/*"
      }
    ]
  }
}</pre><p>
				Here is a description of each configuration option:
			</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p class="simpara">
						<span class="strong strong"><strong>policy-enforcer</strong></span>
					</p><p class="simpara">
						Specifies the configuration options that define how policies are actually enforced and optionally the paths you want to protect. If not specified, the policy enforcer queries the server for all resources associated with the resource server being protected. In this case, you need to ensure the resources are properly configured with a <a class="link" href="#resource_create_uri">URIS</a> property that matches the paths you want to protect.
					</p><div class="itemizedlist"><ul class="itemizedlist" type="circle"><li class="listitem"><p class="simpara">
								<span class="strong strong"><strong>user-managed-access</strong></span>
							</p><p class="simpara">
								Specifies that the adapter uses the UMA protocol. If specified, the adapter queries the server for permission tickets and returns them to clients according to the UMA specification. If not specified, the policy enforcer will be able to enforce permissions based on regular access tokens or RPTs. In this case, before denying access to the resource when the token lacks permission, the policy enforcer will try to obtain permissions directly from the server.
							</p></li><li class="listitem"><p class="simpara">
								<span class="strong strong"><strong>enforcement-mode</strong></span>
							</p><p class="simpara">
								Specifies how policies are enforced.
							</p><div class="itemizedlist"><ul class="itemizedlist" type="square"><li class="listitem"><p class="simpara">
										<span class="strong strong"><strong>ENFORCING</strong></span>
									</p><p class="simpara">
										(default mode) Requests are denied by default even when there is no policy associated with a given resource.
									</p></li><li class="listitem"><p class="simpara">
										<span class="strong strong"><strong>PERMISSIVE</strong></span>
									</p><p class="simpara">
										Requests are allowed even when there is no policy associated with a given resource.
									</p></li><li class="listitem"><p class="simpara">
										<span class="strong strong"><strong>DISABLED</strong></span>
									</p><p class="simpara">
										Completely disables the evaluation of policies and allows access to any resource. When <code class="literal">enforcement-mode</code> is <code class="literal">DISABLED</code> applications are still able to obtain all permissions granted by Red Hat Single Sign-On through the <a class="link" href="#enforcer_authorization_context" title="9.3. Obtaining the authorization context">Authorization Context</a>
									</p></li></ul></div></li><li class="listitem"><p class="simpara">
								<span class="strong strong"><strong>on-deny-redirect-to</strong></span>
							</p><p class="simpara">
								Defines a URL where a client request is redirected when an "access denied" message is obtained from the server. By default, the adapter responds with a 403 HTTP status code.
							</p></li><li class="listitem"><p class="simpara">
								<span class="strong strong"><strong>path-cache</strong></span>
							</p><p class="simpara">
								Defines how the policy enforcer should track associations between paths in your application and resources defined in Red Hat Single Sign-On. The cache is needed to avoid unnecessary requests to a Red Hat Single Sign-On server by caching associations between paths and protected resources.
							</p><div class="itemizedlist"><ul class="itemizedlist" type="square"><li class="listitem"><p class="simpara">
										<span class="strong strong"><strong>lifespan</strong></span>
									</p><p class="simpara">
										Defines the time in milliseconds when the entry should be expired. If not provided, default value is <span class="strong strong"><strong>3000</strong></span>. A value equal to 0 can be set to completely disable the cache. A value equal to -1 can be set to disable the expiry of the cache.
									</p></li><li class="listitem"><p class="simpara">
										<span class="strong strong"><strong>max-entries</strong></span>
									</p><p class="simpara">
										Defines the limit of entries that should be kept in the cache. If not provided, default value is <span class="strong strong"><strong>1000</strong></span>.
									</p></li></ul></div></li><li class="listitem"><p class="simpara">
								<span class="strong strong"><strong>paths</strong></span>
							</p><p class="simpara">
								Specifies the paths to protect. This configuration is optional. If not defined, the policy enforcer will discover all paths by fetching the resources you defined to your application in Red Hat Single Sign-On, where these resources are defined with <code class="literal">URIS</code> representing some paths in your application.
							</p><div class="itemizedlist"><ul class="itemizedlist" type="square"><li class="listitem"><p class="simpara">
										<span class="strong strong"><strong>name</strong></span>
									</p><p class="simpara">
										The name of a resource on the server that is to be associated with a given path. When used in conjunction with a <span class="strong strong"><strong>path</strong></span>, the policy enforcer ignores the resource’s <span class="strong strong"><strong>URIS</strong></span> property and uses the path you provided instead.
									</p></li><li class="listitem"><p class="simpara">
										<span class="strong strong"><strong>path</strong></span>
									</p><p class="simpara">
										(required) A URI relative to the application’s context path. If this option is specified, the policy enforcer queries the server for a resource with a <span class="strong strong"><strong>URI</strong></span> with the same value. Currently a very basic logic for path matching is supported. Examples of valid paths are:
									</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">
												Wildcards: <code class="literal">/*</code>
											</li><li class="listitem">
												Suffix: <code class="literal">/*.html</code>
											</li><li class="listitem">
												Sub-paths: <code class="literal">/path/*</code>
											</li><li class="listitem">
												Path parameters: /resource/{id}
											</li><li class="listitem">
												Exact match: /resource
											</li><li class="listitem">
												Patterns: /{version}/resource, /api/{version}/resource, /api/{version}/resource/*
											</li></ul></div></li><li class="listitem"><p class="simpara">
										<span class="strong strong"><strong>methods</strong></span>
									</p><p class="simpara">
										The HTTP methods (for example, GET, POST, PATCH) to protect and how they are associated with the scopes for a given resource in the server.
									</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p class="simpara">
												<span class="strong strong"><strong>method</strong></span>
											</p><p class="simpara">
												The name of the HTTP method.
											</p></li><li class="listitem"><p class="simpara">
												<span class="strong strong"><strong>scopes</strong></span>
											</p><p class="simpara">
												An array of strings with the scopes associated with the method. When you associate scopes with a specific method, the client trying to access a protected resource (or path) must provide an RPT that grants permission to all scopes specified in the list. For example, if you define a method <span class="emphasis"><em>POST</em></span> with a scope <span class="emphasis"><em>create</em></span>, the RPT must contain a permission granting access to the <span class="emphasis"><em>create</em></span> scope when performing a POST to the path.
											</p></li><li class="listitem"><p class="simpara">
												<span class="strong strong"><strong>scopes-enforcement-mode</strong></span>
											</p><p class="simpara">
												A string referencing the enforcement mode for the scopes associated with a method. Values can be <span class="strong strong"><strong>ALL</strong></span> or <span class="strong strong"><strong>ANY</strong></span>. If <span class="strong strong"><strong>ALL</strong></span>, all defined scopes must be granted in order to access the resource using that method. If <span class="strong strong"><strong>ANY</strong></span>, at least one scope should be granted in order to gain access to the resource using that method. By default, enforcement mode is set to <span class="strong strong"><strong>ALL</strong></span>.
											</p></li></ul></div></li><li class="listitem"><p class="simpara">
										<span class="strong strong"><strong>enforcement-mode</strong></span>
									</p><p class="simpara">
										Specifies how policies are enforced.
									</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p class="simpara">
												<span class="strong strong"><strong>ENFORCING</strong></span>
											</p><p class="simpara">
												(default mode) Requests are denied by default even when there is no policy associated with a given resource.
											</p></li><li class="listitem">
												<span class="strong strong"><strong>DISABLED</strong></span>
											</li></ul></div></li><li class="listitem"><p class="simpara">
										<span class="strong strong"><strong>claim-information-point</strong></span>
									</p><p class="simpara">
										Defines a set of one or more claims that must be resolved and pushed to the Red Hat Single Sign-On server in order to make these claims available to policies. See <a class="link" href="#enforcer_claim_information_point" title="9.2. Claim Information Point">Claim Information Point</a> for more details.
									</p></li></ul></div></li><li class="listitem"><p class="simpara">
								<span class="strong strong"><strong>lazy-load-paths</strong></span>
							</p><p class="simpara">
								Specifies how the adapter should fetch the server for resources associated with paths in your application. If <span class="strong strong"><strong>true</strong></span>, the policy enforcer is going to fetch resources on-demand accordingly with the path being requested. This configuration is specially useful when you don’t want to fetch all resources from the server during deployment (in case you have provided no <code class="literal">paths</code>) or in case you have defined only a sub set of <code class="literal">paths</code> and want to fetch others on-demand.
							</p></li><li class="listitem"><p class="simpara">
								<span class="strong strong"><strong>http-method-as-scope</strong></span>
							</p><p class="simpara">
								Specifies how scopes should be mapped to HTTP methods. If set to <span class="strong strong"><strong>true</strong></span>, the policy enforcer will use the HTTP method from the current request to check whether or not access should be granted. When enabled, make sure your resources in Red Hat Single Sign-On are associated with scopes representing each HTTP method you are protecting.
							</p></li><li class="listitem"><p class="simpara">
								<span class="strong strong"><strong>claim-information-point</strong></span>
							</p><p class="simpara">
								Defines a set of one or more <span class="strong strong"><strong>global</strong></span> claims that must be resolved and pushed to the Red Hat Single Sign-On server in order to make these claims available to policies. See <a class="link" href="#enforcer_claim_information_point" title="9.2. Claim Information Point">Claim Information Point</a> for more details.
							</p></li></ul></div></li></ul></div></section><section class="section" id="enforcer_claim_information_point"><div class="titlepage"><div><div><h2 class="title">9.2. Claim Information Point</h2></div></div></div><p>
				A Claim Information Point (CIP) is responsible for resolving claims and pushing these claims to the Red Hat Single Sign-On server in order to provide more information about the access context to policies. They can be defined as a configuration option to the policy-enforcer in order to resolve claims from different sources, such as:
			</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">
						HTTP Request (parameters, headers, body, etc)
					</li><li class="listitem">
						External HTTP Service
					</li><li class="listitem">
						Static values defined in configuration
					</li><li class="listitem">
						Any other source by implementing the Claim Information Provider SPI
					</li></ul></div><p>
				When pushing claims to the Red Hat Single Sign-On server, policies can base decisions not only on who a user is but also by taking context and contents into account, based on who, what, why, when, where, and which for a given transaction. It is all about Contextual-based Authorization and how to use runtime information in order to support fine-grained authorization decisions.
			</p><section class="section" id="obtaining_information_from_the_http_request"><div class="titlepage"><div><div><h3 class="title">9.2.1. Obtaining information from the HTTP request</h3></div></div></div><p>
					Here are several examples showing how you can extract claims from an HTTP request:
				</p><div class="formalpara"><p class="title"><strong>keycloak.json</strong></p><p>
						
<pre class="programlisting language-json">"policy-enforcer": {
    "paths": [
      {
        "path": "/protected/resource",
        "claim-information-point": {
          "claims": {
            "claim-from-request-parameter": "{request.parameter['a']}",
            "claim-from-header": "{request.header['b']}",
            "claim-from-cookie": "{request.cookie['c']}",
            "claim-from-remoteAddr": "{request.remoteAddr}",
            "claim-from-method": "{request.method}",
            "claim-from-uri": "{request.uri}",
            "claim-from-relativePath": "{request.relativePath}",
            "claim-from-secure": "{request.secure}",
            "claim-from-json-body-object": "{request.body['/a/b/c']}",
            "claim-from-json-body-array": "{request.body['/d/1']}",
            "claim-from-body": "{request.body}",
            "claim-from-static-value": "static value",
            "claim-from-multiple-static-value": ["static", "value"],
            "param-replace-multiple-placeholder": "Test {keycloak.access_token['/custom_claim/0']} and {request.parameter['a']} "
          }
        }
      }
    ]
  }</pre>
					</p></div></section><section class="section" id="obtaining_information_from_an_external_http_service"><div class="titlepage"><div><div><h3 class="title">9.2.2. Obtaining information from an external HTTP service</h3></div></div></div><p>
					Here are several examples showing how you can extract claims from an external HTTP Service:
				</p><div class="formalpara"><p class="title"><strong>keycloak.json</strong></p><p>
						
<pre class="programlisting language-json">"policy-enforcer": {
    "paths": [
      {
        "path": "/protected/resource",
        "claim-information-point": {
          "http": {
            "claims": {
              "claim-a": "/a",
              "claim-d": "/d",
              "claim-d0": "/d/0",
              "claim-d-all": ["/d/0", "/d/1"]
            },
            "url": "http://mycompany/claim-provider",
            "method": "POST",
            "headers": {
              "Content-Type": "application/x-www-form-urlencoded",
              "header-b": ["header-b-value1", "header-b-value2"],
              "Authorization": "Bearer {keycloak.access_token}"
            },
            "parameters": {
              "param-a": ["param-a-value1", "param-a-value2"],
              "param-subject": "{keycloak.access_token['/sub']}",
              "param-user-name": "{keycloak.access_token['/preferred_username']}",
              "param-other-claims": "{keycloak.access_token['/custom_claim']}"
            }
          }
        }
      }
    ]
  }</pre>
					</p></div></section><section class="section" id="static_claims"><div class="titlepage"><div><div><h3 class="title">9.2.3. Static claims</h3></div></div></div><div class="formalpara"><p class="title"><strong>keycloak.json</strong></p><p>
						
<pre class="programlisting language-json">"policy-enforcer": {
    "paths": [
      {
        "path": "/protected/resource",
        "claim-information-point": {
          "claims": {
            "claim-from-static-value": "static value",
            "claim-from-multiple-static-value": ["static", "value"],
          }
        }
      }
    ]
  }</pre>
					</p></div></section><section class="section" id="claim_information_provider_spi"><div class="titlepage"><div><div><h3 class="title">9.2.4. Claim information provider SPI</h3></div></div></div><p>
					The Claim Information Provider SPI can be used by developers to support different claim information points in case none of the built-ins providers are enough to address their requirements.
				</p><p>
					For example, to implement a new CIP provider you need to implement <code class="literal">org.keycloak.adapters.authorization.ClaimInformationPointProviderFactory</code> and <code class="literal">ClaimInformationPointProvider</code> and also provide the file <code class="literal">META-INF/services/org.keycloak.adapters.authorization.ClaimInformationPointProviderFactory</code> in your application`s classpath.
				</p><p>
					Example of <code class="literal">org.keycloak.adapters.authorization.ClaimInformationPointProviderFactory</code>:
				</p><pre class="programlisting language-java">public class MyClaimInformationPointProviderFactory implements ClaimInformationPointProviderFactory&lt;MyClaimInformationPointProvider&gt; {

    @Override
    public String getName() {
        return "my-claims";
    }

    @Override
    public void init(PolicyEnforcer policyEnforcer) {

    }

    @Override
    public MyClaimInformationPointProvider create(Map&lt;String, Object&gt; config) {
        return new MyClaimInformationPointProvider(config);
    }
}</pre><p>
					Every CIP provider must be associated with a name, as defined above in the <code class="literal">MyClaimInformationPointProviderFactory.getName</code> method. The name will be used to map the configuration from the <code class="literal">claim-information-point</code> section in the <code class="literal">policy-enforcer</code> configuration to the implementation.
				</p><p>
					When processing requests, the policy enforcer will call the MyClaimInformationPointProviderFactory.create method in order to obtain an instance of MyClaimInformationPointProvider. When called, any configuration defined for this particular CIP provider (via claim-information-point) is passed as a map.
				</p><p>
					Example of <code class="literal">ClaimInformationPointProvider</code>:
				</p><pre class="programlisting language-java">public class MyClaimInformationPointProvider implements ClaimInformationPointProvider {

    private final Map&lt;String, Object&gt; config;

    public ClaimsInformationPointProvider(Map&lt;String, Object&gt; config) {
        this.config = config;
    }

    @Override
    public Map&lt;String, List&lt;String&gt;&gt; resolve(HttpFacade httpFacade) {
        Map&lt;String, List&lt;String&gt;&gt; claims = new HashMap&lt;&gt;();

        // put whatever claim you want into the map

        return claims;
    }
}</pre></section></section><section class="section" id="enforcer_authorization_context"><div class="titlepage"><div><div><h2 class="title">9.3. Obtaining the authorization context</h2></div></div></div><p>
				When policy enforcement is enabled, the permissions obtained from the server are available through <code class="literal">org.keycloak.AuthorizationContext</code>. This class provides several methods you can use to obtain permissions and ascertain whether a permission was granted for a particular resource or scope.
			</p><p>
				Obtaining the Authorization Context in a Servlet Container
			</p><pre class="programlisting language-java">    HttpServletRequest request = ... // obtain javax.servlet.http.HttpServletRequest
    KeycloakSecurityContext keycloakSecurityContext =
        (KeycloakSecurityContext) request
            .getAttribute(KeycloakSecurityContext.class.getName());
    AuthorizationContext authzContext =
        keycloakSecurityContext.getAuthorizationContext();</pre><div class="admonition note"><div class="admonition_header">Note</div><div><p>
					For more details about how you can obtain a <code class="literal">KeycloakSecurityContext</code> consult the adapter configuration. The example above should be sufficient to obtain the context when running an application using any of the servlet containers supported by Red Hat Single Sign-On.
				</p></div></div><p>
				The authorization context helps give you more control over the decisions made and returned by the server. For example, you can use it to build a dynamic menu where items are hidden or shown depending on the permissions associated with a resource or scope.
			</p><pre class="programlisting language-java">if (authzContext.hasResourcePermission("Project Resource")) {
    // user can access the Project Resource
}

if (authzContext.hasResourcePermission("Admin Resource")) {
    // user can access administration resources
}

if (authzContext.hasScopePermission("urn:project.com:project:create")) {
    // user can create new projects
}</pre><p>
				The <code class="literal">AuthorizationContext</code> represents one of the main capabilities of Red Hat Single Sign-On Authorization Services. From the examples above, you can see that the protected resource is not directly associated with the policies that govern them.
			</p><p>
				Consider some similar code using role-based access control (RBAC):
			</p><pre class="programlisting language-java">if (User.hasRole('user')) {
    // user can access the Project Resource
}

if (User.hasRole('admin')) {
    // user can access administration resources
}

if (User.hasRole('project-manager')) {
    // user can create new projects
}</pre><p>
				Although both examples address the same requirements, they do so in different ways. In RBAC, roles only <span class="emphasis"><em>implicitly</em></span> define access for their resources. With Red Hat Single Sign-On you gain the capability to create more manageable code that focuses directly on your resources whether you are using RBAC, attribute-based access control (ABAC), or any other BAC variant. Either you have the permission for a given resource or scope, or you don’t.
			</p><p>
				Now, suppose your security requirements have changed and in addition to project managers, PMOs can also create new projects.
			</p><p>
				Security requirements change, but with Red Hat Single Sign-On there is no need to change your application code to address the new requirements. Once your application is based on the resource and scope identifier, you need only change the configuration of the permissions or policies associated with a particular resource in the authorization server. In this case, the permissions and policies associated with the <code class="literal">Project Resource</code> and/or the scope <code class="literal">urn:project.com:project:create</code> would be changed.
			</p></section><section class="section" id="using_the_authorizationcontext_to_obtain_an_authorization_client_instance"><div class="titlepage"><div><div><h2 class="title">9.4. Using the AuthorizationContext to obtain an Authorization Client Instance</h2></div></div></div><p>
				The <code class="literal"><code class="literal">AuthorizationContext</code></code> can also be used to obtain a reference to the <a class="link" href="#service_client_api" title="8.6. Authorization client java API">Authorization Client API</a> configured to your application:
			</p><pre class="programlisting language-java">    ClientAuthorizationContext clientContext = ClientAuthorizationContext.class.cast(authzContext);
    AuthzClient authzClient = clientContext.getClient();</pre><p>
				In some cases, resource servers protected by the policy enforcer need to access the APIs provided by the authorization server. With an <code class="literal"><code class="literal">AuthzClient</code></code> instance in hands, resource servers can interact with the server in order to create resources or check for specific permissions programmatically.
			</p></section><section class="section" id="enforcer_js_adapter"><div class="titlepage"><div><div><h2 class="title">9.5. JavaScript integration</h2></div></div></div><p>
				The Red Hat Single Sign-On Server comes with a JavaScript library you can use to interact with a resource server protected by a policy enforcer. This library is based on the Red Hat Single Sign-On JavaScript adapter, which can be integrated to allow your client to obtain permissions from a Red Hat Single Sign-On Server.
			</p><p>
				You can obtain this library from a running a Red Hat Single Sign-On Server instance by including the following <code class="literal">script</code> tag in your web page:
			</p><pre class="programlisting language-html">&lt;script src="http://.../auth/js/keycloak-authz.js"&gt;&lt;/script&gt;</pre><p>
				Once you do that, you can create a <code class="literal">KeycloakAuthorization</code> instance as follows:
			</p><pre class="programlisting language-javascript">var keycloak = ... // obtain a Keycloak instance from keycloak.js library
var authorization = new KeycloakAuthorization(keycloak);</pre><p>
				The <span class="strong strong"><strong>keycloak-authz.js</strong></span> library provides two main features:
			</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">
						Obtain permissions from the server using a permission ticket, if you are accessing a UMA protected resource server.
					</li><li class="listitem">
						Obtain permissions from the server by sending the resources and scopes the application wants to access.
					</li></ul></div><p>
				In both cases, the library allows you to easily interact with both resource server and Red Hat Single Sign-On Authorization Services to obtain tokens with permissions your client can use as bearer tokens to access the protected resources on a resource server.
			</p><section class="section" id="handling_authorization_responses_from_a_uma_protected_resource_server"><div class="titlepage"><div><div><h3 class="title">9.5.1. Handling authorization responses from a UMA-Protected resource server</h3></div></div></div><p>
					If a resource server is protected by a policy enforcer, it responds to client requests based on the permissions carried along with a bearer token. Typically, when you try to access a resource server with a bearer token that is lacking permissions to access a protected resource, the resource server responds with a <span class="strong strong"><strong>401</strong></span> status code and a <code class="literal">WWW-Authenticate</code> header.
				</p><pre class="programlisting language-bash">HTTP/1.1 401 Unauthorized
WWW-Authenticate: UMA realm="${realm}",
    as_uri="https://${host}:${port}/auth/realms/${realm}",
    ticket="016f84e8-f9b9-11e0-bd6f-0021cc6004de"</pre><p>
					See <a class="link" href="#service_uma_authorization_process" title="8.3.1. Authorization process">UMA Authorization Process</a> for more information.
				</p><p>
					What your client needs to do is extract the permission ticket from the <code class="literal"><code class="literal">WWW-Authenticate</code></code> header returned by the resource server and use the library to send an authorization request as follows:
				</p><pre class="programlisting language-javascript">// prepare a authorization request with the permission ticket
var authorizationRequest = {};
authorizationRequest.ticket = ticket;

// send the authorization request, if successful retry the request
Identity.authorization.authorize(authorizationRequest).then(function (rpt) {
    // onGrant
}, function () {
    // onDeny
}, function () {
    // onError
});</pre><p>
					The <code class="literal">authorize</code> function is completely asynchronous and supports a few callback functions to receive notifications from the server:
				</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">
							<code class="literal">onGrant</code>: The first argument of the function. If authorization was successful and the server returned an RPT with the requested permissions, the callback receives the RPT.
						</li><li class="listitem">
							<code class="literal">onDeny</code>: The second argument of the function. Only called if the server has denied the authorization request.
						</li><li class="listitem">
							<code class="literal">onError</code>: The third argument of the function. Only called if the server responds unexpectedly.
						</li></ul></div><p>
					Most applications should use the <code class="literal">onGrant</code> callback to retry a request after a 401 response. Subsequent requests should include the RPT as a bearer token for retries.
				</p></section><section class="section" id="obtaining_entitlements"><div class="titlepage"><div><div><h3 class="title">9.5.2. Obtaining entitlements</h3></div></div></div><p>
					The <code class="literal"><code class="literal">keycloak-authz.js</code></code> library provides an <code class="literal">entitlement</code> function that you can use to obtain an RPT from the server by providing the resources and scopes your client wants to access.
				</p><div class="formalpara"><p class="title"><strong>Example about how to obtain an RPT with permissions for all resources and scopes the user can access</strong></p><p>
						
<pre class="programlisting language-javascript">authorization.entitlement('my-resource-server-id').then(function (rpt) {
    // onGrant callback function.
    // If authorization was successful you'll receive an RPT
    // with the necessary permissions to access the resource server
});</pre>
					</p></div><div class="formalpara"><p class="title"><strong>Example about how to obtain an RPT with permissions for specific resources and scopes</strong></p><p>
						
<pre class="programlisting language-javascript">authorization.entitlement('my-resource-server', {
    "permissions": [
        {
            "id" : "Some Resource"
        }
    ]
}).then(function (rpt) {
    // onGrant
});</pre>
					</p></div><p>
					When using the <code class="literal">entitlement</code> function, you must provide the <span class="emphasis"><em>client_id</em></span> of the resource server you want to access.
				</p><p>
					The <code class="literal">entitlement</code> function is completely asynchronous and supports a few callback functions to receive notifications from the server:
				</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">
							<code class="literal">onGrant</code>: The first argument of the function. If authorization was successful and the server returned an RPT with the requested permissions, the callback receives the RPT.
						</li><li class="listitem">
							<code class="literal">onDeny</code>: The second argument of the function. Only called if the server has denied the authorization request.
						</li><li class="listitem">
							<code class="literal">onError</code>: The third argument of the function. Only called if the server responds unexpectedly.
						</li></ul></div></section><section class="section" id="authorization_request"><div class="titlepage"><div><div><h3 class="title">9.5.3. Authorization request</h3></div></div></div><p>
					Both <code class="literal"><code class="literal">authorize</code></code> and <code class="literal"><code class="literal">entitlement</code></code> functions accept an authorization request object. This object can be set with the following properties:
				</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p class="simpara">
							<span class="strong strong"><strong>permissions</strong></span>
						</p><p class="simpara">
							An array of objects representing the resource and scopes. For instance:
						</p><pre class="programlisting language-javascript">var authorizationRequest = {
   "permissions": [
       {
           "id" : "Some Resource",
           "scopes" : ["view", "edit"]
       }
   ]
}</pre></li><li class="listitem"><p class="simpara">
							<span class="strong strong"><strong>metadata</strong></span>
						</p><p class="simpara">
							An object where its properties define how the authorization request should be processed by the server.
						</p><div class="itemizedlist"><ul class="itemizedlist" type="circle"><li class="listitem"><p class="simpara">
									<span class="strong strong"><strong>response_include_resource_name</strong></span>
								</p><p class="simpara">
									A boolean value indicating to the server if resource names should be included in the RPT’s permissions. If false, only the resource identifier is included.
								</p></li><li class="listitem"><p class="simpara">
									<span class="strong strong"><strong>response_permissions_limit</strong></span>
								</p><p class="simpara">
									An integer N that defines a limit for the amount of permissions an RPT can have. When used together with <code class="literal">rpt</code> parameter, only the last N requested permissions will be kept in the RPT
								</p></li></ul></div></li><li class="listitem"><p class="simpara">
							<span class="strong strong"><strong>submit_request</strong></span>
						</p><p class="simpara">
							A boolean value indicating whether the server should create permission requests to the resources and scopes referenced by a permission ticket. This parameter will only take effect when used together with the <code class="literal">ticket</code> parameter as part of a UMA authorization process.
						</p></li></ul></div></section><section class="section" id="obtaining_the_rpt"><div class="titlepage"><div><div><h3 class="title">9.5.4. Obtaining the RPT</h3></div></div></div><p>
					If you have already obtained an RPT using any of the authorization functions provided by the library, you can always obtain the RPT as follows from the authorization object (assuming that it has been initialized by one of the techniques shown earlier):
				</p><pre class="programlisting language-javascript">var rpt = authorization.rpt;</pre></section></section><section class="section" id="enforcer_filter_using_https"><div class="titlepage"><div><div><h2 class="title">9.6. Configuring TLS/HTTPS</h2></div></div></div><p>
				When the server is using HTTPS, ensure your adapter is configured as follows:
			</p><div class="formalpara"><p class="title"><strong>keycloak.json</strong></p><p>
					
<pre class="programlisting language-json">{
  "truststore": "path_to_your_trust_store",
  "truststore-password": "trust_store_password"
}</pre>
				</p></div><p>
				The configuration above enables TLS/HTTPS to the Authorization Client, making possible to access a Red Hat Single Sign-On Server remotely using the HTTPS scheme.
			</p><div class="admonition note"><div class="admonition_header">Note</div><div><p>
					It is strongly recommended that you enable TLS/HTTPS when accessing the Red Hat Single Sign-On Server endpoints.
				</p></div></div></section></section><div><div xml:lang="en-US" class="legalnotice" id="idm139768737258128"><h1 class="legalnotice">Legal Notice</h1><div class="para">
				Copyright <span class="trademark"/>© 2019 Red Hat, Inc.
			</div><div class="para">
				Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with the License. You may obtain a copy of the License at
			</div><div class="para">
				<a class="ulink" href="http://www.apache.org/licenses/LICENSE-2.0"> http://www.apache.org/licenses/LICENSE-2.0</a>
			</div><div class="para">
				Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.
			</div></div></div></div></div></div><script type="text/javascript">
                        jQuery(document).ready(function() {
                            initSwitchery();
                            jQuery('pre[class*="language-"]').each(function(i, block){hljs.highlightBlock(block);});
                        });
                    </script></body></html>